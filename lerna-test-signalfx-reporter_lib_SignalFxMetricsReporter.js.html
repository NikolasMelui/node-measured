<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: lerna-test-signalfx-reporter/lib/SignalFxMetricsReporter.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: lerna-test-signalfx-reporter/lib/SignalFxMetricsReporter.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const bunyan = require('bunyan');
const Optional = require('optional-js');
const { validateRequiredSignalFxMetricsReporterParameters } = require('./validators/inputValidators');

/**
 * A Interval Based Metrics Reporter that is aware of Measure metrics types and reports them to Signal Fx
 * @implements {Reporter}
 */
class SignalFxMetricsReporter {
  /**
   * @param {SignalFxClient} signalFxClient The configured signal fx client.
   * @param {DimensionAwareMetricsRegistry} registry The Metrics registry.
   * @param {SignalFxMetricsReporterOptions} options See {@link SignalFxMetricsReporterOptions}.
   */
  constructor(signalFxClient, registry, options) {
    validateRequiredSignalFxMetricsReporterParameters(signalFxClient, registry, options);

    this._intervalToMetric = {};
    this._signalFxClient = signalFxClient;
    this._registry = registry;
    this._defaultDimensions = Object.prototype.hasOwnProperty.call(options, 'defaultDimensions')
      ? options.defaultDimensions
      : {};
    this._log = Object.prototype.hasOwnProperty.call(options, 'logger')
      ? options.logger
      : bunyan.createLogger({ name: 'SignalFxMetricsReporter', level: 'info' });
  }

  /**
   * Informs the reporter to report a metric on a given interval in seconds.
   * @param {string} metricKey The metric key for the metric in the metric registry.
   * @param {number} intervalInSeconds The interval in seconds to report the metric on.
   */
  reportMetricOnInterval(metricKey, intervalInSeconds) {
    if (Object.prototype.hasOwnProperty.call(this._intervalToMetric, intervalInSeconds)) {
      this._intervalToMetric[intervalInSeconds].add(metricKey);
    } else {
      this._intervalToMetric[intervalInSeconds] = new Set([metricKey]);
      this._sendMetricsWithInterval(intervalInSeconds);
      this._createTimedCallback(intervalInSeconds);
    }
  }

  /**
   * Creates the timed callback loop for the given interval.
   * @param {number} intervalInSeconds the interval in seconds for the timeout callback
   * @private
   */
  _createTimedCallback(intervalInSeconds) {
    this._log.debug(`createTimedCallback() called with intervalInSeconds: ${intervalInSeconds}`);
    setTimeout(() => {
      this._sendMetricsWithInterval(intervalInSeconds);
      this._createTimedCallback(intervalInSeconds);
    }, intervalInSeconds * 1000);
  }

  /**
   * Gathers all the metrics that have been registered to report on the given interval
   * @param {number} interval The interval to look up what metrics to report
   * @private
   */
  _sendMetricsWithInterval(interval) {
    this._log.debug(`sendMetricsWithInterval() called with intervalInSeconds: ${interval}`);
    try {
      Optional.of(this._intervalToMetric[interval]).ifPresent(metrics => {
        const metricsToSend = [];
        metrics.forEach(metricKey => {
          metricsToSend.push(this._registry.getMetricWrapperByKey(metricKey));
          this._sendMetrics(metricsToSend);
        });
      });
    } catch (error) {
      this._log.error('Failed to send metrics to signal fx', error);
    }
  }

  /**
   * Sends metrics to signal fx, converting name and dimensions and {@link Metric} to data signal fx can ingest
   * @param {MetricWrapper[]} metrics The array of metrics to send to signal fx.
   * @private
   */
  _sendMetrics(metrics) {
    this._log.debug('sendMetrics() called');

    let signalFxDataPointRequest = {};

    metrics.forEach(metric => {
      if (!metric) {
        this._log.warn('Metric was null when it should not have been');
        return;
      }
      signalFxDataPointRequest = this._processMetric(metric, signalFxDataPointRequest);
    });

    this._log.debug('Sending data to Signal Fx');

    this._signalFxClient.send(signalFxDataPointRequest).catch(error => {
      this._log.error('Failed to send metrics to signal fx error:', error);
    });
  }

  /**
   * Method for getting raw signal fx api request values from the Timer Object.
   *
   * @param {MetricWrapper} metric metric The Wrapped Metric Object.
   * @param {any} currentBuiltRequest The signal fx request that is being built.
   * @return {any} the currentBuiltRequest The signal fx request that is being built with the given metric in it.
   * @private
   */
  _processMetric(metric, currentBuiltRequest) {
    const newRequest = Object.assign({}, currentBuiltRequest);

    const { metricName, metricImpl, dimensions } = metric;
    const mergedDimensions = Object.assign({}, this._defaultDimensions, dimensions);

    const valuesToProcess = this._getValuesToProcessForType(metricName, metricImpl);

    valuesToProcess.forEach(metricValueTypeWrapper => {
      const signalFxDataPointMetric = {
        metric: metricValueTypeWrapper.metric,
        value: metricValueTypeWrapper.value,
        dimensions: mergedDimensions
      };

      if (Object.prototype.hasOwnProperty.call(newRequest, metricValueTypeWrapper.type)) {
        newRequest[metricValueTypeWrapper.type].push(signalFxDataPointMetric);
      } else {
        newRequest[metricValueTypeWrapper.type] = [signalFxDataPointMetric];
      }
    });

    return newRequest;
  }

  /**
   * Maps Measured Metrics Object JSON outputs to there respective signal fx metrics using logic from
   * com.signalfx.codahale.reporter.AggregateMetricSenderSessionWrapper in the java lib to derive naming
   *
   * @param {string} name The registered metric base name
   * @param {Metric} metric The metric.
   * @return {MetricValueTypeWrapper[]} an array of MetricValueTypeWrapper that can be used to
   * build the sig fx data point request
   * @private
   */
  _getValuesToProcessForType(name, metric) {
    const type = metric.constructor.name;
    switch (type.toLowerCase()) {
      case 'timer':
        return this._getValuesToProcessForTimer(name, metric);
      case 'gauge':
        return this._getValuesToProcessForGauge(name, metric);
      case 'counter':
        return this._getValuesToProcessForCounter(name, metric);
      case 'histogram':
        return this._getValuesToProcessForHistogram(name, metric);
      default:
        this._log.error(`Metric Type: ${type} has not been implemented to report to signal fx`);
        return [];
    }
  }

  /**
   * Maps and Filters values from a Timer to a set of metrics to report to SigFx.
   *
   * @param {string} name The registry name
   * @param {Timer} timer The Timer
   * @return {MetricValueTypeWrapper[]} Returns an array of MetricValueTypeWrapper to use to build the request
   * @private
   */
  _getValuesToProcessForTimer(name, timer) {
    let valuesToProcess = [];
    valuesToProcess = valuesToProcess.concat(this._getValuesToProcessForHistogram(name, timer.toJSON().histogram));
    return valuesToProcess;
  }

  /**
   * Maps and Filters values from a Gauge to a set of metrics to report to SigFx.
   *
   * @param {string} name The registry name
   * @param {Gauge} gauge The Gauge
   * @return {MetricValueTypeWrapper[]} Returns an array of MetricValueTypeWrapper to use to build the request
   * @private
   */
  _getValuesToProcessForGauge(name, gauge) {
    const valuesToProcess = [];
    valuesToProcess.push({
      metric: `${name}`,
      value: gauge.toJSON(),
      type: SIGNAL_FX_GAUGE
    });
    return valuesToProcess;
  }

  /**
   * Maps and Filters values from a Counter to a set of metrics to report to SigFx.
   *
   * @param {string} name The registry name
   * @param {Counter} counter The data from the measure metric object
   * @return {MetricValueTypeWrapper[]} Returns an array of MetricValueTypeWrapper to use to build the request
   * @private
   */
  _getValuesToProcessForCounter(name, counter) {
    const valuesToProcess = [];
    valuesToProcess.push({
      metric: `${name}.count`,
      value: counter.toJSON(),
      type: SIGNAL_FX_CUMULATIVE_COUNTER
    });
    return valuesToProcess;
  }

  /**
   * Maps and Filters values from a Histogram to a set of metrics to report to SigFx.
   *
   * @param {string} name The registry name
   * @param {Histogram} histogram The Histogram
   * @return {MetricValueTypeWrapper[]} Returns an array of MetricValueTypeWrapper to use to build the request
   * @private
   */
  _getValuesToProcessForHistogram(name, histogram) {
    const data = histogram.toJSON();
    const valuesToProcess = [];
    valuesToProcess.push({
      metric: `${name}.count`,
      value: data.count,
      type: SIGNAL_FX_CUMULATIVE_COUNTER
    });
    valuesToProcess.push({
      metric: `${name}.max`,
      value: data.max,
      type: SIGNAL_FX_GAUGE
    });
    valuesToProcess.push({
      metric: `${name}.min`,
      value: data.min,
      type: SIGNAL_FX_GAUGE
    });
    valuesToProcess.push({
      metric: `${name}.mean`,
      value: data.mean,
      type: SIGNAL_FX_GAUGE
    });
    valuesToProcess.push({
      metric: `${name}.p95`,
      value: data.p95,
      type: SIGNAL_FX_GAUGE
    });
    valuesToProcess.push({
      metric: `${name}.p99`,
      value: data.p99,
      type: SIGNAL_FX_GAUGE
    });
    return valuesToProcess;
  }
}

// const SIGNAL_FX_COUNTER = 'counters';
const SIGNAL_FX_GAUGE = 'gauges';
const SIGNAL_FX_CUMULATIVE_COUNTER = 'cumulative_counters';

module.exports = {
  SignalFxMetricsReporter
};

/**
 * Wrapper object to wrap metric value and SFX metadata needed to send metric value to SFX data ingestion.
 *
 * @interface MetricValueTypeWrapper
 * @typedef MetricValueTypeWrapper
 * @type {Object}
 * @property {string} metric The metric name to report to SignalFx
 * @property {number} value the value to report to SignalFx
 * @property {string} type The mapped SignalFx metric type
 */

/**
 * Options for creating a {@link SignalFxMetricsReporter}
 * @interface SignalFxMetricsReporterOptions
 * @typedef SignalFxMetricsReporterOptions
 * @type {Object}
 * @property {Dimensions} defaultDimensions A dictionary of dimensions to include with every metric reported
 * @property {Logger} logger The logger to use, if not supplied a new Buynan logger will be created
 */
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-measured.html">measured</a></li><li><a href="module-units.html">units</a></li></ul><h3>Classes</h3><ul><li><a href="BinaryHeap.html">BinaryHeap</a></li><li><a href="Collection.html">Collection</a></li><li><a href="Counter.html">Counter</a></li><li><a href="DimensionAwareMetricsRegistry.html">DimensionAwareMetricsRegistry</a></li><li><a href="ExponentiallyDecayingSample.html">ExponentiallyDecayingSample</a></li><li><a href="ExponentiallyMovingWeightedAverage.html">ExponentiallyMovingWeightedAverage</a></li><li><a href="Gauge.html">Gauge</a></li><li><a href="Histogram.html">Histogram</a></li><li><a href="Meter.html">Meter</a></li><li><a href="NoOpMeter.html">NoOpMeter</a></li><li><a href="SelfReportingMetricsRegistry.html">SelfReportingMetricsRegistry</a></li><li><a href="SettableGauge.html">SettableGauge</a></li><li><a href="SignalFxMetricsReporter.html">SignalFxMetricsReporter</a></li><li><a href="Stopwatch.html">Stopwatch</a></li><li><a href="Timer.html">Timer</a></li></ul><h3>Interfaces</h3><ul><li><a href="IntervalBasedMetricsReporter.html">IntervalBasedMetricsReporter</a></li><li><a href="Metric.html">Metric</a></li><li><a href="Reporter.html">Reporter</a></li></ul><h3><a href="global.html">Global</a></h3>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Fri May 18 2018 16:34:35 GMT+0000 (UTC)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
