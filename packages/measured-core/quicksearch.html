<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"util_BinaryHeap.js.html":{"id":"util_BinaryHeap.js.html","title":"Source: util/BinaryHeap.js","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterSettableGaugeStopwatchTimer Interfaces MetricMetricTypes Global Global Source: util/BinaryHeap.js /** * Based on http://en.wikipedia.org/wiki/Binary_Heap * as well as http://eloquentjavascript.net/appendix2.html */ class BinaryHeap { constructor(options) { options = options || {}; this._elements = options.elements || []; this._score = options.score || this._score; } /** * Add elements to the binary heap. * @param {any[]} elements */ add(...elements) { elements.forEach(element =&gt; { this._elements.push(element); this._bubble(this._elements.length - 1); }); } first() { return this._elements[0]; } removeFirst() { const root = this._elements[0]; const last = this._elements.pop(); if (this._elements.length &gt; 0) { this._elements[0] = last; this._sink(0); } return root; } clone() { return new BinaryHeap({ elements: this.toArray(), score: this._score }); } toSortedArray() { const array = []; const clone = this.clone(); let element; while (true) { element = clone.removeFirst(); if (element === undefined) { break; } array.push(element); } return array; } toArray() { return [].concat(this._elements); } size() { return this._elements.length; } _bubble(bubbleIndex) { const bubbleElement = this._elements[bubbleIndex]; const bubbleScore = this._score(bubbleElement); let parentIndex; let parentElement; let parentScore; while (bubbleIndex &gt; 0) { parentIndex = this._parentIndex(bubbleIndex); parentElement = this._elements[parentIndex]; parentScore = this._score(parentElement); if (bubbleScore &lt;= parentScore) { break; } this._elements[parentIndex] = bubbleElement; this._elements[bubbleIndex] = parentElement; bubbleIndex = parentIndex; } } _sink(sinkIndex) { const sinkElement = this._elements[sinkIndex]; const sinkScore = this._score(sinkElement); const { length } = this._elements; let swapIndex; let swapScore; let swapElement; let childIndexes; let i; let childIndex; let childElement; let childScore; while (true) { swapIndex = null; swapScore = null; swapElement = null; childIndexes = this._childIndexes(sinkIndex); for (i = 0; i &lt; childIndexes.length; i++) { childIndex = childIndexes[i]; if (childIndex &gt;= length) { break; } childElement = this._elements[childIndex]; childScore = this._score(childElement); if (childScore &gt; sinkScore) { if (swapScore === null || swapScore &lt; childScore) { swapIndex = childIndex; swapScore = childScore; swapElement = childElement; } } } if (swapIndex === null) { break; } this._elements[swapIndex] = sinkElement; this._elements[sinkIndex] = swapElement; sinkIndex = swapIndex; } } _parentIndex(index) { return Math.floor((index - 1) / 2); } _childIndexes(index) { return [2 * index + 1, 2 * index + 2]; } _score(element) { return element.valueOf(); } } module.exports = BinaryHeap; × Search results Close "},"Collection.js.html":{"id":"Collection.js.html","title":"Source: Collection.js","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterSettableGaugeStopwatchTimer Interfaces MetricMetricTypes Global Global Source: Collection.js const Optional = require('optional-js'); const Counter = require('./metrics/Counter'); const Gauge = require('./metrics/Gauge'); const SettableGauge = require('./metrics/SettableGauge'); const Histogram = require('./metrics/Histogram'); const Meter = require('./metrics/Meter'); const Timer = require('./metrics/Timer'); const { MetricTypes } = require('./metrics/Metric'); /** * A Simple collection that stores names and a {@link Metric} instances with a few convenience methods for * creating / registering and then gathering all data the registered metrics. * @example * var { Collection } = require('measured'); * const collection = new Collection('node-process-metrics'); * const gauge = collection.gauge('node.process.heap_used', () =&gt; { * return process.memoryUsage().heapUsed; * }); */ class Collection { /** * Creates a named collection of metrics * @param {string} [name] The name to use for this collection. */ constructor(name) { this.name = name; /** * internal map of metric name to {@link Metric} * @type {Object.&lt;string, Metric&gt;} * @private */ this._metrics = {}; } /** * register a metric that was created outside the provided convenience methods of this collection * @param name The metric name * @param metric The {@link Metric} implementation * @example * var { Collection, Gauge } = require('measured'); * const collection = new Collection('node-process-metrics'); * const gauge = new Gauge(() =&gt; { * return process.memoryUsage().heapUsed; * }); * collection.register('node.process.heap_used', gauge); */ register(name, metric) { this._metrics[name] = metric; } /** * Fetches the data/values from all registered metrics * @return {Object} The combined JSON object */ toJSON() { const json = {}; Object.keys(this._metrics).forEach(metric =&gt; { if (Object.prototype.hasOwnProperty.call(this._metrics, metric)) { json[metric] = this._metrics[metric].toJSON(); } }); if (!this.name) { return json; } const wrapper = {}; wrapper[this.name] = json; return wrapper; } /** * Gets or creates and registers a {@link Gauge} * @param {string} name The metric name * @param {function} readFn See {@link Gauge} * @return {Gauge} */ gauge(name, readFn) { this._validateName(name); let gauge; this._getMetricForNameAndType(name, MetricTypes.GAUGE).ifPresentOrElse( registeredMetric =&gt; { gauge = registeredMetric; }, () =&gt; { gauge = new Gauge(readFn); this.register(name, gauge); } ); return gauge; } /** * Gets or creates and registers a {@link Counter} * @param {string} name The metric name * @param {CounterProperties} [properties] See {@link CounterProperties} * @return {Counter} */ counter(name, properties) { this._validateName(name); let counter; this._getMetricForNameAndType(name, MetricTypes.COUNTER).ifPresentOrElse( registeredMetric =&gt; { counter = registeredMetric; }, () =&gt; { counter = new Counter(properties); this.register(name, counter); } ); return counter; } /** * Gets or creates and registers a {@link Histogram} * @param {string} name The metric name * @param {HistogramProperties} [properties] See {@link HistogramProperties} * @return {Histogram} */ histogram(name, properties) { this._validateName(name); let histogram; this._getMetricForNameAndType(name, MetricTypes.HISTOGRAM).ifPresentOrElse( registeredMetric =&gt; { histogram = registeredMetric; }, () =&gt; { histogram = new Histogram(properties); this.register(name, histogram); } ); return histogram; } /** * Gets or creates and registers a {@link Timer} * @param {string} name The metric name * @param {TimerProperties} [properties] See {@link TimerProperties} * @return {Timer} */ timer(name, properties) { this._validateName(name); let timer; this._getMetricForNameAndType(name, MetricTypes.TIMER).ifPresentOrElse( registeredMetric =&gt; { timer = registeredMetric; }, () =&gt; { timer = new Timer(properties); this.register(name, timer); } ); return timer; } /** * Gets or creates and registers a {@link Meter} * @param {string} name The metric name * @param {MeterProperties} [properties] See {@link MeterProperties} * @return {Meter} */ meter(name, properties) { this._validateName(name); let meter; this._getMetricForNameAndType(name, MetricTypes.METER).ifPresentOrElse( registeredMetric =&gt; { meter = registeredMetric; }, () =&gt; { meter = new Meter(properties); this.register(name, meter); } ); return meter; } /** * Gets or creates and registers a {@link SettableGauge} * @param {string} name The metric name * @param {SettableGaugeProperties} [properties] See {@link SettableGaugeProperties} * @return {SettableGauge} */ settableGauge(name, properties) { this._validateName(name); let settableGauge; this._getMetricForNameAndType(name, MetricTypes.METER).ifPresentOrElse( registeredMetric =&gt; { settableGauge = registeredMetric; }, () =&gt; { settableGauge = new SettableGauge(properties); this.register(name, settableGauge); } ); return settableGauge; } /** * Checks the registry for a metric with a given name and type, if it exists in the registry as a * different type an error is thrown. * @param {string} name The metric name * @param {string} requestedType The metric type * @return {Optional&lt;Metric&gt;} * @private */ _getMetricForNameAndType(name, requestedType) { if (this._metrics[name]) { const metric = this._metrics[name]; const actualType = metric.getType(); if (requestedType !== actualType) { throw new Error( `You requested a metric of type: ${requestedType} with name: ${name}, but it exists in the registry as type: ${actualType}` ); } return Optional.of(metric); } return Optional.empty(); } /** * Validates that the provided name is valid. * * @param name The provided metric name param. * @private */ _validateName(name) { if (!name || typeof name !== 'string') { throw new Error('You must supply a metric name'); } } /** * Calls end on all metrics in the registry that support end() */ end() { const metrics = this._metrics; Object.keys(metrics).forEach(name =&gt; { const metric = metrics[name]; if (metric.end) { metric.end(); } }); } } module.exports = Collection; × Search results Close "},"metrics_Counter.js.html":{"id":"metrics_Counter.js.html","title":"Source: metrics/Counter.js","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterSettableGaugeStopwatchTimer Interfaces MetricMetricTypes Global Global Source: metrics/Counter.js const { MetricTypes } = require('./Metric'); /** * Counters are things that increment or decrement * @implements {Metric} * @example * var Measured = require('measured') * var activeUploads = new Measured.Counter(); * http.createServer(function(req, res) { * activeUploads.inc(); * req.on('end', function() { * activeUploads.dec(); * }); * }); */ class Counter { /** * @param {CounterProperties} [properties] see {@link CounterProperties} */ constructor(properties) { properties = properties || {}; this._count = properties.count || 0; } /** * Counters directly return their currently value. * @return {number} */ toJSON() { return this._count; } /** * Increments the counter. * @param {number} n Increment the counter by n. Defaults to 1. */ inc(n) { this._count += arguments.length ? n : 1; } /** * Decrements the counter * @param {number} n Decrement the counter by n. Defaults to 1. */ dec(n) { this._count -= arguments.length ? n : 1; } /** * Resets the counter back to count Defaults to 0. * @param {number} count Resets the counter back to count Defaults to 0. */ reset(count) { this._count = count || 0; } /** * The type of the Metric Impl. {@link MetricTypes}. * @return {string} The type of the Metric Impl. */ getType() { return MetricTypes.COUNTER; } } module.exports = Counter; /** * Properties that can be supplied to the constructor of a {@link Counter} * * @interface CounterProperties * @typedef CounterProperties * @type {Object} * @property {number} count An initial count for the counter. Defaults to 0. * @example * // Creates a counter that starts at 5. * const counter = new Counter({ count: 5 }) */ × Search results Close "},"util_ExponentiallyDecayingSample.js.html":{"id":"util_ExponentiallyDecayingSample.js.html","title":"Source: util/ExponentiallyDecayingSample.js","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterSettableGaugeStopwatchTimer Interfaces MetricMetricTypes Global Global Source: util/ExponentiallyDecayingSample.js const BinaryHeap = require('./BinaryHeap'); const units = require('./units'); const RESCALE_INTERVAL = units.HOURS; const ALPHA = 0.015; const SIZE = 1028; /** * ExponentiallyDecayingSample */ class ExponentiallyDecayingSample { constructor(options) { options = options || {}; this._elements = new BinaryHeap({ score: element =&gt; -element.priority }); this._rescaleInterval = options.rescaleInterval || RESCALE_INTERVAL; this._alpha = options.alpha || ALPHA; this._size = options.size || SIZE; this._random = options.random || this._random; this._landmark = null; this._nextRescale = null; } update(value, timestamp) { const now = Date.now(); if (!this._landmark) { this._landmark = now; this._nextRescale = this._landmark + this._rescaleInterval; } timestamp = timestamp || now; const newSize = this._elements.size() + 1; const element = { priority: this._priority(timestamp - this._landmark), value: value }; if (newSize &lt;= this._size) { this._elements.add(element); } else if (element.priority &gt; this._elements.first().priority) { this._elements.removeFirst(); this._elements.add(element); } if (now &gt;= this._nextRescale) { this._rescale(now); } } toSortedArray() { return this._elements.toSortedArray().map(element =&gt; element.value); } toArray() { return this._elements.toArray().map(element =&gt; element.value); } toArrayWithWeights() { return this._elements.toArray(); } _weight(age) { // We divide by 1000 to not run into huge numbers before reaching a // rescale event. return Math.exp(this._alpha * (age / 1000)); } _priority(age) { return this._weight(age) / this._random(); } _random() { return Math.random(); } _rescale(now) { now = now || Date.now(); const self = this; const oldLandmark = this._landmark; this._landmark = now || Date.now(); this._nextRescale = now + this._rescaleInterval; const factor = self._priority(-(self._landmark - oldLandmark)); this._elements.toArray().forEach(element =&gt; { element.priority *= factor; }); } } module.exports = ExponentiallyDecayingSample; × Search results Close "},"util_ExponentiallyMovingWeightedAverage.js.html":{"id":"util_ExponentiallyMovingWeightedAverage.js.html","title":"Source: util/ExponentiallyMovingWeightedAverage.js","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterSettableGaugeStopwatchTimer Interfaces MetricMetricTypes Global Global Source: util/ExponentiallyMovingWeightedAverage.js const units = require('./units'); const TICK_INTERVAL = 5 * units.SECONDS; /** * ExponentiallyMovingWeightedAverage */ class ExponentiallyMovingWeightedAverage { constructor(timePeriod, tickInterval) { this._timePeriod = timePeriod || units.MINUTE; this._tickInterval = tickInterval || TICK_INTERVAL; this._alpha = 1 - Math.exp(-this._tickInterval / this._timePeriod); this._count = 0; this._rate = 0; } update(n) { this._count += n; } tick() { const instantRate = this._count / this._tickInterval; this._count = 0; this._rate += this._alpha * (instantRate - this._rate); } rate(timeUnit) { return (this._rate || 0) * timeUnit; } } module.exports = ExponentiallyMovingWeightedAverage; × Search results Close "},"metrics_Gauge.js.html":{"id":"metrics_Gauge.js.html","title":"Source: metrics/Gauge.js","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterSettableGaugeStopwatchTimer Interfaces MetricMetricTypes Global Global Source: metrics/Gauge.js const { MetricTypes } = require('./Metric'); /** * Values that can be read instantly * @implements {Metric} * @example * var Measured = require('measured') * var gauge = new Measured.Gauge(function() { * return process.memoryUsage().rss; * }); */ class Gauge { /** * @param {function} readFn A function that returns the numeric value for this gauge. */ constructor(readFn) { this._readFn = readFn; } /** * This is sync for now, but maybe async gauges would be useful as well? * @return {number} Gauges directly return the value from the callback which should be a number. */ toJSON() { return this._readFn(); } /** * The type of the Metric Impl. {@link MetricTypes}. * @return {string} The type of the Metric Impl. */ getType() { return MetricTypes.GAUGE; } } module.exports = Gauge; × Search results Close "},"metrics_Histogram.js.html":{"id":"metrics_Histogram.js.html","title":"Source: metrics/Histogram.js","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterSettableGaugeStopwatchTimer Interfaces MetricMetricTypes Global Global Source: metrics/Histogram.js const { MetricTypes } = require('./Metric'); const binarySearch = require('binary-search'); const EDS = require('../util/ExponentiallyDecayingSample'); /** * Keeps a reservoir of statistically relevant values biased towards the last 5 minutes to explore their distribution. * @implements {Metric} * @example * var Measured = require('measured') * var histogram = new Measured.Histogram(); * http.createServer(function(req, res) { * if (req.headers['content-length']) { * histogram.update(parseInt(req.headers['content-length'], 10)); * } * }); */ class Histogram { /** @param {HistogramProperties} [properties] see {@link HistogramProperties}. */ constructor(properties) { this._properties = properties || {}; this._initializeState(); } _initializeState() { this._sample = this._properties.sample || new EDS(); this._percentilesMethod = this._properties.percentilesMethod || this._percentiles; this._min = null; this._max = null; this._count = 0; this._sum = 0; // These are for the Welford algorithm for calculating running constiance // without floating-point doom. this._constianceM = 0; this._constianceS = 0; } /** * Pushes value into the sample. timestamp defaults to Date.now(). * @param {number} value */ update(value) { this._count++; this._sum += value; this._sample.update(value); this._updateMin(value); this._updateMax(value); this._updateVariance(value); } _percentiles(percentiles) { const values = this._sample.toArray().sort((a, b) =&gt; { return a === b ? 0 : a - b; }); const results = {}; let i, percentile, pos, lower, upper; for (i = 0; i &lt; percentiles.length; i++) { percentile = percentiles[i]; if (values.length) { pos = percentile * (values.length + 1); if (pos &lt; 1) { results[percentile] = values[0]; } else if (pos &gt;= values.length) { results[percentile] = values[values.length - 1]; } else { lower = values[Math.floor(pos) - 1]; upper = values[Math.ceil(pos) - 1]; results[percentile] = lower + (pos - Math.floor(pos)) * (upper - lower); } } else { results[percentile] = null; } } return results; } weightedPercentiles(percentiles) { const values = this._sample.toArrayWithWeights().sort((a, b) =&gt; { return a.value === b.value ? 0 : a.value - b.value; }); const sumWeight = values.reduce((sum, sample) =&gt; { return sum + sample.priority; }, 0); const normWeights = values.map(value =&gt; { return value.priority / sumWeight; }); const quantiles = [0]; let i; for (i = 1; i &lt; values.length; i++) { quantiles[i] = quantiles[i - 1] + normWeights[i - 1]; } function gt(a, b) { return a - b; } const results = {}; let percentile, pos; for (i = 0; i &lt; percentiles.length; i++) { percentile = percentiles[i]; if (values.length) { pos = binarySearch(quantiles, percentile, gt); if (pos &lt; 0) { results[percentile] = values[-pos - 1 - 1].value; } else if (pos &lt; 1) { results[percentile] = values[0].value; } else if (pos &gt;= values.length) { results[percentile] = values[values.length - 1].value; } } else { results[percentile] = null; } } return results; } /** * Resets all values. Histograms initialized with custom options will be reset to the default settings (patch welcome). */ reset() { // while this is technically a bug?, copying existing logic to maintain current api, // TODO reset should reset the sample, not override it with a new EDS() this._properties.sample = new EDS(); this._initializeState(); } /** * Checks whether the histogram contains values. * @return {boolean} Whether the histogram contains values. */ hasValues() { return this._count &gt; 0; } /** * @return {HistogramData} */ toJSON() { const percentiles = this._percentilesMethod([0.5, 0.75, 0.95, 0.99, 0.999]); return { min: this._min, max: this._max, sum: this._sum, variance: this._calculateVariance(), mean: this._calculateMean(), stddev: this._calculateStddev(), count: this._count, median: percentiles[0.5], p75: percentiles[0.75], p95: percentiles[0.95], p99: percentiles[0.99], p999: percentiles[0.999] }; } _updateMin(value) { if (this._min === null || value &lt; this._min) { this._min = value; } } _updateMax(value) { if (this._max === null || value &gt; this._max) { this._max = value; } } _updateVariance(value) { if (this._count === 1) { this._constianceM = value; return value; } const oldM = this._constianceM; this._constianceM += (value - oldM) / this._count; this._constianceS += (value - oldM) * (value - this._constianceM); // TODO is this right, above it returns in the if statement but does nothing but update internal state for the else case? return undefined; } /** * * @return {number|null} * @private */ _calculateMean() { return this._count === 0 ? 0 : this._sum / this._count; } /** * @return {number|null} * @private */ _calculateVariance() { return this._count &lt;= 1 ? null : this._constianceS / (this._count - 1); } /** * @return {number|null} * @private */ _calculateStddev() { return this._count &lt; 1 ? null : Math.sqrt(this._calculateVariance()); } /** * The type of the Metric Impl. {@link MetricTypes}. * @return {string} The type of the Metric Impl. */ getType() { return MetricTypes.HISTOGRAM; } } module.exports = Histogram; /** * Properties to create a {@link Histogram} with. * * @interface HistogramProperties * @typedef HistogramProperties * @type {Object} * @property {object} sample The sample reservoir to use. Defaults to an ExponentiallyDecayingSample. */ /** * The data returned from Histogram::toJSON() * @interface HistogramData * @typedef HistogramData * @typedef {object} * @property {number|null} min The lowest observed value. * @property {number|null} max The highest observed value. * @property {number|null} sum The sum of all observed values. * @property {number|null} variance The variance of all observed values. * @property {number|null} mean The average of all observed values. * @property {number|null} stddev The stddev of all observed values. * @property {number} count The number of observed values. * @property {number} median 50% of all values in the resevoir are at or below this value. * @property {number} p75 See median, 75% percentile. * @property {number} p95 See median, 95% percentile. * @property {number} p99 See median, 99% percentile. * @property {number} p999 See median, 99.9% percentile. */ × Search results Close "},"metrics_Meter.js.html":{"id":"metrics_Meter.js.html","title":"Source: metrics/Meter.js","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterSettableGaugeStopwatchTimer Interfaces MetricMetricTypes Global Global Source: metrics/Meter.js const { MetricTypes } = require('./Metric'); const units = require('../util/units'); const EWMA = require('../util/ExponentiallyMovingWeightedAverage'); const RATE_UNIT = units.SECONDS; const TICK_INTERVAL = 5 * units.SECONDS; /** * Things that are measured as events / interval. * @implements {Metric} * @example * var Measured = require('measured') * var meter = new Measured.Meter(); * http.createServer(function(req, res) { * meter.mark(); * }); */ class Meter { /** * @param {MeterProperties} [properties] see {@link MeterProperties}. */ constructor(properties) { this._properties = properties || {}; this._initializeState(); } /** * Initializes the state of this Metric * @private */ _initializeState() { this._rateUnit = this._properties.rateUnit || RATE_UNIT; this._tickInterval = this._properties.tickInterval || TICK_INTERVAL; if (this._properties.getTime) { this._getTime = this._properties.getTime; } this._m1Rate = this._properties.m1Rate || new EWMA(units.MINUTES, this._tickInterval); this._m5Rate = this._properties.m5Rate || new EWMA(5 * units.MINUTES, this._tickInterval); this._m15Rate = this._properties.m15Rate || new EWMA(15 * units.MINUTES, this._tickInterval); this._count = 0; this._currentSum = 0; this._startTime = this._getTime(); this._lastToJSON = this._getTime(); this._interval = setInterval(this._tick.bind(this), TICK_INTERVAL); } /** * Register n events as having just occured. Defaults to 1. * @param {number} n */ mark(n) { if (!this._interval) { this.start(); } n = n || 1; this._count += n; this._currentSum += n; this._m1Rate.update(n); this._m5Rate.update(n); this._m15Rate.update(n); } start() {} end() { clearInterval(this._interval); this._interval = null; } /** * Refs the backing timer again. Idempotent. */ ref() { if (this._interval &amp;&amp; this._interval.ref) { this._interval.ref(); } } /** * Unrefs the backing timer. The meter will not keep the event loop alive. Idempotent. */ unref() { if (this._interval &amp;&amp; this._interval.unref) { this._interval.unref(); } } _tick() { this._m1Rate.tick(); this._m5Rate.tick(); this._m15Rate.tick(); } /** * Resets all values. Meters initialized with custom options will be reset to the default settings (patch welcome). */ reset() { this.end(); this._initializeState(); } meanRate() { if (this._count === 0) { return 0; } const elapsed = this._getTime() - this._startTime; return this._count / elapsed * this._rateUnit; } currentRate() { const currentSum = this._currentSum; const duration = this._getTime() - this._lastToJSON; const currentRate = currentSum / duration * this._rateUnit; this._currentSum = 0; this._lastToJSON = this._getTime(); // currentRate could be NaN if duration was 0, so fix that return currentRate || 0; } toJSON() { return { mean: this.meanRate(), count: this._count, currentRate: this.currentRate(), '1MinuteRate': this._m1Rate.rate(this._rateUnit), '5MinuteRate': this._m5Rate.rate(this._rateUnit), '15MinuteRate': this._m15Rate.rate(this._rateUnit) }; } _getTime() { if (!process.hrtime) { return new Date().getTime(); } const hrtime = process.hrtime(); return hrtime[0] * 1000 + hrtime[1] / (1000 * 1000); } /** * The type of the Metric Impl. {@link MetricTypes}. * @return {string} The type of the Metric Impl. */ getType() { return MetricTypes.METER; } } module.exports = Meter; /** * * @interface MeterProperties * @typedef MeterProperties * @type {Object} * @property {number} rateUnit The rate unit. Defaults to 1000 (1 sec). * @property {number} tickInterval The interval in which the averages are updated. Defaults to 5000 (5 sec). * @example * const meter = new Meter({ rateUnit: 1000, tickInterval: 5000}) */ /** * The data returned from Meter::toJSON() * @interface MeterData * @typedef MeterData * @typedef {object} * @property {number} mean The average rate since the meter was started. * @property {number} count The total of all values added to the meter. * @property {number} currentRate The rate of the meter since the last toJSON() call. * @property {number} 1MinuteRate The rate of the meter biased towards the last 1 minute. * @property {number} 5MinuteRate The rate of the meter biased towards the last 5 minutes. * @property {number} 15MinuteRate The rate of the meter biased towards the last 15 minutes. */ × Search results Close "},"metrics_Metric.js.html":{"id":"metrics_Metric.js.html","title":"Source: metrics/Metric.js","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterSettableGaugeStopwatchTimer Interfaces MetricMetricTypes Global Global Source: metrics/Metric.js /** * Interface for Metric types. * * Implementations * &lt;p&gt; * &lt;li&gt;&lt;a href=&quot;#counter&quot;&gt;Counter&lt;/a&gt;, things that increment or decrement.&lt;/li&gt; * &lt;li&gt;&lt;a href=&quot;#gauge&quot;&gt;Gauge&lt;/a&gt;, values that can be read instantly via a supplied call back.&lt;/li&gt; * &lt;li&gt;&lt;a href=&quot;#histogram&quot;&gt;Histogram&lt;/a&gt;, keeps a reservoir of statistically relevant values to explore their distribution.&lt;/li&gt; * &lt;li&gt;&lt;a href=&quot;#meter&quot;&gt;Meter&lt;/a&gt;, things that are measured as events / interval.&lt;/li&gt; * &lt;li&gt;&lt;a href=&quot;#noopmeter&quot;&gt;NoOpMeter&lt;/a&gt;, an empty impl of meter, useful for supplying to a Timer, when you only care about the Histogram.&lt;/li&gt; * &lt;li&gt;&lt;a href=&quot;#settablegauge&quot;&gt;SettableGauge&lt;/a&gt;, just like a Gauge but its value is set directly rather than supplied by a callback.&lt;/li&gt; * &lt;li&gt;&lt;a href=&quot;#timer&quot;&gt;Timer&lt;/a&gt;, timers are a combination of Meters and Histograms. They measure the rate as well as distribution of scalar events.&lt;/li&gt; * &lt;/p&gt; * * @interface Metric */ // eslint-disable-next-line no-unused-vars class Metric { /** * Please note that dispite its name, this method can return raw numbers on * certain implementations such as counters and gauges. * * @return {any} Returns the data from the Metric */ toJSON() {} /** * The type of the Metric Impl. {@link MetricTypes}. * @return {string} The type of the Metric Impl. */ getType() {} } /** * An enum like object that is the set of core metric types that all implementors of {@link Metric} are. * * @typedef MetricTypes * @interface MetricTypes * @type {Object.&lt;string, string&gt;} * @property {COUNTER} The type for Counters. * @property {GAUGE} The type for Gauges. * @property {HISTOGRAM} The type for Histograms. * @property {METER} The type for Meters. * @property {TIMER} The type for Timers. */ const MetricTypes = { COUNTER: 'Counter', GAUGE: 'Gauge', HISTOGRAM: 'Histogram', METER: 'Meter', TIMER: 'Timer' }; module.exports = { MetricTypes }; × Search results Close "},"index.js.html":{"id":"index.js.html","title":"Source: index.js","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterSettableGaugeStopwatchTimer Interfaces MetricMetricTypes Global Global Source: index.js const Collection = require('./Collection'); const Counter = require('./metrics/Counter'); const Gauge = require('./metrics/Gauge'); const SettableGauge = require('./metrics/SettableGauge'); const Histogram = require('./metrics/Histogram'); const Meter = require('./metrics/Meter'); const NoOpMeter = require('./metrics/NoOpMeter'); const Timer = require('./metrics/Timer'); const BinaryHeap = require('./util/BinaryHeap'); const ExponentiallyDecayingSample = require('./util/ExponentiallyDecayingSample'); const ExponentiallyMovingWeightedAverage = require('./util/ExponentiallyMovingWeightedAverage'); const Stopwatch = require('./util/Stopwatch'); const units = require('./util/units'); const { MetricTypes } = require('./metrics/Metric'); /** * The main measured module that is referenced when require('measured') is used. * @module measured-core */ module.exports = { /** * See {@link Collection} * @type {Collection} * @augments Collection */ Collection, /** * See {@link Counter} * @type {Counter} */ Counter, /** * See {@link Gauge} * @type {Gauge} */ Gauge, /** * See {@link SettableGauge} * @type {SettableGauge} */ SettableGauge, /** * See {@link Histogram} * @type {Histogram} */ Histogram, /** * See {@link Meter} * @type {Meter} */ Meter, /** * See {@link NoOpMeter} * @type {NoOpMeter} */ NoOpMeter, /** * See {@link Timer} * @type {Timer} */ Timer, /** * See {@link BinaryHeap} * @type {BinaryHeap} */ BinaryHeap, /** * See {@link ExponentiallyDecayingSample} * @type {ExponentiallyDecayingSample} */ ExponentiallyDecayingSample, /** * See {@link ExponentiallyMovingWeightedAverage} * @type {ExponentiallyMovingWeightedAverage} */ ExponentiallyMovingWeightedAverage, /** * See {@link Stopwatch} * @type {Stopwatch} */ Stopwatch, /** * See {@link MetricTypes} * @type {MetricTypes} */ MetricTypes, /** * See {@link units} * @type {units} */ units, /** * Creates a named collection. See {@Collection} for more details * * @param name The name for the collection * @return {Collection} */ createCollection: name =&gt; { return new Collection(name); } }; × Search results Close "},"util_units.js.html":{"id":"util_units.js.html","title":"Source: util/units.js","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterSettableGaugeStopwatchTimer Interfaces MetricMetricTypes Global Global Source: util/units.js const NANOSECONDS = 1 / (1000 * 1000); const MICROSECONDS = 1 / 1000; const MILLISECONDS = 1; const SECONDS = 1000 * MILLISECONDS; const MINUTES = 60 * SECONDS; const HOURS = 60 * MINUTES; const DAYS = 24 * HOURS; /** * Time units, as found in Java: {@link http://download.oracle.com/javase/6/docs/api/java/util/concurrent/TimeUnit.html} * @module units * @example * const TimeUnit = require('measured-core').unit * setTimeout(() =&gt; {}, 5 * TimeUnit.MINUTES) */ module.exports = { /** * nanoseconds in milliseconds * @type {number} */ NANOSECONDS, /** * microseconds in milliseconds * @type {number} */ MICROSECONDS, /** * milliseconds in milliseconds * @type {number} */ MILLISECONDS, /** * seconds in milliseconds * @type {number} */ SECONDS, /** * minutes in milliseconds * @type {number} */ MINUTES, /** * hours in milliseconds * @type {number} */ HOURS, /** * days in milliseconds * @type {number} */ DAYS }; × Search results Close "},"metrics_NoOpMeter.js.html":{"id":"metrics_NoOpMeter.js.html","title":"Source: metrics/NoOpMeter.js","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterSettableGaugeStopwatchTimer Interfaces MetricMetricTypes Global Global Source: metrics/NoOpMeter.js const { MetricTypes } = require('./Metric'); /** * A No-Op Impl of Meter that can be used with a timer, to only create histogram data. * This is useful for some time series aggregators that can calculate rates for you just off of sent count. * * @implements {Metric} * @example * const { NoOpMeter, Timer } = require('measured') * const meter = new NoOpMeter(); * const timer = new Timer({meter: meter}); * ... * // do some stuff with the timer and stopwatch api * ... */ // eslint-disable-next-line padded-blocks class NoOpMeter { /** * No-Op impl * @param {number} n Number of events to mark. */ // eslint-disable-next-line no-unused-vars mark(n) {} /** * No-Op impl */ start() {} /** * No-Op impl */ end() {} /** * No-Op impl */ ref() {} /** * No-Op impl */ unref() {} /** * No-Op impl */ reset() {} /** * No-Op impl */ meanRate() {} /** * No-Op impl */ currentRate() {} /** * Returns an empty object * @return {{}} */ toJSON() { return {}; } /** * The type of the Metric Impl. {@link MetricTypes}. * @return {string} The type of the Metric Impl. */ getType() { return MetricTypes.METER; } } module.exports = NoOpMeter; × Search results Close "},"metrics_SettableGauge.js.html":{"id":"metrics_SettableGauge.js.html","title":"Source: metrics/SettableGauge.js","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterSettableGaugeStopwatchTimer Interfaces MetricMetricTypes Global Global Source: metrics/SettableGauge.js const { MetricTypes } = require('./Metric'); /** * Works like a {@link Gauge}, but rather than getting its value from a callback, the value * is set when needed. This can be useful for setting a gauges value for asynchronous operations. * @implements {Metric} * @example * const settableGauge = new SettableGauge(); * // Update the settable gauge ever 10'ish seconds * setInterval(() =&gt; { * calculateSomethingAsync().then((value) =&gt; { * settableGauge.setValue(value); * }); * }, 10000); */ class SettableGauge { /** * @param {SettableGaugeProperties} [options] See {@link SettableGaugeProperties}. */ constructor(options) { options = options || {}; this._value = options.initialValue || 0; } setValue(value) { this._value = value; } /** * @return {number} Settable Gauges directly return there current value. */ toJSON() { return this._value; } /** * The type of the Metric Impl. {@link MetricTypes}. * @return {string} The type of the Metric Impl. */ getType() { return MetricTypes.GAUGE; } } module.exports = SettableGauge; /** * Properties that can be supplied to the constructor of a {@link Counter} * * @interface SettableGaugeProperties * @typedef SettableGaugeProperties * @type {Object} * @property {number} initialValue An initial value to use for this settable gauge. Defaults to 0. * @example * // Creates a Gauge that with an initial value of 500. * const settableGauge = new SettableGauge({ initialValue: 500 }) * */ × Search results Close "},"util_Stopwatch.js.html":{"id":"util_Stopwatch.js.html","title":"Source: util/Stopwatch.js","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterSettableGaugeStopwatchTimer Interfaces MetricMetricTypes Global Global Source: util/Stopwatch.js const { EventEmitter } = require('events'); /** * A simple object for tracking elapsed time * * @extends {EventEmitter} */ class Stopwatch extends EventEmitter { /** * Creates a started Stopwatch * @param {StopwatchProperties} options See {@link StopwatchProperties} */ constructor(options) { super(); options = options || {}; EventEmitter.call(this); if (options.getTime) { this._getTime = options.getTime; } this._start = this._getTime(); this._ended = false; } /** * Called to mark the end of the timer task * @return {number} the total execution time */ end() { if (this._ended) { return null; } this._ended = true; const elapsed = this._getTime() - this._start; this.emit('end', elapsed); return elapsed; } _getTime() { if (!process.hrtime) { return Date.now(); } const hrtime = process.hrtime(); return hrtime[0] * 1000 + hrtime[1] / (1000 * 1000); } } module.exports = Stopwatch; /** * @interface StopwatchProperties * @typedef StopwatchProperties * @type {Object} * @property {function} getTime optional function override for supplying time., defaults to new Date() / process.hrt() */ × Search results Close "},"metrics_Timer.js.html":{"id":"metrics_Timer.js.html","title":"Source: metrics/Timer.js","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterSettableGaugeStopwatchTimer Interfaces MetricMetricTypes Global Global Source: metrics/Timer.js const { MetricTypes } = require('./Metric'); const Histogram = require('./Histogram'); const Meter = require('./Meter'); const Stopwatch = require('../util/Stopwatch'); /** * * Timers are a combination of Meters and Histograms. They measure the rate as well as distribution of scalar events. * &lt;p&gt; * Since they are frequently used for tracking how long certain things take, they expose an API for that: See example 1. * &lt;p&gt; * But you can also use them as generic histograms that also track the rate of events: See example 2. * * @example * var Measured = require('measured') * var timer = new Measured.Timer(); * http.createServer(function(req, res) { * var stopwatch = timer.start(); * req.on('end', function() { * stopwatch.end(); * }); * }); * * * @example * var Measured = require('measured') * var timer = new Measured.Timer(); * http.createServer(function(req, res) { * if (req.headers['content-length']) { * timer.update(parseInt(req.headers['content-length'], 10)); * } * }); * * @implements {Metric} */ class Timer { /** * @param {TimerProperties} [properties] See {@link TimerProperties}. */ constructor(properties) { properties = properties || {}; this._meter = properties.meter || new Meter({}); this._histogram = properties.histogram || new Histogram({}); this._getTime = properties.getTime; } /** * @return {Stopwatch} Returns a Stopwatch that has been started. */ start() { const self = this; const watch = new Stopwatch({ getTime: this._getTime }); watch.once('end', elapsed =&gt; { self.update(elapsed); }); return watch; } /** * Updates the internal histogram with value and marks one event on the internal meter. * @param {number} value */ update(value) { this._meter.mark(); this._histogram.update(value); } /** * Resets all values. Timers initialized with custom options will be reset to the default settings. */ reset() { this._meter.reset(); this._histogram.reset(); } end() { this._meter.end(); } /** * Refs the backing timer again. Idempotent. */ ref() { this._meter.ref(); } /** * Unrefs the backing timer. The meter will not keep the event loop alive. Idempotent. */ unref() { this._meter.unref(); } /** * toJSON output: * * &lt;li&gt; meter: See &lt;a href=&quot;#meter&quot;&gt;Meter&lt;/a&gt;#toJSON output docs above.&lt;/li&gt; * &lt;li&gt; histogram: See &lt;a href=&quot;#histogram&quot;&gt;Histogram&lt;/a&gt;#toJSON output docs above.&lt;/a&gt;&lt;/li&gt; * * @return {any} */ toJSON() { return { meter: this._meter.toJSON(), histogram: this._histogram.toJSON() }; } /** * The type of the Metric Impl. {@link MetricTypes}. * @return {string} The type of the Metric Impl. */ getType() { return MetricTypes.TIMER; } } module.exports = Timer; /** * @interface TimerProperties * @typedef TimerProperties * @type {Object} * @property {Meter} meter The internal meter to use. Defaults to a new {@link Meter}. * @property {Histogram} histogram The internal histogram to use. Defaults to a new {@link Histogram}. * @property {function} getTime optional function override for supplying time to the {@link Stopwatch} */ × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterSettableGaugeStopwatchTimer Interfaces MetricMetricTypes Global Global Global Type Definitions CounterProperties Properties that can be supplied to the constructor of a Counter Type: Object Properties: Name Type Description count number An initial count for the counter. Defaults to 0. Source: metrics/Counter.js, line 69 Example // Creates a counter that starts at 5. const counter = new Counter({ count: 5 }) HistogramData The data returned from Histogram::toJSON() Type: object Properties: Name Type Description min number | null The lowest observed value. max number | null The highest observed value. sum number | null The sum of all observed values. variance number | null The variance of all observed values. mean number | null The average of all observed values. stddev number | null The stddev of all observed values. count number The number of observed values. median number 50% of all values in the resevoir are at or below this value. p75 number See median, 75% percentile. p95 number See median, 95% percentile. p99 number See median, 99% percentile. p999 number See median, 99.9% percentile. Source: metrics/Histogram.js, line 239 HistogramProperties Properties to create a Histogram with. Type: Object Properties: Name Type Description sample object The sample reservoir to use. Defaults to an ExponentiallyDecayingSample. Source: metrics/Histogram.js, line 230 MeterData The data returned from Meter::toJSON() Type: object Properties: Name Type Description mean number The average rate since the meter was started. count number The total of all values added to the meter. currentRate number The rate of the meter since the last toJSON() call. 1MinuteRate number The rate of the meter biased towards the last 1 minute. 5MinuteRate number The rate of the meter biased towards the last 5 minutes. 15MinuteRate number The rate of the meter biased towards the last 15 minutes. Source: metrics/Meter.js, line 168 MeterProperties Type: Object Properties: Name Type Description rateUnit number The rate unit. Defaults to 1000 (1 sec). tickInterval number The interval in which the averages are updated. Defaults to 5000 (5 sec). Source: metrics/Meter.js, line 157 Example const meter = new Meter({ rateUnit: 1000, tickInterval: 5000}) SettableGaugeProperties Properties that can be supplied to the constructor of a Counter Type: Object Properties: Name Type Description initialValue number An initial value to use for this settable gauge. Defaults to 0. Source: metrics/SettableGauge.js, line 47 Example // Creates a Gauge that with an initial value of 500. const settableGauge = new SettableGauge({ initialValue: 500 }) StopwatchProperties Type: Object Properties: Name Type Description getTime function optional function override for supplying time., defaults to new Date() / process.hrt() Source: util/Stopwatch.js, line 53 TimerProperties Type: Object Properties: Name Type Description meter Meter The internal meter to use. Defaults to a new Meter. histogram Histogram The internal histogram to use. Defaults to a new Histogram. getTime function optional function override for supplying time to the Stopwatch Source: metrics/Timer.js, line 123 × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterSettableGaugeStopwatchTimer Interfaces MetricMetricTypes Global Global Modules Classes BinaryHeap Collection Counter ExponentiallyDecayingSample ExponentiallyMovingWeightedAverage Gauge Histogram Meter NoOpMeter SettableGauge Stopwatch Timer × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterSettableGaugeStopwatchTimer Interfaces MetricMetricTypes Global Global Classes Classes BinaryHeap Collection Counter ExponentiallyDecayingSample ExponentiallyMovingWeightedAverage Gauge Histogram Meter NoOpMeter SettableGauge Stopwatch Timer × Search results Close "},"interfaces.list.html":{"id":"interfaces.list.html","title":"Interfaces","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterSettableGaugeStopwatchTimer Interfaces MetricMetricTypes Global Global Interfaces Classes BinaryHeap Collection Counter ExponentiallyDecayingSample ExponentiallyMovingWeightedAverage Gauge Histogram Meter NoOpMeter SettableGauge Stopwatch Timer × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterSettableGaugeStopwatchTimer Interfaces MetricMetricTypes Global Global Measured CoreThe core measured library that has the Metric interfaces and implementations. Installnpm install measured-coreWhat is in this packageMetric ImplemenationsThe core library has the following metrics classes: Gauge, Values that can be read instantly via a supplied call back. SettableGauge, Just like a Gauge but its value is set directly rather than supplied by a callback. Counter, Counters are things that increment or decrement. Timer, Timers are a combination of Meters and Histograms. They measure the rate as well as distribution of scalar events. Histogram, Keeps a reservoir of statistically relevant values to explore their distribution. Meter, Things that are measured as events / interval. RegistryThe core library comes with a basic registry class called Collection, that is not aware of dimensions / tags and leaves reporting up to you. See the measured-reporting module for more advanced and featured registries. OtherSee The measured-core modules for the full list of exports for require('measured-core'). UsageStep 1: Add measurements to your code. For example, lets track therequests/sec of a http server: var http = require('http'); var stats = require('measured').createCollection(); http.createServer(function(req, res) { stats.meter('requestsPerSecond').mark(); res.end('Thanks'); }).listen(3000);Step 2: Show the collected measurements (more advanced examples follow later): setInterval(function() { console.log(stats.toJSON()); }, 1000);This will output something like this every second: { requestsPerSecond: { mean: 1710.2180279856818, count: 10511, 'currentRate': 1941.4893498239829, '1MinuteRate': 168.08263156623656, '5MinuteRate': 34.74630977619571, '15MinuteRate': 11.646507524106095 } }Step 3: Aggregate the data into your backend of choice.Here are a few time series data aggregators. Graphite A free and open source, self hosted and managed solution for time series data. SignalFx An enterprise SASS offering for time series data. Datadog An enterprise SASS offering for time series data. × Search results Close "},"BinaryHeap.html":{"id":"BinaryHeap.html","title":"Class: BinaryHeap","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterSettableGaugeStopwatchTimer Interfaces MetricMetricTypes Global Global Class: BinaryHeap BinaryHeap Based on http://en.wikipedia.org/wiki/Binary_Heapas well as http://eloquentjavascript.net/appendix2.html new BinaryHeap() Source: util/BinaryHeap.js, line 5 Methods add(elements) Add elements to the binary heap. Parameters: Name Type Argument Description elements Array.&lt;any&gt; &lt;repeatable&gt; Source: util/BinaryHeap.js, line 17 × Search results Close "},"Collection.html":{"id":"Collection.html","title":"Class: Collection","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterSettableGaugeStopwatchTimer Interfaces MetricMetricTypes Global Global Class: Collection Collection A Simple collection that stores names and a Metric instances with a few convenience methods forcreating / registering and then gathering all data the registered metrics. new Collection( [name]) Creates a named collection of metrics Parameters: Name Type Argument Description name string &lt;optional&gt; The name to use for this collection. Source: Collection.js, line 20 Example var { Collection } = require('measured'); const collection = new Collection('node-process-metrics'); const gauge = collection.gauge('node.process.heap_used', () =&gt; { return process.memoryUsage().heapUsed; }); Methods counter(name [, properties]) Gets or creates and registers a Counter Parameters: Name Type Argument Description name string The metric name properties CounterProperties &lt;optional&gt; See CounterProperties Source: Collection.js, line 103 Returns: Type Counter end() Calls end on all metrics in the registry that support end() Source: Collection.js, line 244 gauge(name, readFn) Gets or creates and registers a Gauge Parameters: Name Type Description name string The metric name readFn function See Gauge Source: Collection.js, line 81 Returns: Type Gauge histogram(name [, properties]) Gets or creates and registers a Histogram Parameters: Name Type Argument Description name string The metric name properties HistogramProperties &lt;optional&gt; See HistogramProperties Source: Collection.js, line 125 Returns: Type Histogram meter(name [, properties]) Gets or creates and registers a Meter Parameters: Name Type Argument Description name string The metric name properties MeterProperties &lt;optional&gt; See MeterProperties Source: Collection.js, line 169 Returns: Type Meter register(name, metric) register a metric that was created outside the provided convenience methods of this collection Parameters: Name Type Description name The metric name metric The Metric implementation Source: Collection.js, line 48 Example var { Collection, Gauge } = require('measured'); const collection = new Collection('node-process-metrics'); const gauge = new Gauge(() =&gt; { return process.memoryUsage().heapUsed; }); collection.register('node.process.heap_used', gauge); settableGauge(name [, properties]) Gets or creates and registers a SettableGauge Parameters: Name Type Argument Description name string The metric name properties SettableGaugeProperties &lt;optional&gt; See SettableGaugeProperties Source: Collection.js, line 191 Returns: Type SettableGauge timer(name [, properties]) Gets or creates and registers a Timer Parameters: Name Type Argument Description name string The metric name properties TimerProperties &lt;optional&gt; See TimerProperties Source: Collection.js, line 147 Returns: Type Timer toJSON() Fetches the data/values from all registered metrics Source: Collection.js, line 56 Returns: The combined JSON object Type Object × Search results Close "},"Counter.html":{"id":"Counter.html","title":"Class: Counter","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterSettableGaugeStopwatchTimer Interfaces MetricMetricTypes Global Global Class: Counter Counter Counters are things that increment or decrement new Counter( [properties]) Parameters: Name Type Argument Description properties CounterProperties &lt;optional&gt; see CounterProperties Implements: Metric Source: metrics/Counter.js, line 16 Example var Measured = require('measured') var activeUploads = new Measured.Counter(); http.createServer(function(req, res) { activeUploads.inc(); req.on('end', function() { activeUploads.dec(); }); }); Methods dec(n) Decrements the counter Parameters: Name Type Description n number Decrement the counter by n. Defaults to 1. Source: metrics/Counter.js, line 46 getType() The type of the Metric Impl. MetricTypes. Implements: Metric#getType Source: metrics/Counter.js, line 62 Returns: The type of the Metric Impl. Type string inc(n) Increments the counter. Parameters: Name Type Description n number Increment the counter by n. Defaults to 1. Source: metrics/Counter.js, line 38 reset(count) Resets the counter back to count Defaults to 0. Parameters: Name Type Description count number Resets the counter back to count Defaults to 0. Source: metrics/Counter.js, line 54 toJSON() Counters directly return their currently value. Implements: Metric#toJSON Source: metrics/Counter.js, line 30 Returns: Type number × Search results Close "},"ExponentiallyDecayingSample.html":{"id":"ExponentiallyDecayingSample.html","title":"Class: ExponentiallyDecayingSample","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterSettableGaugeStopwatchTimer Interfaces MetricMetricTypes Global Global Class: ExponentiallyDecayingSample ExponentiallyDecayingSample ExponentiallyDecayingSample new ExponentiallyDecayingSample() Source: util/ExponentiallyDecayingSample.js, line 11 × Search results Close "},"ExponentiallyMovingWeightedAverage.html":{"id":"ExponentiallyMovingWeightedAverage.html","title":"Class: ExponentiallyMovingWeightedAverage","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterSettableGaugeStopwatchTimer Interfaces MetricMetricTypes Global Global Class: ExponentiallyMovingWeightedAverage ExponentiallyMovingWeightedAverage ExponentiallyMovingWeightedAverage new ExponentiallyMovingWeightedAverage() Source: util/ExponentiallyMovingWeightedAverage.js, line 8 × Search results Close "},"Gauge.html":{"id":"Gauge.html","title":"Class: Gauge","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterSettableGaugeStopwatchTimer Interfaces MetricMetricTypes Global Global Class: Gauge Gauge Values that can be read instantly new Gauge(readFn) Parameters: Name Type Description readFn function A function that returns the numeric value for this gauge. Implements: Metric Source: metrics/Gauge.js, line 12 Example var Measured = require('measured') var gauge = new Measured.Gauge(function() { return process.memoryUsage().rss; }); Methods getType() The type of the Metric Impl. MetricTypes. Implements: Metric#getType Source: metrics/Gauge.js, line 32 Returns: The type of the Metric Impl. Type string toJSON() This is sync for now, but maybe async gauges would be useful as well? Implements: Metric#toJSON Source: metrics/Gauge.js, line 24 Returns: Gauges directly return the value from the callback which should be a number. Type number × Search results Close "},"Histogram.html":{"id":"Histogram.html","title":"Class: Histogram","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterSettableGaugeStopwatchTimer Interfaces MetricMetricTypes Global Global Class: Histogram Histogram Keeps a reservoir of statistically relevant values biased towards the last 5 minutes to explore their distribution. new Histogram( [properties]) Parameters: Name Type Argument Description properties HistogramProperties &lt;optional&gt; see HistogramProperties. Implements: Metric Source: metrics/Histogram.js, line 17 Example var Measured = require('measured') var histogram = new Measured.Histogram(); http.createServer(function(req, res) { if (req.headers['content-length']) { histogram.update(parseInt(req.headers['content-length'], 10)); } }); Methods getType() The type of the Metric Impl. MetricTypes. Implements: Metric#getType Source: metrics/Histogram.js, line 223 Returns: The type of the Metric Impl. Type string hasValues() Checks whether the histogram contains values. Source: metrics/Histogram.js, line 141 Returns: Whether the histogram contains values. Type boolean reset() Resets all values. Histograms initialized with custom options will be reset to the default settings (patch welcome). Source: metrics/Histogram.js, line 129 toJSON() Implements: Metric#toJSON Source: metrics/Histogram.js, line 148 Returns: Type HistogramData update(value) Pushes value into the sample. timestamp defaults to Date.now(). Parameters: Name Type Description value number Source: metrics/Histogram.js, line 44 × Search results Close "},"Meter.html":{"id":"Meter.html","title":"Class: Meter","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterSettableGaugeStopwatchTimer Interfaces MetricMetricTypes Global Global Class: Meter Meter Things that are measured as events / interval. new Meter( [properties]) Parameters: Name Type Argument Description properties MeterProperties &lt;optional&gt; see MeterProperties. Implements: Metric Source: metrics/Meter.js, line 18 Example var Measured = require('measured') var meter = new Measured.Meter(); http.createServer(function(req, res) { meter.mark(); }); Methods getType() The type of the Metric Impl. MetricTypes. Implements: Metric#getType Source: metrics/Meter.js, line 150 Returns: The type of the Metric Impl. Type string mark(n) Register n events as having just occured. Defaults to 1. Parameters: Name Type Description n number Source: metrics/Meter.js, line 52 ref() Refs the backing timer again. Idempotent. Source: metrics/Meter.js, line 76 reset() Resets all values. Meters initialized with custom options will be reset to the default settings (patch welcome). Source: metrics/Meter.js, line 100 toJSON() Please note that dispite its name, this method can return raw numbers oncertain implementations such as counters and gauges. Implements: Metric#toJSON Source: metrics/Metric.js, line 25 Returns: Returns the data from the Metric Type any unref() Unrefs the backing timer. The meter will not keep the event loop alive. Idempotent. Source: metrics/Meter.js, line 85 × Search results Close "},"Metric.html":{"id":"Metric.html","title":"Interface: Metric","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterSettableGaugeStopwatchTimer Interfaces MetricMetricTypes Global Global Interface: Metric Metric Interface for Metric types. Implementations Counter, things that increment or decrement.Gauge, values that can be read instantly via a supplied call back.Histogram, keeps a reservoir of statistically relevant values to explore their distribution.Meter, things that are measured as events / interval.NoOpMeter, an empty impl of meter, useful for supplying to a Timer, when you only care about the Histogram.SettableGauge, just like a Gauge but its value is set directly rather than supplied by a callback.Timer, timers are a combination of Meters and Histograms. They measure the rate as well as distribution of scalar events. Source: metrics/Metric.js, line 1 Methods getType() The type of the Metric Impl. MetricTypes. Source: metrics/Metric.js, line 31 Returns: The type of the Metric Impl. Type string toJSON() Please note that dispite its name, this method can return raw numbers oncertain implementations such as counters and gauges. Source: metrics/Metric.js, line 25 Returns: Returns the data from the Metric Type any × Search results Close "},"MetricTypes.html":{"id":"MetricTypes.html","title":"Interface: MetricTypes","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterSettableGaugeStopwatchTimer Interfaces MetricMetricTypes Global Global Interface: MetricTypes MetricTypes An enum like object that is the set of core metric types that all implementors of Metric are. Properties: Name Type Description The COUNTER type for Counters. The GAUGE type for Gauges. The HISTOGRAM type for Histograms. The METER type for Meters. The TIMER type for Timers. Source: metrics/Metric.js, line 34 × Search results Close "},"module-measured-core.html":{"id":"module-measured-core.html","title":"Module: measured-core","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterSettableGaugeStopwatchTimer Interfaces MetricMetricTypes Global Global Module: measured-core The main measured module that is referenced when require('measured') is used. Source: index.js, line 16 Members &lt;static&gt; BinaryHeap :BinaryHeap See BinaryHeap Type: BinaryHeap Source: index.js, line 74 &lt;static&gt; Collection :Collection See Collection Type: Collection Source: index.js, line 26 &lt;static&gt; Counter :Counter See Counter Type: Counter Source: index.js, line 32 &lt;static&gt; ExponentiallyDecayingSample :ExponentiallyDecayingSample See ExponentiallyDecayingSample Type: ExponentiallyDecayingSample Source: index.js, line 80 &lt;static&gt; ExponentiallyMovingWeightedAverage :ExponentiallyMovingWeightedAverage See ExponentiallyMovingWeightedAverage Type: ExponentiallyMovingWeightedAverage Source: index.js, line 86 &lt;static&gt; Gauge :Gauge See Gauge Type: Gauge Source: index.js, line 38 &lt;static&gt; Histogram :Histogram See Histogram Type: Histogram Source: index.js, line 50 &lt;static&gt; Meter :Meter See Meter Type: Meter Source: index.js, line 56 &lt;static&gt; MetricTypes :MetricTypes See MetricTypes Type: MetricTypes Source: index.js, line 98 &lt;static&gt; NoOpMeter :NoOpMeter See NoOpMeter Type: NoOpMeter Source: index.js, line 62 &lt;static&gt; SettableGauge :SettableGauge See SettableGauge Type: SettableGauge Source: index.js, line 44 &lt;static&gt; Stopwatch :Stopwatch See Stopwatch Type: Stopwatch Source: index.js, line 92 &lt;static&gt; Timer :Timer See Timer Type: Timer Source: index.js, line 68 &lt;static&gt; units :units See units Type: units Source: index.js, line 104 Methods &lt;static&gt; createCollection(name) Creates a named collection. See {@Collection} for more details Parameters: Name Type Description name The name for the collection Source: index.js, line 112 Returns: Type Collection × Search results Close "},"module-units.html":{"id":"module-units.html","title":"Module: units","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterSettableGaugeStopwatchTimer Interfaces MetricMetricTypes Global Global Module: units Time units, as found in Java: http://download.oracle.com/javase/6/docs/api/java/util/concurrent/TimeUnit.html Source: util/units.js, line 9 Example const TimeUnit = require('measured-core').unit setTimeout(() =&gt; {}, 5 * TimeUnit.MINUTES) Members &lt;static&gt; DAYS :number days in milliseconds Type: number Source: util/units.js, line 51 &lt;static&gt; HOURS :number hours in milliseconds Type: number Source: util/units.js, line 46 &lt;static&gt; MICROSECONDS :number microseconds in milliseconds Type: number Source: util/units.js, line 26 &lt;static&gt; MILLISECONDS :number milliseconds in milliseconds Type: number Source: util/units.js, line 31 &lt;static&gt; MINUTES :number minutes in milliseconds Type: number Source: util/units.js, line 41 &lt;static&gt; NANOSECONDS :number nanoseconds in milliseconds Type: number Source: util/units.js, line 21 &lt;static&gt; SECONDS :number seconds in milliseconds Type: number Source: util/units.js, line 36 × Search results Close "},"NoOpMeter.html":{"id":"NoOpMeter.html","title":"Class: NoOpMeter","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterSettableGaugeStopwatchTimer Interfaces MetricMetricTypes Global Global Class: NoOpMeter NoOpMeter A No-Op Impl of Meter that can be used with a timer, to only create histogram data.This is useful for some time series aggregators that can calculate rates for you just off of sent count. new NoOpMeter() Implements: Metric Source: metrics/NoOpMeter.js, line 17 Example const { NoOpMeter, Timer } = require('measured') const meter = new NoOpMeter(); const timer = new Timer({meter: meter}); ... // do some stuff with the timer and stopwatch api ... Methods currentRate() No-Op impl Source: metrics/NoOpMeter.js, line 58 end() No-Op impl Source: metrics/NoOpMeter.js, line 33 getType() The type of the Metric Impl. MetricTypes. Implements: Metric#getType Source: metrics/NoOpMeter.js, line 72 Returns: The type of the Metric Impl. Type string mark(n) No-Op impl Parameters: Name Type Description n number Number of events to mark. Source: metrics/NoOpMeter.js, line 23 meanRate() No-Op impl Source: metrics/NoOpMeter.js, line 53 ref() No-Op impl Source: metrics/NoOpMeter.js, line 38 reset() No-Op impl Source: metrics/NoOpMeter.js, line 48 start() No-Op impl Source: metrics/NoOpMeter.js, line 28 toJSON() Returns an empty object Implements: Metric#toJSON Source: metrics/NoOpMeter.js, line 64 Returns: Type Object unref() No-Op impl Source: metrics/NoOpMeter.js, line 43 × Search results Close "},"SettableGauge.html":{"id":"SettableGauge.html","title":"Class: SettableGauge","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterSettableGaugeStopwatchTimer Interfaces MetricMetricTypes Global Global Class: SettableGauge SettableGauge Works like a Gauge, but rather than getting its value from a callback, the valueis set when needed. This can be useful for setting a gauges value for asynchronous operations. new SettableGauge( [options]) Parameters: Name Type Argument Description options SettableGaugeProperties &lt;optional&gt; See SettableGaugeProperties. Implements: Metric Source: metrics/SettableGauge.js, line 16 Example const settableGauge = new SettableGauge(); // Update the settable gauge ever 10'ish seconds setInterval(() =&gt; { calculateSomethingAsync().then((value) =&gt; { settableGauge.setValue(value); }); }, 10000); Methods getType() The type of the Metric Impl. MetricTypes. Implements: Metric#getType Source: metrics/SettableGauge.js, line 40 Returns: The type of the Metric Impl. Type string toJSON() Implements: Metric#toJSON Source: metrics/SettableGauge.js, line 32 Returns: Settable Gauges directly return there current value. Type number × Search results Close "},"Stopwatch.html":{"id":"Stopwatch.html","title":"Class: Stopwatch","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterSettableGaugeStopwatchTimer Interfaces MetricMetricTypes Global Global Class: Stopwatch Stopwatch A simple object for tracking elapsed time new Stopwatch(options) Creates a started Stopwatch Parameters: Name Type Description options StopwatchProperties See StopwatchProperties Source: util/Stopwatch.js, line 8 Extends EventEmitter Methods end() Called to mark the end of the timer task Source: util/Stopwatch.js, line 29 Returns: the total execution time Type number × Search results Close "},"Timer.html":{"id":"Timer.html","title":"Class: Timer","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterSettableGaugeStopwatchTimer Interfaces MetricMetricTypes Global Global Class: Timer Timer Timers are a combination of Meters and Histograms. They measure the rate as well as distribution of scalar events. Since they are frequently used for tracking how long certain things take, they expose an API for that: See example 1. But you can also use them as generic histograms that also track the rate of events: See example 2. new Timer( [properties]) Parameters: Name Type Argument Description properties TimerProperties &lt;optional&gt; See TimerProperties. Implements: Metric Source: metrics/Timer.js, line 36 Examples var Measured = require('measured') var timer = new Measured.Timer(); http.createServer(function(req, res) { var stopwatch = timer.start(); req.on('end', function() { stopwatch.end(); }); }); var Measured = require('measured') var timer = new Measured.Timer(); http.createServer(function(req, res) { if (req.headers['content-length']) { timer.update(parseInt(req.headers['content-length'], 10)); } }); Methods getType() The type of the Metric Impl. MetricTypes. Implements: Metric#getType Source: metrics/Timer.js, line 116 Returns: The type of the Metric Impl. Type string ref() Refs the backing timer again. Idempotent. Source: metrics/Timer.js, line 86 reset() Resets all values. Timers initialized with custom options will be reset to the default settings. Source: metrics/Timer.js, line 74 start() Source: metrics/Timer.js, line 51 Returns: Returns a Stopwatch that has been started. Type Stopwatch toJSON() toJSON output: meter: See Meter#toJSON output docs above. histogram: See Histogram#toJSON output docs above. Implements: Metric#toJSON Source: metrics/Timer.js, line 105 Returns: Type any unref() Unrefs the backing timer. The meter will not keep the event loop alive. Idempotent. Source: metrics/Timer.js, line 93 update(value) Updates the internal histogram with value and marks one event on the internal meter. Parameters: Name Type Description value number Source: metrics/Timer.js, line 66 × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
