<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"reporter_SignalFxMetricsReporter.js.html":{"id":"reporter_SignalFxMetricsReporter.js.html","title":"Source: reporter/SignalFxMetricsReporter.js","body":" Measured Classes SignalFxMetricsReporterSignalFxSelfReportingMetricsRegistry Global Global Source: reporter/SignalFxMetricsReporter.js const { Reporter } = require('measured-reporting'); const { MetricTypes } = require('measured-core'); const { validateSignalFxClient } = require('../validators/inputValidators'); /** * A Reporter that reports metrics to Signal Fx * @extends {Reporter} */ class SignalFxMetricsReporter extends Reporter { /** * @param {SignalFxClient} signalFxClient The configured signal fx client. * @param {ReporterOptions} options See {@link ReporterOptions}. */ constructor(signalFxClient, options) { super(options); validateSignalFxClient(signalFxClient); this._signalFxClient = signalFxClient; } /** * Sends metrics to signal fx, converting name and dimensions and {@link Metric} to data signal fx can ingest * @param {MetricWrapper[]} metrics The array of metrics to send to signal fx. * @protected */ _reportMetrics(metrics) { this._log.debug('sendMetrics() called'); let signalFxDataPointRequest = {}; metrics.forEach(metric =&gt; { if (!metric) { this._log.warn('Metric was null when it should not have been'); return; } signalFxDataPointRequest = this._processMetric(metric, signalFxDataPointRequest); }); this._log.debug('Sending data to Signal Fx'); this._signalFxClient.send(signalFxDataPointRequest).catch(error =&gt; { this._log.error('Failed to send metrics to signal fx error:', error); }); } /** * Method for getting raw signal fx api request values from the Timer Object. * * @param {MetricWrapper} metric metric The Wrapped Metric Object. * @param {any} currentBuiltRequest The signal fx request that is being built. * @return {any} the currentBuiltRequest The signal fx request that is being built with the given metric in it. * @protected */ _processMetric(metric, currentBuiltRequest) { const newRequest = Object.assign({}, currentBuiltRequest); const { metricName, metricImpl } = metric; const mergedDimensions = this._getDimensions(metric); const valuesToProcess = this._getValuesToProcessForType(metricName, metricImpl); valuesToProcess.forEach(metricValueTypeWrapper =&gt; { const signalFxDataPointMetric = { metric: metricValueTypeWrapper.metric, value: metricValueTypeWrapper.value, dimensions: mergedDimensions }; if (Object.prototype.hasOwnProperty.call(newRequest, metricValueTypeWrapper.type)) { newRequest[metricValueTypeWrapper.type].push(signalFxDataPointMetric); } else { newRequest[metricValueTypeWrapper.type] = [signalFxDataPointMetric]; } }); return newRequest; } /** * Maps Measured Metrics Object JSON outputs to there respective signal fx metrics using logic from * com.signalfx.codahale.reporter.AggregateMetricSenderSessionWrapper in the java lib to derive naming * * @param {string} name The registered metric base name * @param {Metric} metric The metric. * @return {MetricValueTypeWrapper[]} an array of MetricValueTypeWrapper that can be used to * build the sig fx data point request * @protected */ _getValuesToProcessForType(name, metric) { const type = metric.getType(); switch (type) { case MetricTypes.TIMER: return this._getValuesToProcessForTimer(name, metric); case MetricTypes.GAUGE: return this._getValuesToProcessForGauge(name, metric); case MetricTypes.COUNTER: return this._getValuesToProcessForCounter(name, metric); case MetricTypes.HISTOGRAM: return this._getValuesToProcessForHistogram(name, metric); case MetricTypes.METER: this._log.warn( 'Meters are not implemented in the signal fx reporter as you can use a counter and reduce your DPM' ); return []; default: this._log.error(`Metric Type: ${type} has not been implemented to report to signal fx`); return []; } } /** * Maps and Filters values from a Timer to a set of metrics to report to SigFx. * * @param {string} name The registry name * @param {Timer} timer The Timer * @return {MetricValueTypeWrapper[]} Returns an array of MetricValueTypeWrapper to use to build the request * @protected */ _getValuesToProcessForTimer(name, timer) { let valuesToProcess = []; // only grab histogram data as Meters can be accomplished with signal fx using the count from the histogram valuesToProcess = valuesToProcess.concat(this._getValuesToProcessForHistogram(name, timer.toJSON().histogram)); return valuesToProcess; } /** * Maps and Filters values from a Gauge to a set of metrics to report to SigFx. * * @param {string} name The registry name * @param {Gauge} gauge The Gauge * @return {MetricValueTypeWrapper[]} Returns an array of MetricValueTypeWrapper to use to build the request * @protected */ _getValuesToProcessForGauge(name, gauge) { const valuesToProcess = []; valuesToProcess.push({ metric: `${name}`, value: gauge.toJSON(), type: SIGNAL_FX_GAUGE }); return valuesToProcess; } /** * Maps and Filters values from a Counter to a set of metrics to report to SigFx. * * @param {string} name The registry name * @param {Counter} counter The data from the measure metric object * @return {MetricValueTypeWrapper[]} Returns an array of MetricValueTypeWrapper to use to build the request * @protected */ _getValuesToProcessForCounter(name, counter) { const valuesToProcess = []; valuesToProcess.push({ metric: `${name}.count`, value: counter.toJSON(), type: SIGNAL_FX_CUMULATIVE_COUNTER }); return valuesToProcess; } /** * Maps and Filters values from a Histogram to a set of metrics to report to SigFx. * * @param {string} name The registry name * @param {Histogram} histogram The Histogram * @return {MetricValueTypeWrapper[]} Returns an array of MetricValueTypeWrapper to use to build the request * @protected */ _getValuesToProcessForHistogram(name, histogram) { const data = histogram.toJSON(); const valuesToProcess = []; valuesToProcess.push({ metric: `${name}.count`, value: data.count, type: SIGNAL_FX_CUMULATIVE_COUNTER }); valuesToProcess.push({ metric: `${name}.max`, value: data.max, type: SIGNAL_FX_GAUGE }); valuesToProcess.push({ metric: `${name}.min`, value: data.min, type: SIGNAL_FX_GAUGE }); valuesToProcess.push({ metric: `${name}.mean`, value: data.mean, type: SIGNAL_FX_GAUGE }); valuesToProcess.push({ metric: `${name}.p95`, value: data.p95, type: SIGNAL_FX_GAUGE }); valuesToProcess.push({ metric: `${name}.p99`, value: data.p99, type: SIGNAL_FX_GAUGE }); return valuesToProcess; } } // const SIGNAL_FX_COUNTER = 'counters'; const SIGNAL_FX_GAUGE = 'gauges'; const SIGNAL_FX_CUMULATIVE_COUNTER = 'cumulative_counters'; module.exports = { SignalFxMetricsReporter }; /** * Wrapper object to wrap metric value and SFX metadata needed to send metric value to SFX data ingestion. * * @interface MetricValueTypeWrapper * @typedef MetricValueTypeWrapper * @type {Object} * @property {string} metric The metric name to report to SignalFx * @property {number} value the value to report to SignalFx * @property {string} type The mapped SignalFx metric type */ × Search results Close "},"validators_inputValidators.js.html":{"id":"validators_inputValidators.js.html","title":"Source: validators/inputValidators.js","body":" Measured Classes SignalFxMetricsReporterSignalFxSelfReportingMetricsRegistry Global Global Source: validators/inputValidators.js /** * Validation functions for validating public input * @module SignalFxReporterInputValidators * @private */ module.exports = { /** * Validates that the object supplied for the sfx client at least has a send function * @param signalFxClient */ validateSignalFxClient: signalFxClient =&gt; { if (signalFxClient === undefined) { throw new Error('signalFxClient was undefined when it is required'); } if (typeof signalFxClient.send !== 'function' || signalFxClient.length &lt; 1) { throw new Error('signalFxClient must implement send(data: any)'); } } }; × Search results Close "},"registryies_SignalFxSelfReportingMetricsRegistry.js.html":{"id":"registryies_SignalFxSelfReportingMetricsRegistry.js.html","title":"Source: registryies/SignalFxSelfReportingMetricsRegistry.js","body":" Measured Classes SignalFxMetricsReporterSignalFxSelfReportingMetricsRegistry Global Global Source: registryies/SignalFxSelfReportingMetricsRegistry.js const { NoOpMeter, Timer } = require('measured-core'); const { SelfReportingMetricsRegistry } = require('measured-reporting'); const { validateTimerOptions } = require('measured-reporting').inputValidators; /** * A SignalFx Self Reporting Metrics Registry that disallows the use of meters as they waste DPM and accomplished using a counter. * @extends {SelfReportingMetricsRegistry} */ class SignalFxSelfReportingMetricsRegistry extends SelfReportingMetricsRegistry { /** * Creates a {@link Timer} or get the existing Timer for a given name and dimension combo with a NoOpMeter * * @param {string} name The Metric name * @param {Dimensions} dimensions any custom {@link Dimensions} for the Metric * @param {number} publishingIntervalInSeconds a optional custom publishing interval * @return {Timer} */ getOrCreateTimer(name, dimensions, publishingIntervalInSeconds) { validateTimerOptions(name, dimensions, publishingIntervalInSeconds); let timer; if (this.hasMetric(name, dimensions)) { timer = this.getMetric(name, dimensions); } else { timer = new Timer({ meter: new NoOpMeter() }); const key = this._putMetric(name, timer, dimensions); this._reporter.reportMetricOnInterval(key, publishingIntervalInSeconds); } return timer; } /** * You should use counters and implements meter functionality in your Dashboard. * @param {string} name The Metric name * @param {Dimensions} dimensions any custom {@link Dimensions} for the Metric * @param {number} publishingIntervalInSeconds a optional custom publishing interval * @return {NoOpMeter|*} */ getOrCreateMeter(name, dimensions, publishingIntervalInSeconds) { this._log.error( 'Meters will not get reported using the SignalFx reporter as they waste DPM, please use a counter instead' ); return new NoOpMeter(); } } × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" Measured Classes SignalFxMetricsReporterSignalFxSelfReportingMetricsRegistry Global Global Global Type Definitions MetricValueTypeWrapper Wrapper object to wrap metric value and SFX metadata needed to send metric value to SFX data ingestion. Type: Object Properties: Name Type Description metric string The metric name to report to SignalFx value number the value to report to SignalFx type string The mapped SignalFx metric type Source: reporter/SignalFxMetricsReporter.js, line 214 × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Measured Classes SignalFxMetricsReporterSignalFxSelfReportingMetricsRegistry Global Global Classes Classes SignalFxMetricsReporter SignalFxSelfReportingMetricsRegistry × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" Measured Classes SignalFxMetricsReporterSignalFxSelfReportingMetricsRegistry Global Global Measured SignalFx ReporterInstallnpm install measured-signalfx-reporterDocsSee the full API Docs here. × Search results Close "},"SignalFxMetricsReporter.html":{"id":"SignalFxMetricsReporter.html","title":"Class: SignalFxMetricsReporter","body":" Measured Classes SignalFxMetricsReporterSignalFxSelfReportingMetricsRegistry Global Global Class: SignalFxMetricsReporter SignalFxMetricsReporter A Reporter that reports metrics to Signal Fx new SignalFxMetricsReporter(signalFxClient, options) Parameters: Name Type Description signalFxClient SignalFxClient The configured signal fx client. options ReporterOptions See ReporterOptions. Source: reporter/SignalFxMetricsReporter.js, line 9 Extends Reporter Methods &lt;protected&gt; _getValuesToProcessForCounter(name, counter) Maps and Filters values from a Counter to a set of metrics to report to SigFx. Parameters: Name Type Description name string The registry name counter Counter The data from the measure metric object Source: reporter/SignalFxMetricsReporter.js, line 151 Returns: Returns an array of MetricValueTypeWrapper to use to build the request Type Array.&lt;MetricValueTypeWrapper&gt; &lt;protected&gt; _getValuesToProcessForGauge(name, gauge) Maps and Filters values from a Gauge to a set of metrics to report to SigFx. Parameters: Name Type Description name string The registry name gauge Gauge The Gauge Source: reporter/SignalFxMetricsReporter.js, line 133 Returns: Returns an array of MetricValueTypeWrapper to use to build the request Type Array.&lt;MetricValueTypeWrapper&gt; &lt;protected&gt; _getValuesToProcessForHistogram(name, histogram) Maps and Filters values from a Histogram to a set of metrics to report to SigFx. Parameters: Name Type Description name string The registry name histogram Histogram The Histogram Source: reporter/SignalFxMetricsReporter.js, line 169 Returns: Returns an array of MetricValueTypeWrapper to use to build the request Type Array.&lt;MetricValueTypeWrapper&gt; &lt;protected&gt; _getValuesToProcessForTimer(name, timer) Maps and Filters values from a Timer to a set of metrics to report to SigFx. Parameters: Name Type Description name string The registry name timer Timer The Timer Source: reporter/SignalFxMetricsReporter.js, line 118 Returns: Returns an array of MetricValueTypeWrapper to use to build the request Type Array.&lt;MetricValueTypeWrapper&gt; &lt;protected&gt; _getValuesToProcessForType(name, metric) Maps Measured Metrics Object JSON outputs to there respective signal fx metrics using logic fromcom.signalfx.codahale.reporter.AggregateMetricSenderSessionWrapper in the java lib to derive naming Parameters: Name Type Description name string The registered metric base name metric Metric The metric. Source: reporter/SignalFxMetricsReporter.js, line 88 Returns: an array of MetricValueTypeWrapper that can be used tobuild the sig fx data point request Type Array.&lt;MetricValueTypeWrapper&gt; &lt;protected&gt; _processMetric(metric, currentBuiltRequest) Method for getting raw signal fx api request values from the Timer Object. Parameters: Name Type Description metric MetricWrapper metric The Wrapped Metric Object. currentBuiltRequest any The signal fx request that is being built. Source: reporter/SignalFxMetricsReporter.js, line 53 Returns: the currentBuiltRequest The signal fx request that is being built with the given metric in it. Type any &lt;protected&gt; _reportMetrics(metrics) Sends metrics to signal fx, converting name and dimensions and Metric to data signal fx can ingest Parameters: Name Type Description metrics Array.&lt;MetricWrapper&gt; The array of metrics to send to signal fx. Source: reporter/SignalFxMetricsReporter.js, line 25 × Search results Close "},"SignalFxSelfReportingMetricsRegistry.html":{"id":"SignalFxSelfReportingMetricsRegistry.html","title":"Class: SignalFxSelfReportingMetricsRegistry","body":" Measured Classes SignalFxMetricsReporterSignalFxSelfReportingMetricsRegistry Global Global Class: SignalFxSelfReportingMetricsRegistry SignalFxSelfReportingMetricsRegistry A SignalFx Self Reporting Metrics Registry that disallows the use of meters as they waste DPM and accomplished using a counter. new SignalFxSelfReportingMetricsRegistry() Source: registryies/SignalFxSelfReportingMetricsRegistry.js, line 9 Extends SelfReportingMetricsRegistry Methods getOrCreateMeter(name, dimensions, publishingIntervalInSeconds) You should use counters and implements meter functionality in your Dashboard. Parameters: Name Type Description name string The Metric name dimensions Dimensions any custom Dimensions for the Metric publishingIntervalInSeconds number a optional custom publishing interval Source: registryies/SignalFxSelfReportingMetricsRegistry.js, line 40 Returns: Type NoOpMeter | * getOrCreateTimer(name, dimensions, publishingIntervalInSeconds) Creates a Timer or get the existing Timer for a given name and dimension combo with a NoOpMeter Parameters: Name Type Description name string The Metric name dimensions Dimensions any custom Dimensions for the Metric publishingIntervalInSeconds number a optional custom publishing interval Source: registryies/SignalFxSelfReportingMetricsRegistry.js, line 18 Returns: Type Timer × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
