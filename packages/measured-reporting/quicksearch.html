<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"registries_DimensionAwareMetricsRegistry.js.html":{"id":"registries_DimensionAwareMetricsRegistry.js.html","title":"Source: registries/DimensionAwareMetricsRegistry.js","body":" Measured Classes ReporterSelfReportingMetricsRegistry Tutorials SignalFx Express Full End to End Example Global Global Source: registries/DimensionAwareMetricsRegistry.js /** * Simple registry that stores Metrics by name and dimension * @private */ class DimensionAwareMetricsRegistry { constructor() { this._metrics = {}; } /** * Checks to see if a metric with the given name and dimensions is present. * * @param {string} name The metric name * @param {Dimensions} dimensions The dimensions for the metric * @returns {boolean} true if the metric with given dimensions is present */ hasMetric(name, dimensions) { const key = this._generateStorageKey(name, dimensions); return Object.prototype.hasOwnProperty.call(this._metrics, key); } /** * Retrieves a metric with a given name and dimensions is present. * * @param {string} name The metric name * @param {Dimensions} dimensions The dimensions for the metric * @returns {Metric} a wrapper object around name, dimension and {@link Metric} */ getMetric(name, dimensions) { const key = this._generateStorageKey(name, dimensions); return this._metrics[key].metricImpl; } /** * Retrieves a metric by the calculated key (name / dimension combo). * * @param {string} key The registered key for the given registered {@link MetricWrapper} * @returns {MetricWrapper} a wrapper object around name, dimension and {@link Metric} */ getMetricWrapperByKey(key) { return this._metrics[key]; } /** * Upserts a {@link Metric} in the internal storage map for a given name, dimension combo * * @param {string} name The metric name * @param {Metric} metric The {@link Metric} impl * @param {Dimensions} dimensions The dimensions for the metric * @return {string} The registry key for the metric, dimension combo */ putMetric(name, metric, dimensions) { const key = this._generateStorageKey(name, dimensions); this._metrics[key] = { name: name, metricImpl: metric, dimensions: dimensions || {} }; return key; } allKeys() { return Object.keys(this._metrics); } /** * Generates a unique key off of the metric name and custom dimensions for internal use in the registry maps. * * @param {string} name The metric name * @param {Dimensions} dimensions The dimensions for the metric * @return {string} a unique key based off of the metric nae and dimensions * @private */ _generateStorageKey(name, dimensions) { let key = name; if (dimensions) { Object.keys(dimensions).forEach(dimensionKey =&gt; { key = `${key}-${dimensions[dimensionKey]}`; }); } return key; } } module.exports = DimensionAwareMetricsRegistry; × Search results Close "},"@types_types.js.html":{"id":"@types_types.js.html","title":"Source: @types/types.js","body":" Measured Classes ReporterSelfReportingMetricsRegistry Tutorials SignalFx Express Full End to End Example Global Global Source: @types/types.js /** * A wrapper object around a {@link Metric}, {@link Dimensions} and the metric name * * @interface MetricWrapper * @typedef MetricWrapper * @type {Object} * @property {string} name The supplied name of the Metric * @property {Metric} metric The {@link Metric} object * @property {Dimensions} dimensions The {@link Dimensions} for the given {@link Metric} */ /** * A Dictionary of string, string key value pairs * * @interface Dimensions * @typedef Dimensions * @type {Object.&lt;string, string&gt;} * * @example * { * path: &quot;/api/foo&quot; * method: &quot;GET&quot; * statusCode: &quot;200&quot; * } */ × Search results Close "},"validators_inputValidators.js.html":{"id":"validators_inputValidators.js.html","title":"Source: validators/inputValidators.js","body":" Measured Classes ReporterSelfReportingMetricsRegistry Tutorials SignalFx Express Full End to End Example Global Global Source: validators/inputValidators.js const Optional = require('optional-js'); /** * This module contains various validators to validate publicly exposed input * @module inputValidators * @private */ module.exports = { /** * Validates @{link Gauge} options. * * @param {string} name The metric name * @param {function} callback The callback for the Gauge * @param {Dimensions} dimensions The optional custom dimensions * @param {number} publishingIntervalInSeconds the optional publishing interval */ validateGaugeOptions: (name, callback, dimensions, publishingIntervalInSeconds) =&gt; { module.exports.validateMetricName(name); module.exports.validateNumberReturningCallback(callback); module.exports.validateOptionalDimensions(dimensions); module.exports.validateOptionalPublishingInterval(publishingIntervalInSeconds); }, /** * Validates the create histogram Options. * * @param {string} name The metric name * @param {Dimensions} dimensions The optional custom dimensions * @param {number} publishingIntervalInSeconds the optional publishing interval */ validateHistogramOptions: (name, dimensions, publishingIntervalInSeconds) =&gt; { module.exports.validateMetricName(name); module.exports.validateOptionalDimensions(dimensions); module.exports.validateOptionalPublishingInterval(publishingIntervalInSeconds); }, /** * Validates the create counter Options. * * @param {string} name The metric name * @param {Dimensions} dimensions The optional custom dimensions * @param {number} publishingIntervalInSeconds the optional publishing interval */ validateCounterOptions: (name, dimensions, publishingIntervalInSeconds) =&gt; { module.exports.validateMetricName(name); module.exports.validateOptionalDimensions(dimensions); module.exports.validateOptionalPublishingInterval(publishingIntervalInSeconds); }, /** * Validates the create timer Options. * * @param {string} name The metric name * @param {Dimensions} dimensions The optional custom dimensions * @param {number} publishingIntervalInSeconds the optional publishing interval */ validateTimerOptions: (name, dimensions, publishingIntervalInSeconds) =&gt; { module.exports.validateMetricName(name); module.exports.validateOptionalDimensions(dimensions); module.exports.validateOptionalPublishingInterval(publishingIntervalInSeconds); }, /** * Validates the create timer Options. * * @param {string} name The metric name * @param {Metric} metric The metric instance * @param {Dimensions} dimensions The optional custom dimensions * @param {number} publishingIntervalInSeconds the optional publishing interval */ validateRegisterOptions: (name, metric, dimensions, publishingIntervalInSeconds) =&gt; { module.exports.validateMetricName(name); // todo validate metric module.exports.validateOptionalDimensions(dimensions); module.exports.validateOptionalPublishingInterval(publishingIntervalInSeconds); }, /** * Validates the create settable gauge Options. * * @param {string} name The metric name * @param {Dimensions} dimensions The optional custom dimensions * @param {number} publishingIntervalInSeconds the optional publishing interval */ validateSettableGaugeOptions: (name, dimensions, publishingIntervalInSeconds) =&gt; { module.exports.validateMetricName(name); module.exports.validateOptionalDimensions(dimensions); module.exports.validateOptionalPublishingInterval(publishingIntervalInSeconds); }, /** * Validates the metric name. * * @param name The metric name. */ validateMetricName: name =&gt; { const type = typeof name; if (type !== 'string') { throw new Error(`options.name is a required option and must be of type string, actual type: ${type}`); } }, /** * Validates the provided callback. * * @param callback The provided callback for a gauge. */ validateNumberReturningCallback: callback =&gt; { const type = typeof callback; if (type !== 'function') { throw new Error(`options.callback is a required option and must be function, actual type: ${type}`); } const callbackType = typeof callback(); if (callbackType !== 'number') { throw new Error(`options.callback must return a number, actual return type: ${callbackType}`); } }, /** * Validates a set of optional dimensions * @param dimensionsOptional */ validateOptionalDimensions: dimensionsOptional =&gt; { Optional.ofNullable(dimensionsOptional).ifPresent(dimensions =&gt; { const type = typeof dimensions; if (type !== 'object') { throw new Error(`options.dimensions should be an object, actual type: ${type}`); } Object.keys(dimensions).forEach(key =&gt; { const valueType = typeof dimensions[key]; if (valueType !== 'string') { throw new Error(`options.dimensions.${key} should be of type string, actual type: ${type}`); } }); }); }, /** * Validates an optional logger instance * @param loggerOptional */ validateOptionalLogger: loggerOptional =&gt; { Optional.ofNullable(loggerOptional).ifPresent(logger =&gt; { if ( typeof logger.trace !== 'function' || typeof logger.debug !== 'function' || typeof logger.info !== 'function' || typeof logger.warn !== 'function' || typeof logger.error !== 'function' ) { throw new Error( 'The logger that was passed in does not support all required ' + 'logging methods, expected object to have functions trace, debug, info, warn, and error with ' + 'method signatures (...msgs) =&gt; {}' ); } }); }, /** * Validates the optional publishing interval. * * @param publishingIntervalInSecondsOptional The optional publishing interval. */ validateOptionalPublishingInterval: publishingIntervalInSecondsOptional =&gt; { Optional.ofNullable(publishingIntervalInSecondsOptional).ifPresent(publishingIntervalInSeconds =&gt; { const type = typeof publishingIntervalInSeconds; if (type !== 'number') { throw new Error(`options.publishingIntervalInSeconds must be of type number, actual type: ${type}`); } }); }, validateReporterParameters: options =&gt; { module.exports.validateOptionalDimensions(options.defaultDimensions); module.exports.validateOptionalLogger(options.logger); }, /** * Validates that a valid Reporter object has been supplied */ validateReporterInstance: reporter =&gt; { // TODO implement }, /** * Validates the input parameters for a {@link SelfReportingMetricsRegistry} * @param reporter * @param logger */ validateSelfReportingMetricsRegistryParameters: (reporter, logger) =&gt; { // TODO implement } }; × Search results Close "},"reporters_Reporter.js.html":{"id":"reporters_Reporter.js.html","title":"Source: reporters/Reporter.js","body":" Measured Classes ReporterSelfReportingMetricsRegistry Tutorials SignalFx Express Full End to End Example Global Global Source: reporters/Reporter.js const bunyan = require('bunyan'); const Optional = require('optional-js'); const { validateReporterParameters } = require('../validators/inputValidators'); const DEFAULT_REPORTING_INTERVAL_IN_SECONDS = 10; /** * The abstract reporter that specific implementations can extend to create a Self Reporting Metrics Registry Reporter. * * {@link SelfReportingMetricsRegistry} * @abstract */ class Reporter { /** * @param {ReporterOptions} [options] The optional params to supply when creating a reporter. */ constructor(options) { if (this.constructor === Reporter) { throw new TypeError(&quot;Can't instantiate abstract class!&quot;); } options = options || {}; validateReporterParameters(options); /** * Map of intervals to metric keys, this will be used to look up what metrics should be reported at a given interval. * @type {Object.&lt;number, Set&lt;string&gt;&gt;} * @private */ this._intervalToMetric = {}; this._intervals = []; /** * Map of default dimensions, that should be sent with every metric * @type {Dimensions} * @protected */ this._defaultDimensions = options.defaultDimensions || {}; /** * Loggers to use, defaults to a new bunyan logger if nothing is supplied in options * @type {Logger} * @protected */ this._log = options.logger || bunyan.createLogger({ name: 'Reporter', level: options.logLevel || 'info' }); /** * the default interval a number in seconds. * @type {number} * @protected */ this._defaultReportingIntervalInSeconds = options.defaultReportingIntervalInSeconds || DEFAULT_REPORTING_INTERVAL_IN_SECONDS; } /** * Sets the registry, this must be called before reportMetricOnInterval. * * @param {DimensionAwareMetricsRegistry} registry */ setRegistry(registry) { this._registry = registry; } /** * Informs the reporter to report a metric on a given interval in seconds. * * @param {string} metricKey The metric key for the metric in the metric registry. * @param {number} intervalInSeconds The interval in seconds to report the metric on. */ reportMetricOnInterval(metricKey, intervalInSeconds) { intervalInSeconds = intervalInSeconds || this._defaultReportingIntervalInSeconds; if (!this._registry) { throw new Error( 'You must call setRegistry(registry) before telling a Reporter to report a metric on an interval.' ); } if (Object.prototype.hasOwnProperty.call(this._intervalToMetric, intervalInSeconds)) { this._intervalToMetric[intervalInSeconds].add(metricKey); } else { this._intervalToMetric[intervalInSeconds] = new Set([metricKey]); this._reportMetricsWithInterval(intervalInSeconds); this._createIntervalCallback(intervalInSeconds); } } /** * Creates the timed callback loop for the given interval. * * @param {number} intervalInSeconds the interval in seconds for the timeout callback * @private */ _createIntervalCallback(intervalInSeconds) { this._log.debug(`_createIntervalCallback() called with intervalInSeconds: ${intervalInSeconds}`); this._intervals.push( setInterval(() =&gt; { this._reportMetricsWithInterval(intervalInSeconds); }, intervalInSeconds * 1000) ); } /** * Gathers all the metrics that have been registered to report on the given interval. * * @param {number} interval The interval to look up what metrics to report * @private */ _reportMetricsWithInterval(interval) { this._log.debug(`_reportMetricsWithInterval() called with intervalInSeconds: ${interval}`); try { Optional.of(this._intervalToMetric[interval]).ifPresent(metrics =&gt; { const metricsToSend = []; metrics.forEach(metricKey =&gt; { metricsToSend.push(this._registry.getMetricWrapperByKey(metricKey)); }); this._reportMetrics(metricsToSend); }); } catch (error) { this._log.error('Failed to send metrics to signal fx', error); } } /** * This method gets called with an array of {@link MetricWrapper} on an interval, when metrics should be reported. * * This is the main method that needs to get implemented when created an aggregator specific reporter. * * @param {MetricWrapper[]} metrics The array of metrics to report. * @protected * @abstract */ _reportMetrics(metrics) { throw new TypeError('Abstract method _reportMetrics(metrics) must be implemented in implementation class'); } /** * * @param {MetricWrapper} metric The Wrapped Metric Object. * @return {Dimensions} The left merged default dimensions with the metric specific dimensions * @private */ _getDimensions(metric) { return Object.assign({}, this._defaultDimensions, metric.dimensions); } /** * Clears the intervals that are running to report metrics at an interval, and resets the state. */ shutdown() { this._intervals.forEach(interval =&gt; clearInterval(interval)); this._intervals = []; this._intervalToMetric = {}; } } /** * Options for creating a {@link Reporter} * @interface ReporterOptions * @typedef ReporterOptions * @type {Object} * @property {Dimensions} defaultDimensions A dictionary of dimensions to include with every metric reported * @property {Logger} logger The logger to use, if not supplied a new Buynan logger will be created * @property {string} logLevel The log level to use with the created Bunyan logger if you didn't supply your own logger. * @property {number} defaultReportingIntervalInSeconds The default reporting interval to use if non is supplied when registering a metric, defaults to 10 seconds. */ module.exports = Reporter; × Search results Close "},"registries_SelfReportingMetricsRegistry.js.html":{"id":"registries_SelfReportingMetricsRegistry.js.html","title":"Source: registries/SelfReportingMetricsRegistry.js","body":" Measured Classes ReporterSelfReportingMetricsRegistry Tutorials SignalFx Express Full End to End Example Global Global Source: registries/SelfReportingMetricsRegistry.js const bunyan = require('bunyan'); const { SettableGauge, Gauge, Timer, Counter, Meter, Histogram } = require('measured-core'); const DimensionAwareMetricsRegistry = require('./DimensionAwareMetricsRegistry'); const { validateSelfReportingMetricsRegistryParameters, validateRegisterOptions, validateGaugeOptions, validateCounterOptions, validateHistogramOptions, validateTimerOptions, validateSettableGaugeOptions } = require('../validators/inputValidators'); /** * A dimensional aware self-reporting metrics registry */ class SelfReportingMetricsRegistry { /** * @param {Reporter} reporter The Metrics Reporter * @param {SelfReportingMetricsRegistryOptions} [options] Configurable options for the Self Reporting Metrics Registry */ constructor(reporter, options) { options = options || {}; validateSelfReportingMetricsRegistryParameters(reporter, options.logger); /** * @type {Reporter} * @protected */ this._reporter = reporter; /** * @type {DimensionAwareMetricsRegistry} * @protected */ this._registry = options.registry || new DimensionAwareMetricsRegistry(); this._reporter.setRegistry(this._registry); /** * Loggers to use, defaults to a new bunyan logger if nothing is supplied in options * @type {Logger} * @protected */ this._log = options.logger || bunyan.createLogger({ name: 'SelfReportingMetricsRegistry', level: options.logLevel || 'info' }); } /** * Registers a manually created Metric. * * @param {string} name The Metric name * @param {Metric} metric The {@link Metric} to register * @param {Dimensions} [dimensions] any custom {@link Dimensions} for the Metric * @param {number} [publishingIntervalInSeconds] a optional custom publishing interval * @example * const settableGauge = new SettableGauge(5); * // register the gauge and have it report to every 10 seconds * registry.register('my-gauge', settableGauge, {}, 10); * interval(() =&gt; { * // such as cpu % used * determineAValueThatCannotBeSync((value) =&gt; { * settableGauge.update(value); * }) * }, 10000) */ register(name, metric, dimensions, publishingIntervalInSeconds) { validateRegisterOptions(name, metric, dimensions, publishingIntervalInSeconds); if (this._registry.hasMetric(name, dimensions)) { throw new Error( `Metric with name: ${name} and dimensions: ${JSON.stringify(dimensions)} has already been registered` ); } else { const key = this._registry.putMetric(name, metric, dimensions); this._reporter.reportMetricOnInterval(key, publishingIntervalInSeconds); } return metric; } /** * Creates a {@link Gauge} or gets the existing Gauge for a given name and dimension combo * * @param {string} name The Metric name * @param {function} callback The callback that will return a value to report to signal fx * @param {Dimensions} [dimensions] any custom {@link Dimensions} for the Metric * @param {number} [publishingIntervalInSeconds] a optional custom publishing interval * @return {Gauge} * @example * // https://nodejs.org/api/process.html#process_process_memoryusage * // Report heap total and heap used at the default interval * registry.getOrCreateGauge( * 'process-memory-heap-total', * () =&gt; { * return process.memoryUsage().heapTotal * } * ); * registry.getOrCreateGauge( * 'process-memory-heap-used', * () =&gt; { * return process.memoryUsage().heapUsed * } * ) */ getOrCreateGauge(name, callback, dimensions, publishingIntervalInSeconds) { validateGaugeOptions(name, callback, dimensions, publishingIntervalInSeconds); let gauge; if (this._registry.hasMetric(name, dimensions)) { gauge = this._registry.getMetric(name, dimensions); } else { gauge = new Gauge(callback); const key = this._registry.putMetric(name, gauge, dimensions); this._reporter.reportMetricOnInterval(key, publishingIntervalInSeconds); } return gauge; } /** * Creates a {@link Histogram} or gets the existing Histogram for a given name and dimension combo * * @param {string} name The Metric name * @param {Dimensions} dimensions any custom {@link Dimensions} for the Metric * @param {number} publishingIntervalInSeconds a optional custom publishing interval * @return {Histogram} */ getOrCreateHistogram(name, dimensions, publishingIntervalInSeconds) { validateHistogramOptions(name, dimensions, publishingIntervalInSeconds); let histogram; if (this._registry.hasMetric(name, dimensions)) { histogram = this._registry.getMetric(name, dimensions); } else { histogram = new Histogram(); const key = this._registry.putMetric(name, histogram, dimensions); this._reporter.reportMetricOnInterval(key, publishingIntervalInSeconds); } return histogram; } /** * Creates a {@link Meter} or gets the existing Meter for a given name and dimension combo * * @param {string} name The Metric name * @param {Dimensions} dimensions any custom {@link Dimensions} for the Metric * @param {number} publishingIntervalInSeconds a optional custom publishing interval * @return {Meter} */ getOrCreateMeter(name, dimensions, publishingIntervalInSeconds) { // todo validate options let meter; if (this._registry.hasMetric(name, dimensions)) { meter = this._registry.getMetric(name, dimensions); } else { meter = new Meter(); const key = this._registry.putMetric(name, meter, dimensions); this._reporter.reportMetricOnInterval(key, publishingIntervalInSeconds); } return meter; } /** * Creates a {@link Counter} or gets the existing Counter for a given name and dimension combo * * @param {string} name The Metric name * @param {Dimensions} dimensions any custom {@link Dimensions} for the Metric * @param {number} publishingIntervalInSeconds a optional custom publishing interval * @return {Counter} */ getOrCreateCounter(name, dimensions, publishingIntervalInSeconds) { validateCounterOptions(name, dimensions, publishingIntervalInSeconds); let counter; if (this._registry.hasMetric(name, dimensions)) { counter = this._registry.getMetric(name, dimensions); } else { counter = new Counter(); const key = this._registry.putMetric(name, counter, dimensions); this._reporter.reportMetricOnInterval(key, publishingIntervalInSeconds); } return counter; } /** * Creates a {@link Timer} or gets the existing Timer for a given name and dimension combo. * * @param {string} name The Metric name * @param {Dimensions} dimensions any custom {@link Dimensions} for the Metric * @param {number} publishingIntervalInSeconds a optional custom publishing interval * @return {Timer} */ getOrCreateTimer(name, dimensions, publishingIntervalInSeconds) { validateTimerOptions(name, dimensions, publishingIntervalInSeconds); let timer; if (this._registry.hasMetric(name, dimensions)) { timer = this._registry.getMetric(name, dimensions); } else { timer = new Timer(); const key = this._registry.putMetric(name, timer, dimensions); this._reporter.reportMetricOnInterval(key, publishingIntervalInSeconds); } return timer; } /** * Creates a {@link SettableGauge} or gets the existing SettableGauge for a given name and dimension combo. * * @param name * @param dimensions * @param publishingIntervalInSeconds */ getOrCreateSettableGauge(name, dimensions, publishingIntervalInSeconds) { validateSettableGaugeOptions(name, dimensions, publishingIntervalInSeconds); let settableGauge; if (this._registry.hasMetric(name, dimensions)) { settableGauge = this._registry.getMetric(name, dimensions); } else { settableGauge = new SettableGauge(); const key = this._registry.putMetric(name, settableGauge, dimensions); this._reporter.reportMetricOnInterval(key, publishingIntervalInSeconds); } return settableGauge; } /** * Calls end on all metrics in the registry that support end() and calls end on the reporter */ shutdown() { // shutdown the reporter this._reporter.shutdown(); // shutdown any metrics that have an end method this._registry.allKeys().forEach(key =&gt; { const metricWrapper = this._registry.getMetricWrapperByKey(key); if (metricWrapper.metric.end) { metricWrapper.metric.end(); } }); } } module.exports = SelfReportingMetricsRegistry; /** * Configurable options for the Self Reporting Metrics Registry * * @interface SelfReportingMetricsRegistryOptions * @typedef SelfReportingMetricsRegistryOptions * @property {Logger} logger the Logger to use * @property {string} logLevel The Log level to use if defaulting to included logger * @property {DimensionAwareMetricsRegistry} registry The registry to use, defaults to new DimensionAwareMetricsRegistry */ × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" Measured Classes ReporterSelfReportingMetricsRegistry Tutorials SignalFx Express Full End to End Example Global Global Global Type Definitions Dimensions A Dictionary of string, string key value pairs Type: Object.&lt;string, string&gt; Source: @types/types.js, line 12 Example { path: &quot;/api/foo&quot; method: &quot;GET&quot; statusCode: &quot;200&quot; } MetricWrapper A wrapper object around a Metric, Dimensions and the metric name Type: Object Properties: Name Type Description name string The supplied name of the Metric metric Metric The Metric object dimensions Dimensions The Dimensions for the given Metric Source: @types/types.js, line 1 ReporterOptions Options for creating a Reporter Type: Object Properties: Name Type Description defaultDimensions Dimensions A dictionary of dimensions to include with every metric reported logger Logger The logger to use, if not supplied a new Buynan logger will be created logLevel string The log level to use with the created Bunyan logger if you didn't supply your own logger. defaultReportingIntervalInSeconds number The default reporting interval to use if non is supplied when registering a metric, defaults to 10 seconds. Source: reporters/Reporter.js, line 160 SelfReportingMetricsRegistryOptions Configurable options for the Self Reporting Metrics Registry Properties: Name Type Description logger Logger the Logger to use logLevel string The Log level to use if defaulting to included logger registry DimensionAwareMetricsRegistry The registry to use, defaults to new DimensionAwareMetricsRegistry Source: registries/SelfReportingMetricsRegistry.js, line 257 × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Measured Classes ReporterSelfReportingMetricsRegistry Tutorials SignalFx Express Full End to End Example Global Global Classes Classes Reporter SelfReportingMetricsRegistry × Search results Close "},"tutorials.list.html":{"id":"tutorials.list.html","title":"Tutorials","body":" Measured Classes ReporterSelfReportingMetricsRegistry Tutorials SignalFx Express Full End to End Example Global Global Tutorials Classes Reporter SelfReportingMetricsRegistry × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" Measured Classes ReporterSelfReportingMetricsRegistry Tutorials SignalFx Express Full End to End Example Global Global Measured ReportingThe registry and reporting library that has the classes needed to create a dimension aware, self reporting metrics registry. Installnpm install measured-reportingWhat is in this packageSelf Reporting Metrics RegistryA dimensional aware self-reporting metrics registry, just supply this class with a reporter implementation at instantiation and this is all you need to instrument application level metrics in your app. Reporter Abstract ClassThe base class for reporter implementations. This class is extended and the _reportMetrics(metrics) method gets overridden to create an data aggregator specific reporter. See the SignalFx Reporter for an example implementation. What are dimensions?As described by Signal Fx: A dimension is a key/value pair that, along with the metric name, is part of the identity of a time series.You can filter and aggregate time series by those dimensions across SignalFx. DataDog has a nice blog post about how they are used in their aggregator api. Graphite also supports the concept via tags. × Search results Close "},"Reporter.html":{"id":"Reporter.html","title":"Class: Reporter","body":" Measured Classes ReporterSelfReportingMetricsRegistry Tutorials SignalFx Express Full End to End Example Global Global Class: Reporter Reporter The abstract reporter that specific implementations can extend to create a Self Reporting Metrics Registry Reporter. SelfReportingMetricsRegistry &lt;abstract&gt; new Reporter( [options]) Parameters: Name Type Argument Description options ReporterOptions &lt;optional&gt; The optional params to supply when creating a reporter. Source: reporters/Reporter.js, line 13 Members &lt;protected&gt; _defaultDimensions :Dimensions Map of default dimensions, that should be sent with every metric Type: Dimensions Source: reporters/Reporter.js, line 38 &lt;protected&gt; _defaultReportingIntervalInSeconds :number the default interval a number in seconds. Type: number Source: reporters/Reporter.js, line 54 &lt;protected&gt; _log :Logger Loggers to use, defaults to a new bunyan logger if nothing is supplied in options Type: Logger Source: reporters/Reporter.js, line 45 Methods &lt;abstract, protected&gt; _reportMetrics(metrics) This method gets called with an array of MetricWrapper on an interval, when metrics should be reported. This is the main method that needs to get implemented when created an aggregator specific reporter. Parameters: Name Type Description metrics Array.&lt;MetricWrapper&gt; The array of metrics to report. Source: reporters/Reporter.js, line 136 reportMetricOnInterval(metricKey, intervalInSeconds) Informs the reporter to report a metric on a given interval in seconds. Parameters: Name Type Description metricKey string The metric key for the metric in the metric registry. intervalInSeconds number The interval in seconds to report the metric on. Source: reporters/Reporter.js, line 73 setRegistry(registry) Sets the registry, this must be called before reportMetricOnInterval. Parameters: Name Type Description registry DimensionAwareMetricsRegistry Source: reporters/Reporter.js, line 63 shutdown() Clears the intervals that are running to report metrics at an interval, and resets the state. Source: reporters/Reporter.js, line 153 × Search results Close "},"SelfReportingMetricsRegistry.html":{"id":"SelfReportingMetricsRegistry.html","title":"Class: SelfReportingMetricsRegistry","body":" Measured Classes ReporterSelfReportingMetricsRegistry Tutorials SignalFx Express Full End to End Example Global Global Class: SelfReportingMetricsRegistry SelfReportingMetricsRegistry A dimensional aware self-reporting metrics registry new SelfReportingMetricsRegistry(reporter [, options]) Parameters: Name Type Argument Description reporter Reporter The Metrics Reporter options SelfReportingMetricsRegistryOptions &lt;optional&gt; Configurable options for the Self Reporting Metrics Registry Source: registries/SelfReportingMetricsRegistry.js, line 24 Members &lt;protected&gt; _log :Logger Loggers to use, defaults to a new bunyan logger if nothing is supplied in options Type: Logger Source: registries/SelfReportingMetricsRegistry.js, line 51 &lt;protected&gt; _registry :DimensionAwareMetricsRegistry Type: DimensionAwareMetricsRegistry Source: registries/SelfReportingMetricsRegistry.js, line 43 &lt;protected&gt; _reporter :Reporter Type: Reporter Source: registries/SelfReportingMetricsRegistry.js, line 37 Methods getOrCreateCounter(name, dimensions, publishingIntervalInSeconds) Creates a Counter or gets the existing Counter for a given name and dimension combo Parameters: Name Type Description name string The Metric name dimensions Dimensions any custom Dimensions for the Metric publishingIntervalInSeconds number a optional custom publishing interval Source: registries/SelfReportingMetricsRegistry.js, line 179 Returns: Type Counter getOrCreateGauge(name, callback [, dimensions] [, publishingIntervalInSeconds]) Creates a Gauge or gets the existing Gauge for a given name and dimension combo Parameters: Name Type Argument Description name string The Metric name callback function The callback that will return a value to report to signal fx dimensions Dimensions &lt;optional&gt; any custom Dimensions for the Metric publishingIntervalInSeconds number &lt;optional&gt; a optional custom publishing interval Source: registries/SelfReportingMetricsRegistry.js, line 112 Returns: Type Gauge Example // https://nodejs.org/api/process.html#process_process_memoryusage // Report heap total and heap used at the default interval registry.getOrCreateGauge( 'process-memory-heap-total', () =&gt; { return process.memoryUsage().heapTotal } ); registry.getOrCreateGauge( 'process-memory-heap-used', () =&gt; { return process.memoryUsage().heapUsed } ) getOrCreateHistogram(name, dimensions, publishingIntervalInSeconds) Creates a Histogram or gets the existing Histogram for a given name and dimension combo Parameters: Name Type Description name string The Metric name dimensions Dimensions any custom Dimensions for the Metric publishingIntervalInSeconds number a optional custom publishing interval Source: registries/SelfReportingMetricsRegistry.js, line 133 Returns: Type Histogram getOrCreateMeter(name, dimensions, publishingIntervalInSeconds) Creates a Meter or gets the existing Meter for a given name and dimension combo Parameters: Name Type Description name string The Metric name dimensions Dimensions any custom Dimensions for the Metric publishingIntervalInSeconds number a optional custom publishing interval Source: registries/SelfReportingMetricsRegistry.js, line 156 Returns: Type Meter getOrCreateSettableGauge(name, dimensions, publishingIntervalInSeconds) Creates a SettableGauge or gets the existing SettableGauge for a given name and dimension combo. Parameters: Name Type Description name dimensions publishingIntervalInSeconds Source: registries/SelfReportingMetricsRegistry.js, line 224 getOrCreateTimer(name, dimensions, publishingIntervalInSeconds) Creates a Timer or gets the existing Timer for a given name and dimension combo. Parameters: Name Type Description name string The Metric name dimensions Dimensions any custom Dimensions for the Metric publishingIntervalInSeconds number a optional custom publishing interval Source: registries/SelfReportingMetricsRegistry.js, line 202 Returns: Type Timer register(name, metric [, dimensions] [, publishingIntervalInSeconds]) Registers a manually created Metric. Parameters: Name Type Argument Description name string The Metric name metric Metric The Metric to register dimensions Dimensions &lt;optional&gt; any custom Dimensions for the Metric publishingIntervalInSeconds number &lt;optional&gt; a optional custom publishing interval Source: registries/SelfReportingMetricsRegistry.js, line 74 Example const settableGauge = new SettableGauge(5); // register the gauge and have it report to every 10 seconds registry.register('my-gauge', settableGauge, {}, 10); interval(() =&gt; { // such as cpu % used determineAValueThatCannotBeSync((value) =&gt; { settableGauge.update(value); }) }, 10000) shutdown() Calls end on all metrics in the registry that support end() and calls end on the reporter Source: registries/SelfReportingMetricsRegistry.js, line 242 × Search results Close "},"tutorial-SignalFx Express Full End to End Example.html":{"id":"tutorial-SignalFx Express Full End to End Example.html","title":"Tutorial: SignalFx Express Full End to End Example","body":" Measured Classes ReporterSelfReportingMetricsRegistry Tutorials SignalFx Express Full End to End Example Global Global SignalFx Express Full End to End Example Using Measured to instrument OS, Process and Express Metrics.This tutorial shows how to use the measured libraries to fully instrument OS and Node Process metrics as well as create an express middleware. The middleware will measure request count, latency distributions (req/res time histogram) and add dimensions to make it filterable by request method, response status code, request uri path. const os = require('os'); const signalfx = require('signalfx'); const express = require('express'); const { SignalFxMetricsReporter, SignalFxSelfReportingMetricsRegistry } = require('measured-signalfx-reporter'); const { Stopwatch } = require('measured-core'); const libraryMetadata = require('./package'); // get metadata from package.json const library = libraryMetadata.name; const version = libraryMetadata.version; // report process and os stats 1x per minute const PROCESS_AND_SYSTEM_METRICS_REPORTING_INTERVAL_IN_SECONDS = 1; // Report the request count and histogram stats every 10 seconds const REQUEST_METRICS_REPORTING_INTERVAL_IN_SECONDS = 10; const defaultDimensions = { app: library, app_version: version, env: 'test' }; /** * Get your api key from a secrets provider of some kind. * * Good examples: * * &lt;li&gt; S3 with KMS * &lt;li&gt; Cerberus * &lt;li&gt; AWS Secrets Manager * &lt;li&gt; Vault * &lt;li&gt; Confidant * * Bad examples: * * &lt;li&gt; Checked into SCM in plaintext as a property * &lt;li&gt; Set as a plaintext environment variable * * @return {string} Returns the resolved Signal Fx Api Key */ const apiKeyResolver = () =&gt; { // https://diogomonica.com/2017/03/27/why-you-shouldnt-use-env-variables-for-secret-data/ return process.env.SIGNALFX_API_KEY }; // create the signal fx client const signalFxClient = new signalfx.Ingest(apiKeyResolver(), { userAgents: library }); // create the signal fx reporter with the client const signalFxReporter = new SignalFxMetricsReporter(signalFxClient, { defaultDimensions: defaultDimensions, defaultReportingIntervalInSeconds: 10 }); // create the self reporting metrics registry with the signal fx reporter const metricsRegistry = new SignalFxSelfReportingMetricsRegistry(signalFxReporter); metricsRegistry.getOrCreateGauge( 'os-1m-load-average', () =&gt; { // os.loadavg returns an array [1, 5, 15] mins intervals return os.loadavg()[0] }, {}, PROCESS_AND_SYSTEM_METRICS_REPORTING_INTERVAL_IN_SECONDS ); metricsRegistry.getOrCreateGauge( 'os-free-mem-bytes', () =&gt; { return os.freemem() }, {}, PROCESS_AND_SYSTEM_METRICS_REPORTING_INTERVAL_IN_SECONDS ); metricsRegistry.getOrCreateGauge( 'os-total-mem-bytes', () =&gt; { return os.totalmem() }, {}, PROCESS_AND_SYSTEM_METRICS_REPORTING_INTERVAL_IN_SECONDS ); // https://nodejs.org/api/process.html#process_process_memoryusage metricsRegistry.getOrCreateGauge( 'process-memory-rss', () =&gt; { return process.memoryUsage().rss }, {}, PROCESS_AND_SYSTEM_METRICS_REPORTING_INTERVAL_IN_SECONDS ); // https://nodejs.org/api/process.html#process_process_memoryusage metricsRegistry.getOrCreateGauge( 'process-memory-heap-total', () =&gt; { return process.memoryUsage().heapTotal }, {}, PROCESS_AND_SYSTEM_METRICS_REPORTING_INTERVAL_IN_SECONDS ); // https://nodejs.org/api/process.html#process_process_memoryusage metricsRegistry.getOrCreateGauge( 'process-memory-heap-used', () =&gt; { return process.memoryUsage().heapUsed }, {}, PROCESS_AND_SYSTEM_METRICS_REPORTING_INTERVAL_IN_SECONDS ); // https://nodejs.org/api/process.html#process_process_memoryusage metricsRegistry.getOrCreateGauge( 'process-memory-external', () =&gt; { const mem = process.memoryUsage() as any return mem.hasOwnProperty('external') ? mem.external : 0 }, {}, PROCESS_AND_SYSTEM_METRICS_REPORTING_INTERVAL_IN_SECONDS ); // https://nodejs.org/api/process.html#process_process_uptime metricsRegistry.getOrCreateGauge( 'process-uptime-seconds', () =&gt; { return Math.floor(process.uptime()) }, {}, PROCESS_AND_SYSTEM_METRICS_REPORTING_INTERVAL_IN_SECONDS ); // Now that we have some base system and process metrics wired up, // lets wire up an express middleware that will track request count, latency statics and give us all this // information filterable by http method, response status code and URI path. /** * This middleware is a little interesting because we need to track the time elapsed before we know the status code dimension. * So we will create the Stopwatch manually rather that using the API available on the Timer object itself, see api docs for more info. * * @param metricsRegistry the self reporting metrics registry * @return {Function} Express Middleware */ const createExpressMiddleware = metricsRegistry =&gt; { return (req, res, next) =&gt; { const stopwatch = new Stopwatch(); req.on('end', () =&gt; { const customDimensions = { statusCode: `${res.statusCode}`, path: req.route ? req.route.path : '_unknown', method: req.method }; // create the timer for the request count/latency histogram const requestTimer = metricsRegistry.getOrCreateTimer( 'request', customDimensions, REQUEST_METRICS_REPORTING_INTERVAL_IN_SECONDS ); // stop the request latency counter const time = stopwatch.end(); requestTimer.update(time) }); next() } }; const app = express(); // wire up the metrics middleware app.use(createExpressMiddleware(metricsRegistry)); app.get('/hello', (req, res) =&gt; { res.send('hello world') }); app.get('/path2', (req, res) =&gt; { res.send('path2') }); app.listen(8080, () =&gt; log.info('Example app listening on port 8080!')); × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
