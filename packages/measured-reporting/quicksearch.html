<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"registries_DimensionAwareMetricsRegistry.js.html":{"id":"registries_DimensionAwareMetricsRegistry.js.html","title":"Source: registries/DimensionAwareMetricsRegistry.js","body":" Measured Modules inputValidatorsmeasured-reporting Classes DimensionAwareMetricsRegistryReporterSelfReportingMetricsRegistry Tutorials SignalFx Express Full End to End Example Global Global Source: registries/DimensionAwareMetricsRegistry.js /** * Simple registry that stores Metrics by name and dimensions. */ class DimensionAwareMetricsRegistry { constructor() { this._metrics = {}; } /** * Checks to see if a metric with the given name and dimensions is present. * * @param {string} name The metric name * @param {Dimensions} dimensions The dimensions for the metric * @returns {boolean} true if the metric with given dimensions is present */ hasMetric(name, dimensions) { const key = this._generateStorageKey(name, dimensions); return Object.prototype.hasOwnProperty.call(this._metrics, key); } /** * Retrieves a metric with a given name and dimensions is present. * * @param {string} name The metric name * @param {Dimensions} dimensions The dimensions for the metric * @returns {Metric} a wrapper object around name, dimension and {@link Metric} */ getMetric(name, dimensions) { const key = this._generateStorageKey(name, dimensions); return this._metrics[key].metricImpl; } /** * Retrieves a metric by the calculated key (name / dimension combo). * * @param {string} key The registered key for the given registered {@link MetricWrapper} * @returns {MetricWrapper} a wrapper object around name, dimension and {@link Metric} */ getMetricWrapperByKey(key) { return this._metrics[key]; } /** * Upserts a {@link Metric} in the internal storage map for a given name, dimension combo * * @param {string} name The metric name * @param {Metric} metric The {@link Metric} impl * @param {Dimensions} dimensions The dimensions for the metric * @return {string} The registry key for the metric, dimension combo */ putMetric(name, metric, dimensions) { const key = this._generateStorageKey(name, dimensions); this._metrics[key] = { name: name, metricImpl: metric, dimensions: dimensions || {} }; return key; } /** * Returns an array of all keys of metrics stored in this registry. * @return {string[]} all keys of metrics stored in this registry. */ allKeys() { return Object.keys(this._metrics); } /** * Generates a unique key off of the metric name and custom dimensions for internal use in the registry maps. * * @param {string} name The metric name * @param {Dimensions} dimensions The dimensions for the metric * @return {string} a unique key based off of the metric nae and dimensions * @private */ _generateStorageKey(name, dimensions) { let key = name; if (dimensions) { Object.keys(dimensions) .sort() .forEach(dimensionKey =&gt; { key = `${key}-${dimensions[dimensionKey]}`; }); } return key; } } module.exports = DimensionAwareMetricsRegistry; × Search results Close "},"@types_types.js.html":{"id":"@types_types.js.html","title":"Source: @types/types.js","body":" Measured Modules inputValidatorsmeasured-reporting Classes DimensionAwareMetricsRegistryReporterSelfReportingMetricsRegistry Tutorials SignalFx Express Full End to End Example Global Global Source: @types/types.js /** * A wrapper object around a {@link Metric}, {@link Dimensions} and the metric name * * @interface MetricWrapper * @typedef MetricWrapper * @type {Object} * @property {string} name The supplied name of the Metric * @property {Metric} metricImpl The {@link Metric} object * @property {Dimensions} dimensions The {@link Dimensions} for the given {@link Metric} */ /** * A Dictionary of string, string key value pairs * * @interface Dimensions * @typedef Dimensions * @type {Object.&lt;string, string&gt;} * * @example * { * path: &quot;/api/foo&quot; * method: &quot;GET&quot; * statusCode: &quot;200&quot; * } */ × Search results Close "},"validators_inputValidators.js.html":{"id":"validators_inputValidators.js.html","title":"Source: validators/inputValidators.js","body":" Measured Modules inputValidatorsmeasured-reporting Classes DimensionAwareMetricsRegistryReporterSelfReportingMetricsRegistry Tutorials SignalFx Express Full End to End Example Global Global Source: validators/inputValidators.js const Optional = require('optional-js'); const { validateMetric } = require('measured-core').metricValidators; /** * This module contains various validators to validate publicly exposed input. * * @module inputValidators */ module.exports = { /** * Validates @{link Gauge} options. * * @param {string} name The metric name * @param {function} callback The callback for the Gauge * @param {Dimensions} dimensions The optional custom dimensions * @param {number} publishingIntervalInSeconds the optional publishing interval */ validateGaugeOptions: (name, callback, dimensions, publishingIntervalInSeconds) =&gt; { module.exports.validateCommonMetricParameters(name, dimensions, publishingIntervalInSeconds); module.exports.validateNumberReturningCallback(callback); }, /** * Validates @{link Gauge} options. * * @param {string} name The metric name * @param {function} callback The callback for the CachedGauge * @param {Dimensions} dimensions The optional custom dimensions * @param {number} publishingIntervalInSeconds the optional publishing interval */ validateCachedGaugeOptions: (name, callback, dimensions, publishingIntervalInSeconds) =&gt; { module.exports.validateCommonMetricParameters(name, dimensions, publishingIntervalInSeconds); // Should we validate the promise call back, it may be expensive or produce a race condition in some use-cases. }, /** * Validates the create histogram Options. * * @param {string} name The metric name * @param {Dimensions} dimensions The optional custom dimensions * @param {number} publishingIntervalInSeconds the optional publishing interval */ validateHistogramOptions: (name, dimensions, publishingIntervalInSeconds) =&gt; { module.exports.validateCommonMetricParameters(name, dimensions, publishingIntervalInSeconds); }, /** * Validates the create counter Options. * * @param {string} name The metric name * @param {Dimensions} dimensions The optional custom dimensions * @param {number} publishingIntervalInSeconds the optional publishing interval */ validateCounterOptions: (name, dimensions, publishingIntervalInSeconds) =&gt; { module.exports.validateCommonMetricParameters(name, dimensions, publishingIntervalInSeconds); }, /** * Validates the create timer Options. * * @param {string} name The metric name * @param {Dimensions} dimensions The optional custom dimensions * @param {number} publishingIntervalInSeconds the optional publishing interval */ validateTimerOptions: (name, dimensions, publishingIntervalInSeconds) =&gt; { module.exports.validateCommonMetricParameters(name, dimensions, publishingIntervalInSeconds); }, /** * Validates the create timer Options. * * @param {string} name The metric name * @param {Metric} metric The metric instance * @param {Dimensions} dimensions The optional custom dimensions * @param {number} publishingIntervalInSeconds the optional publishing interval */ validateRegisterOptions: (name, metric, dimensions, publishingIntervalInSeconds) =&gt; { module.exports.validateMetric(metric); module.exports.validateCommonMetricParameters(name, dimensions, publishingIntervalInSeconds); }, /** * Validates the create settable gauge Options. * * @param {string} name The metric name * @param {Dimensions} dimensions The optional custom dimensions * @param {number} publishingIntervalInSeconds the optional publishing interval */ validateSettableGaugeOptions: (name, dimensions, publishingIntervalInSeconds) =&gt; { module.exports.validateCommonMetricParameters(name, dimensions, publishingIntervalInSeconds); }, /** * Validates the options that are common amoung all create metric methods * * @param {string} name The metric name * @param {Dimensions} dimensions The optional custom dimensions * @param {number} publishingIntervalInSeconds the optional publishing interval */ validateCommonMetricParameters: (name, dimensions, publishingIntervalInSeconds) =&gt; { module.exports.validateMetricName(name); module.exports.validateOptionalDimensions(dimensions); module.exports.validateOptionalPublishingInterval(publishingIntervalInSeconds); }, /** * Validates the metric name. * * @param name The metric name. */ validateMetricName: name =&gt; { const type = typeof name; if (type !== 'string') { throw new TypeError(`options.name is a required option and must be of type string, actual type: ${type}`); } }, /** * Validates that a metric implements the metric interface. * * @function * @name validateMetric * @param {Metric} metric The object that is supposed to be a metric. */ validateMetric, /** * Validates the provided callback. * * @param callback The provided callback for a gauge. */ validateNumberReturningCallback: callback =&gt; { const type = typeof callback; if (type !== 'function') { throw new TypeError(`options.callback is a required option and must be function, actual type: ${type}`); } const callbackType = typeof callback(); if (callbackType !== 'number') { throw new TypeError(`options.callback must return a number, actual return type: ${callbackType}`); } }, /** * Validates a set of optional dimensions * @param dimensionsOptional */ validateOptionalDimensions: dimensionsOptional =&gt; { Optional.ofNullable(dimensionsOptional).ifPresent(dimensions =&gt; { const type = typeof dimensions; if (type !== 'object') { throw new TypeError(`options.dimensions should be an object, actual type: ${type}`); } if (Array.isArray(dimensions)) { throw new TypeError('dimensions where detected to be an array, expected Object&lt;string, string&gt;'); } Object.keys(dimensions).forEach(key =&gt; { const valueType = typeof dimensions[key]; if (valueType !== 'string') { throw new TypeError(`options.dimensions.${key} should be of type string, actual type: ${type}`); } }); }); }, /** * Validates that an optional logger instance at least has the methods we expect. * @param loggerOptional */ validateOptionalLogger: loggerOptional =&gt; { Optional.ofNullable(loggerOptional).ifPresent(logger =&gt; { if ( typeof logger.debug !== 'function' || typeof logger.info !== 'function' || typeof logger.warn !== 'function' || typeof logger.error !== 'function' ) { throw new TypeError( 'The logger that was passed in does not support all required ' + 'logging methods, expected object to have functions debug, info, warn, and error with ' + 'method signatures (...msgs) =&gt; {}' ); } }); }, /** * Validates the optional publishing interval. * * @param publishingIntervalInSecondsOptional The optional publishing interval. */ validateOptionalPublishingInterval: publishingIntervalInSecondsOptional =&gt; { Optional.ofNullable(publishingIntervalInSecondsOptional).ifPresent(publishingIntervalInSeconds =&gt; { const type = typeof publishingIntervalInSeconds; if (type !== 'number') { throw new TypeError(`options.publishingIntervalInSeconds must be of type number, actual type: ${type}`); } }); }, /** * Validates optional params for a Reporter * @param {ReporterOptions} options The optional params */ validateReporterParameters: options =&gt; { if (options) { module.exports.validateOptionalDimensions(options.defaultDimensions); module.exports.validateOptionalLogger(options.logger); } }, /** * Validates that a valid Reporter object has been supplied * * @param {Reporter} reporter */ validateReporterInstance: reporter =&gt; { if (!reporter) { throw new TypeError('The reporter was undefined, when it was required'); } if (typeof reporter.setRegistry !== 'function') { throw new TypeError( 'A reporter must implement setRegistry(registry), see the abstract Reporter class in the docs.' ); } if (typeof reporter.reportMetricOnInterval !== 'function') { throw new TypeError( 'A reporter must implement reportMetricOnInterval(metricKey, intervalInSeconds), see the abstract Reporter class in the docs.' ); } }, /** * Validates the input parameters for a {@link SelfReportingMetricsRegistry} * @param {Reporter} reporter * @param {SelfReportingMetricsRegistryOptions} [options] */ validateSelfReportingMetricsRegistryParameters: (reporter, options) =&gt; { module.exports.validateReporterInstance(reporter); if (options) { module.exports.validateOptionalLogger(options.logger); } } }; × Search results Close "},"index.js.html":{"id":"index.js.html","title":"Source: index.js","body":" Measured Modules inputValidatorsmeasured-reporting Classes DimensionAwareMetricsRegistryReporterSelfReportingMetricsRegistry Tutorials SignalFx Express Full End to End Example Global Global Source: index.js const SelfReportingMetricsRegistry = require('./registries/SelfReportingMetricsRegistry'); const Reporter = require('./reporters/Reporter'); const inputValidators = require('./validators/inputValidators'); /** * The main measured module that is referenced when require('measured-reporting') is used. * @module measured-reporting */ module.exports = { /** * @type {SelfReportingMetricsRegistry} */ SelfReportingMetricsRegistry, /** * @type {Reporter} */ Reporter, /** * @type {inputValidators} */ inputValidators }; × Search results Close "},"reporters_Reporter.js.html":{"id":"reporters_Reporter.js.html","title":"Source: reporters/Reporter.js","body":" Measured Modules inputValidatorsmeasured-reporting Classes DimensionAwareMetricsRegistryReporterSelfReportingMetricsRegistry Tutorials SignalFx Express Full End to End Example Global Global Source: reporters/Reporter.js const bunyan = require('bunyan'); const Optional = require('optional-js'); const { validateReporterParameters } = require('../validators/inputValidators'); const DEFAULT_REPORTING_INTERVAL_IN_SECONDS = 10; /** * The abstract reporter that specific implementations can extend to create a Self Reporting Metrics Registry Reporter. * * {@link SelfReportingMetricsRegistry} * @abstract */ class Reporter { /** * @param {ReporterOptions} [options] The optional params to supply when creating a reporter. */ constructor(options) { if (this.constructor === Reporter) { throw new TypeError(&quot;Can't instantiate abstract class!&quot;); } options = options || {}; validateReporterParameters(options); /** * Map of intervals to metric keys, this will be used to look up what metrics should be reported at a given interval. * * @type {Object.&lt;number, Set&lt;string&gt;&gt;} * @private */ this._intervalToMetric = {}; this._intervals = []; /** * Map of default dimensions, that should be sent with every metric. * * @type {Dimensions} * @protected */ this._defaultDimensions = options.defaultDimensions || {}; /** * Loggers to use, defaults to a new bunyan logger if nothing is supplied in options * @type {Logger} * @protected */ this._log = options.logger || bunyan.createLogger({ name: 'Reporter', level: options.logLevel || 'info' }); /** * The default reporting interval, a number in seconds. * If not overridden via the {@see ReporterOptions}, defaults to 10 seconds. * * @type {number} * @protected */ this._defaultReportingIntervalInSeconds = options.defaultReportingIntervalInSeconds || DEFAULT_REPORTING_INTERVAL_IN_SECONDS; } /** * Sets the registry, this must be called before reportMetricOnInterval. * * @param {DimensionAwareMetricsRegistry} registry */ setRegistry(registry) { this._registry = registry; } /** * Informs the reporter to report a metric on a given interval in seconds. * * @param {string} metricKey The metric key for the metric in the metric registry. * @param {number} intervalInSeconds The interval in seconds to report the metric on. */ reportMetricOnInterval(metricKey, intervalInSeconds) { intervalInSeconds = intervalInSeconds || this._defaultReportingIntervalInSeconds; if (!this._registry) { throw new Error( 'You must call setRegistry(registry) before telling a Reporter to report a metric on an interval.' ); } if (Object.prototype.hasOwnProperty.call(this._intervalToMetric, intervalInSeconds)) { this._intervalToMetric[intervalInSeconds].add(metricKey); } else { this._intervalToMetric[intervalInSeconds] = new Set([metricKey]); this._reportMetricsWithInterval(intervalInSeconds); this._createIntervalCallback(intervalInSeconds); } } /** * Creates the timed callback loop for the given interval. * * @param {number} intervalInSeconds the interval in seconds for the timeout callback * @private */ _createIntervalCallback(intervalInSeconds) { this._log.debug(`_createIntervalCallback() called with intervalInSeconds: ${intervalInSeconds}`); this._intervals.push( setInterval(() =&gt; { this._reportMetricsWithInterval(intervalInSeconds); }, intervalInSeconds * 1000) ); } /** * Gathers all the metrics that have been registered to report on the given interval. * * @param {number} interval The interval to look up what metrics to report * @private */ _reportMetricsWithInterval(interval) { this._log.debug(`_reportMetricsWithInterval() called with intervalInSeconds: ${interval}`); try { Optional.of(this._intervalToMetric[interval]).ifPresent(metrics =&gt; { const metricsToSend = []; metrics.forEach(metricKey =&gt; { metricsToSend.push(this._registry.getMetricWrapperByKey(metricKey)); }); this._reportMetrics(metricsToSend); }); } catch (error) { this._log.error('Failed to send metrics to signal fx', error); } } /** * This method gets called with an array of {@link MetricWrapper} on an interval, when metrics should be reported. * * This is the main method that needs to get implemented when created an aggregator specific reporter. * * @param {MetricWrapper[]} metrics The array of metrics to report. * @protected * @abstract */ _reportMetrics(metrics) { throw new TypeError('Abstract method _reportMetrics(metrics) must be implemented in implementation class'); } /** * * @param {MetricWrapper} metric The Wrapped Metric Object. * @return {Dimensions} The left merged default dimensions with the metric specific dimensions * @protected */ _getDimensions(metric) { return Object.assign({}, this._defaultDimensions, metric.dimensions); } /** * Clears the intervals that are running to report metrics at an interval, and resets the state. */ shutdown() { this._intervals.forEach(interval =&gt; clearInterval(interval)); this._intervals = []; this._intervalToMetric = {}; } } /** * Options for creating a {@link Reporter} * @interface ReporterOptions * @typedef ReporterOptions * @type {Object} * @property {Dimensions} defaultDimensions A dictionary of dimensions to include with every metric reported * @property {Logger} logger The logger to use, if not supplied a new Buynan logger will be created * @property {string} logLevel The log level to use with the created Bunyan logger if you didn't supply your own logger. * @property {number} defaultReportingIntervalInSeconds The default reporting interval to use if non is supplied when registering a metric, defaults to 10 seconds. */ module.exports = Reporter; × Search results Close "},"registries_SelfReportingMetricsRegistry.js.html":{"id":"registries_SelfReportingMetricsRegistry.js.html","title":"Source: registries/SelfReportingMetricsRegistry.js","body":" Measured Modules inputValidatorsmeasured-reporting Classes DimensionAwareMetricsRegistryReporterSelfReportingMetricsRegistry Tutorials SignalFx Express Full End to End Example Global Global Source: registries/SelfReportingMetricsRegistry.js const bunyan = require('bunyan'); const { CachedGauge, SettableGauge, Gauge, Timer, Counter, Meter, Histogram } = require('measured-core'); const DimensionAwareMetricsRegistry = require('./DimensionAwareMetricsRegistry'); const { validateSelfReportingMetricsRegistryParameters, validateRegisterOptions, validateGaugeOptions, validateCounterOptions, validateHistogramOptions, validateTimerOptions, validateSettableGaugeOptions, validateCachedGaugeOptions } = require('../validators/inputValidators'); /** * A dimensional aware self-reporting metrics registry */ class SelfReportingMetricsRegistry { /** * @param {Reporter} reporter The Metrics Reporter * @param {SelfReportingMetricsRegistryOptions} [options] Configurable options for the Self Reporting Metrics Registry */ constructor(reporter, options) { options = options || {}; validateSelfReportingMetricsRegistryParameters(reporter, options); /** * @type {Reporter} * @protected */ this._reporter = reporter; /** * @type {DimensionAwareMetricsRegistry} * @protected */ this._registry = options.registry || new DimensionAwareMetricsRegistry(); this._reporter.setRegistry(this._registry); /** * Loggers to use, defaults to a new bunyan logger if nothing is supplied in options * @type {Logger} * @protected */ this._log = options.logger || bunyan.createLogger({ name: 'SelfReportingMetricsRegistry', level: options.logLevel || 'info' }); } /** * Registers a manually created Metric. * * @param {string} name The Metric name * @param {Metric} metric The {@link Metric} to register * @param {Dimensions} [dimensions] any custom {@link Dimensions} for the Metric * @param {number} [publishingIntervalInSeconds] a optional custom publishing interval * @example * const settableGauge = new SettableGauge(5); * // register the gauge and have it report to every 10 seconds * registry.register('my-gauge', settableGauge, {}, 10); * interval(() =&gt; { * // such as cpu % used * determineAValueThatCannotBeSync((value) =&gt; { * settableGauge.update(value); * }) * }, 10000) */ register(name, metric, dimensions, publishingIntervalInSeconds) { validateRegisterOptions(name, metric, dimensions, publishingIntervalInSeconds); if (this._registry.hasMetric(name, dimensions)) { throw new Error( `Metric with name: ${name} and dimensions: ${JSON.stringify(dimensions)} has already been registered` ); } else { const key = this._registry.putMetric(name, metric, dimensions); this._reporter.reportMetricOnInterval(key, publishingIntervalInSeconds); } return metric; } /** * Creates a {@link Gauge} or gets the existing Gauge for a given name and dimension combo * * @param {string} name The Metric name * @param {function} callback The callback that will return a value to report to signal fx * @param {Dimensions} [dimensions] any custom {@link Dimensions} for the Metric * @param {number} [publishingIntervalInSeconds] a optional custom publishing interval * @return {Gauge} * @example * // https://nodejs.org/api/process.html#process_process_memoryusage * // Report heap total and heap used at the default interval * registry.getOrCreateGauge( * 'process-memory-heap-total', * () =&gt; { * return process.memoryUsage().heapTotal * } * ); * registry.getOrCreateGauge( * 'process-memory-heap-used', * () =&gt; { * return process.memoryUsage().heapUsed * } * ) */ getOrCreateGauge(name, callback, dimensions, publishingIntervalInSeconds) { validateGaugeOptions(name, callback, dimensions, publishingIntervalInSeconds); let gauge; if (this._registry.hasMetric(name, dimensions)) { gauge = this._registry.getMetric(name, dimensions); } else { gauge = new Gauge(callback); const key = this._registry.putMetric(name, gauge, dimensions); this._reporter.reportMetricOnInterval(key, publishingIntervalInSeconds); } return gauge; } /** * Creates a {@link Histogram} or gets the existing Histogram for a given name and dimension combo * * @param {string} name The Metric name * @param {Dimensions} dimensions any custom {@link Dimensions} for the Metric * @param {number} publishingIntervalInSeconds a optional custom publishing interval * @return {Histogram} */ getOrCreateHistogram(name, dimensions, publishingIntervalInSeconds) { validateHistogramOptions(name, dimensions, publishingIntervalInSeconds); let histogram; if (this._registry.hasMetric(name, dimensions)) { histogram = this._registry.getMetric(name, dimensions); } else { histogram = new Histogram(); const key = this._registry.putMetric(name, histogram, dimensions); this._reporter.reportMetricOnInterval(key, publishingIntervalInSeconds); } return histogram; } /** * Creates a {@link Meter} or gets the existing Meter for a given name and dimension combo * * @param {string} name The Metric name * @param {Dimensions} dimensions any custom {@link Dimensions} for the Metric * @param {number} publishingIntervalInSeconds a optional custom publishing interval * @return {Meter} */ getOrCreateMeter(name, dimensions, publishingIntervalInSeconds) { // todo validate options let meter; if (this._registry.hasMetric(name, dimensions)) { meter = this._registry.getMetric(name, dimensions); } else { meter = new Meter(); const key = this._registry.putMetric(name, meter, dimensions); this._reporter.reportMetricOnInterval(key, publishingIntervalInSeconds); } return meter; } /** * Creates a {@link Counter} or gets the existing Counter for a given name and dimension combo * * @param {string} name The Metric name * @param {Dimensions} dimensions any custom {@link Dimensions} for the Metric * @param {number} publishingIntervalInSeconds a optional custom publishing interval * @return {Counter} */ getOrCreateCounter(name, dimensions, publishingIntervalInSeconds) { validateCounterOptions(name, dimensions, publishingIntervalInSeconds); let counter; if (this._registry.hasMetric(name, dimensions)) { counter = this._registry.getMetric(name, dimensions); } else { counter = new Counter(); const key = this._registry.putMetric(name, counter, dimensions); this._reporter.reportMetricOnInterval(key, publishingIntervalInSeconds); } return counter; } /** * Creates a {@link Timer} or gets the existing Timer for a given name and dimension combo. * * @param {string} name The Metric name * @param {Dimensions} dimensions any custom {@link Dimensions} for the Metric * @param {number} publishingIntervalInSeconds a optional custom publishing interval * @return {Timer} */ getOrCreateTimer(name, dimensions, publishingIntervalInSeconds) { validateTimerOptions(name, dimensions, publishingIntervalInSeconds); let timer; if (this._registry.hasMetric(name, dimensions)) { timer = this._registry.getMetric(name, dimensions); } else { timer = new Timer(); const key = this._registry.putMetric(name, timer, dimensions); this._reporter.reportMetricOnInterval(key, publishingIntervalInSeconds); } return timer; } /** * Creates a {@link SettableGauge} or gets the existing SettableGauge for a given name and dimension combo. * * @param {string} name The Metric name * @param {Dimensions} dimensions any custom {@link Dimensions} for the Metric * @param {number} publishingIntervalInSeconds a optional custom publishing interval * @return {SettableGauge} */ getOrCreateSettableGauge(name, dimensions, publishingIntervalInSeconds) { validateSettableGaugeOptions(name, dimensions, publishingIntervalInSeconds); let settableGauge; if (this._registry.hasMetric(name, dimensions)) { settableGauge = this._registry.getMetric(name, dimensions); } else { settableGauge = new SettableGauge(); const key = this._registry.putMetric(name, settableGauge, dimensions); this._reporter.reportMetricOnInterval(key, publishingIntervalInSeconds); } return settableGauge; } /** * Creates a {@link CachedGauge} or gets the existing CachedGauge for a given name and dimension combo. * * @param {string} name The Metric name. * @param {function} valueProducingPromiseCallback. * @param {number} cachedGaugeUpdateIntervalInSeconds. * @param {Dimensions} dimensions any custom {@link Dimensions} for the Metric. * @param {number} publishingIntervalInSeconds a optional custom publishing interval. * @return {CachedGauge} */ getOrCreateCachedGauge(name, valueProducingPromiseCallback, cachedGaugeUpdateIntervalInSeconds, dimensions, publishingIntervalInSeconds) { validateCachedGaugeOptions(name, valueProducingPromiseCallback, dimensions, publishingIntervalInSeconds); let cachedGauge; if (this._registry.hasMetric(name, dimensions)) { cachedGauge = this._registry.getMetric(name, dimensions); } else { cachedGauge = new CachedGauge(valueProducingPromiseCallback, cachedGaugeUpdateIntervalInSeconds); const key = this._registry.putMetric(name, cachedGauge, dimensions); this._reporter.reportMetricOnInterval(key, publishingIntervalInSeconds); } return cachedGauge; } /** * Calls end on all metrics in the registry that support end() and calls end on the reporter */ shutdown() { // shutdown the reporter this._reporter.shutdown(); // shutdown any metrics that have an end method this._registry.allKeys().forEach(key =&gt; { const metricWrapper = this._registry.getMetricWrapperByKey(key); if (metricWrapper.metricImpl.end) { metricWrapper.metricImpl.end(); } }); } } module.exports = SelfReportingMetricsRegistry; /** * Configurable options for the Self Reporting Metrics Registry * * @interface SelfReportingMetricsRegistryOptions * @typedef SelfReportingMetricsRegistryOptions * @property {Logger} logger the Logger to use * @property {string} logLevel The Log level to use if defaulting to included logger * @property {DimensionAwareMetricsRegistry} registry The registry to use, defaults to new DimensionAwareMetricsRegistry */ × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" Measured Modules inputValidatorsmeasured-reporting Classes DimensionAwareMetricsRegistryReporterSelfReportingMetricsRegistry Tutorials SignalFx Express Full End to End Example Global Global Global Type Definitions Dimensions A Dictionary of string, string key value pairs Type: Object.&lt;string, string&gt; Source: @types/types.js, line 12 Example { path: &quot;/api/foo&quot; method: &quot;GET&quot; statusCode: &quot;200&quot; } MetricWrapper A wrapper object around a Metric, Dimensions and the metric name Type: Object Properties: Name Type Description name string The supplied name of the Metric metricImpl Metric The Metric object dimensions Dimensions The Dimensions for the given Metric Source: @types/types.js, line 1 ReporterOptions Options for creating a Reporter Type: Object Properties: Name Type Description defaultDimensions Dimensions A dictionary of dimensions to include with every metric reported logger Logger The logger to use, if not supplied a new Buynan logger will be created logLevel string The log level to use with the created Bunyan logger if you didn't supply your own logger. defaultReportingIntervalInSeconds number The default reporting interval to use if non is supplied when registering a metric, defaults to 10 seconds. Source: reporters/Reporter.js, line 162 SelfReportingMetricsRegistryOptions Configurable options for the Self Reporting Metrics Registry Properties: Name Type Description logger Logger the Logger to use logLevel string The Log level to use if defaulting to included logger registry DimensionAwareMetricsRegistry The registry to use, defaults to new DimensionAwareMetricsRegistry Source: registries/SelfReportingMetricsRegistry.js, line 276 × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" Measured Modules inputValidatorsmeasured-reporting Classes DimensionAwareMetricsRegistryReporterSelfReportingMetricsRegistry Tutorials SignalFx Express Full End to End Example Global Global Modules Classes DimensionAwareMetricsRegistry Reporter SelfReportingMetricsRegistry × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Measured Modules inputValidatorsmeasured-reporting Classes DimensionAwareMetricsRegistryReporterSelfReportingMetricsRegistry Tutorials SignalFx Express Full End to End Example Global Global Classes Classes DimensionAwareMetricsRegistry Reporter SelfReportingMetricsRegistry × Search results Close "},"tutorials.list.html":{"id":"tutorials.list.html","title":"Tutorials","body":" Measured Modules inputValidatorsmeasured-reporting Classes DimensionAwareMetricsRegistryReporterSelfReportingMetricsRegistry Tutorials SignalFx Express Full End to End Example Global Global Tutorials Classes DimensionAwareMetricsRegistry Reporter SelfReportingMetricsRegistry × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" Measured Modules inputValidatorsmeasured-reporting Classes DimensionAwareMetricsRegistryReporterSelfReportingMetricsRegistry Tutorials SignalFx Express Full End to End Example Global Global Measured ReportingThe registry and reporting library that has the classes needed to create a dimension aware, self reporting metrics registry. Installnpm install measured-reportingWhat is in this packageSelf Reporting Metrics RegistryA dimensional aware self-reporting metrics registry, just supply this class with a reporter implementation at instantiation and this is all you need to instrument application level metrics in your app. Reporter Abstract ClassThe base class for reporter implementations. This class is extended and the _reportMetrics(metrics) method gets overridden to create an data aggregator specific reporter. See the SignalFx Reporter for an example implementation. What are dimensions?As described by Signal Fx: A dimension is a key/value pair that, along with the metric name, is part of the identity of a time series.You can filter and aggregate time series by those dimensions across SignalFx. DataDog has a nice blog post about how they are used in their aggregator api. Graphite also supports the concept via tags. × Search results Close "},"DimensionAwareMetricsRegistry.html":{"id":"DimensionAwareMetricsRegistry.html","title":"Class: DimensionAwareMetricsRegistry","body":" Measured Modules inputValidatorsmeasured-reporting Classes DimensionAwareMetricsRegistryReporterSelfReportingMetricsRegistry Tutorials SignalFx Express Full End to End Example Global Global Class: DimensionAwareMetricsRegistry DimensionAwareMetricsRegistry Simple registry that stores Metrics by name and dimensions. new DimensionAwareMetricsRegistry() Source: registries/DimensionAwareMetricsRegistry.js, line 4 Methods allKeys() Returns an array of all keys of metrics stored in this registry. Source: registries/DimensionAwareMetricsRegistry.js, line 65 Returns: all keys of metrics stored in this registry. Type Array.&lt;string&gt; getMetric(name, dimensions) Retrieves a metric with a given name and dimensions is present. Parameters: Name Type Description name string The metric name dimensions Dimensions The dimensions for the metric Source: registries/DimensionAwareMetricsRegistry.js, line 28 Returns: a wrapper object around name, dimension and Metric Type Metric getMetricWrapperByKey(key) Retrieves a metric by the calculated key (name / dimension combo). Parameters: Name Type Description key string The registered key for the given registered MetricWrapper Source: registries/DimensionAwareMetricsRegistry.js, line 39 Returns: a wrapper object around name, dimension and Metric Type MetricWrapper hasMetric(name, dimensions) Checks to see if a metric with the given name and dimensions is present. Parameters: Name Type Description name string The metric name dimensions Dimensions The dimensions for the metric Source: registries/DimensionAwareMetricsRegistry.js, line 16 Returns: true if the metric with given dimensions is present Type boolean putMetric(name, metric, dimensions) Upserts a Metric in the internal storage map for a given name, dimension combo Parameters: Name Type Description name string The metric name metric Metric The Metric impl dimensions Dimensions The dimensions for the metric Source: registries/DimensionAwareMetricsRegistry.js, line 51 Returns: The registry key for the metric, dimension combo Type string × Search results Close "},"module-inputValidators.html":{"id":"module-inputValidators.html","title":"Module: inputValidators","body":" Measured Modules inputValidatorsmeasured-reporting Classes DimensionAwareMetricsRegistryReporterSelfReportingMetricsRegistry Tutorials SignalFx Express Full End to End Example Global Global Module: inputValidators This module contains various validators to validate publicly exposed input. Source: validators/inputValidators.js, line 4 Methods &lt;static&gt; validateCachedGaugeOptions(name, callback, dimensions, publishingIntervalInSeconds) Validates @{link Gauge} options. Parameters: Name Type Description name string The metric name callback function The callback for the CachedGauge dimensions Dimensions The optional custom dimensions publishingIntervalInSeconds number the optional publishing interval Source: validators/inputValidators.js, line 31 &lt;static&gt; validateCommonMetricParameters(name, dimensions, publishingIntervalInSeconds) Validates the options that are common amoung all create metric methods Parameters: Name Type Description name string The metric name dimensions Dimensions The optional custom dimensions publishingIntervalInSeconds number the optional publishing interval Source: validators/inputValidators.js, line 100 &lt;static&gt; validateCounterOptions(name, dimensions, publishingIntervalInSeconds) Validates the create counter Options. Parameters: Name Type Description name string The metric name dimensions Dimensions The optional custom dimensions publishingIntervalInSeconds number the optional publishing interval Source: validators/inputValidators.js, line 54 &lt;static&gt; validateGaugeOptions(name, callback, dimensions, publishingIntervalInSeconds) Validates @{link Gauge} options. Parameters: Name Type Description name string The metric name callback function The callback for the Gauge dimensions Dimensions The optional custom dimensions publishingIntervalInSeconds number the optional publishing interval Source: validators/inputValidators.js, line 18 &lt;static&gt; validateHistogramOptions(name, dimensions, publishingIntervalInSeconds) Validates the create histogram Options. Parameters: Name Type Description name string The metric name dimensions Dimensions The optional custom dimensions publishingIntervalInSeconds number the optional publishing interval Source: validators/inputValidators.js, line 43 &lt;static&gt; validateMetricName(name) Validates the metric name. Parameters: Name Type Description name The metric name. Source: validators/inputValidators.js, line 111 &lt;static&gt; validateNumberReturningCallback(callback) Validates the provided callback. Parameters: Name Type Description callback The provided callback for a gauge. Source: validators/inputValidators.js, line 132 &lt;static&gt; validateOptionalDimensions(dimensionsOptional) Validates a set of optional dimensions Parameters: Name Type Description dimensionsOptional Source: validators/inputValidators.js, line 148 &lt;static&gt; validateOptionalLogger(loggerOptional) Validates that an optional logger instance at least has the methods we expect. Parameters: Name Type Description loggerOptional Source: validators/inputValidators.js, line 172 &lt;static&gt; validateOptionalPublishingInterval(publishingIntervalInSecondsOptional) Validates the optional publishing interval. Parameters: Name Type Description publishingIntervalInSecondsOptional The optional publishing interval. Source: validators/inputValidators.js, line 194 &lt;static&gt; validateRegisterOptions(name, metric, dimensions, publishingIntervalInSeconds) Validates the create timer Options. Parameters: Name Type Description name string The metric name metric Metric The metric instance dimensions Dimensions The optional custom dimensions publishingIntervalInSeconds number the optional publishing interval Source: validators/inputValidators.js, line 77 &lt;static&gt; validateReporterInstance(reporter) Validates that a valid Reporter object has been supplied Parameters: Name Type Description reporter Reporter Source: validators/inputValidators.js, line 219 &lt;static&gt; validateReporterParameters(options) Validates optional params for a Reporter Parameters: Name Type Description options ReporterOptions The optional params Source: validators/inputValidators.js, line 207 &lt;static&gt; validateSelfReportingMetricsRegistryParameters(reporter [, options]) Validates the input parameters for a SelfReportingMetricsRegistry Parameters: Name Type Argument Description reporter Reporter options SelfReportingMetricsRegistryOptions &lt;optional&gt; Source: validators/inputValidators.js, line 240 &lt;static&gt; validateSettableGaugeOptions(name, dimensions, publishingIntervalInSeconds) Validates the create settable gauge Options. Parameters: Name Type Description name string The metric name dimensions Dimensions The optional custom dimensions publishingIntervalInSeconds number the optional publishing interval Source: validators/inputValidators.js, line 89 &lt;static&gt; validateTimerOptions(name, dimensions, publishingIntervalInSeconds) Validates the create timer Options. Parameters: Name Type Description name string The metric name dimensions Dimensions The optional custom dimensions publishingIntervalInSeconds number the optional publishing interval Source: validators/inputValidators.js, line 65 &lt;inner&gt; validateMetric(metric) Validates that a metric implements the metric interface. Parameters: Name Type Description metric Metric The object that is supposed to be a metric. Source: validators/inputValidators.js, line 118 × Search results Close "},"module-measured-reporting.html":{"id":"module-measured-reporting.html","title":"Module: measured-reporting","body":" Measured Modules inputValidatorsmeasured-reporting Classes DimensionAwareMetricsRegistryReporterSelfReportingMetricsRegistry Tutorials SignalFx Express Full End to End Example Global Global Module: measured-reporting The main measured module that is referenced when require('measured-reporting') is used. Source: index.js, line 5 Members &lt;static&gt; inputValidators :inputValidators Type: inputValidators Source: index.js, line 21 &lt;static&gt; Reporter :Reporter Type: Reporter Source: index.js, line 17 &lt;static&gt; SelfReportingMetricsRegistry :SelfReportingMetricsRegistry Type: SelfReportingMetricsRegistry Source: index.js, line 13 × Search results Close "},"Reporter.html":{"id":"Reporter.html","title":"Class: Reporter","body":" Measured Modules inputValidatorsmeasured-reporting Classes DimensionAwareMetricsRegistryReporterSelfReportingMetricsRegistry Tutorials SignalFx Express Full End to End Example Global Global Class: Reporter Reporter The abstract reporter that specific implementations can extend to create a Self Reporting Metrics Registry Reporter. SelfReportingMetricsRegistry &lt;abstract&gt; new Reporter( [options]) Parameters: Name Type Argument Description options ReporterOptions &lt;optional&gt; The optional params to supply when creating a reporter. Source: reporters/Reporter.js, line 13 Members &lt;protected&gt; _defaultDimensions :Dimensions Map of default dimensions, that should be sent with every metric. Type: Dimensions Source: reporters/Reporter.js, line 40 &lt;protected&gt; _defaultReportingIntervalInSeconds :number The default reporting interval, a number in seconds.If not overridden via the {@see ReporterOptions}, defaults to 10 seconds. Type: number Source: reporters/Reporter.js, line 56 &lt;protected&gt; _log :Logger Loggers to use, defaults to a new bunyan logger if nothing is supplied in options Type: Logger Source: reporters/Reporter.js, line 47 Methods &lt;protected&gt; _getDimensions(metric) Parameters: Name Type Description metric MetricWrapper The Wrapped Metric Object. Source: reporters/Reporter.js, line 148 Returns: The left merged default dimensions with the metric specific dimensions Type Dimensions &lt;abstract, protected&gt; _reportMetrics(metrics) This method gets called with an array of MetricWrapper on an interval, when metrics should be reported. This is the main method that needs to get implemented when created an aggregator specific reporter. Parameters: Name Type Description metrics Array.&lt;MetricWrapper&gt; The array of metrics to report. Source: reporters/Reporter.js, line 138 reportMetricOnInterval(metricKey, intervalInSeconds) Informs the reporter to report a metric on a given interval in seconds. Parameters: Name Type Description metricKey string The metric key for the metric in the metric registry. intervalInSeconds number The interval in seconds to report the metric on. Source: reporters/Reporter.js, line 75 setRegistry(registry) Sets the registry, this must be called before reportMetricOnInterval. Parameters: Name Type Description registry DimensionAwareMetricsRegistry Source: reporters/Reporter.js, line 65 shutdown() Clears the intervals that are running to report metrics at an interval, and resets the state. Source: reporters/Reporter.js, line 155 × Search results Close "},"SelfReportingMetricsRegistry.html":{"id":"SelfReportingMetricsRegistry.html","title":"Class: SelfReportingMetricsRegistry","body":" Measured Modules inputValidatorsmeasured-reporting Classes DimensionAwareMetricsRegistryReporterSelfReportingMetricsRegistry Tutorials SignalFx Express Full End to End Example Global Global Class: SelfReportingMetricsRegistry SelfReportingMetricsRegistry A dimensional aware self-reporting metrics registry new SelfReportingMetricsRegistry(reporter [, options]) Parameters: Name Type Argument Description reporter Reporter The Metrics Reporter options SelfReportingMetricsRegistryOptions &lt;optional&gt; Configurable options for the Self Reporting Metrics Registry Source: registries/SelfReportingMetricsRegistry.js, line 18 Members &lt;protected&gt; _log :Logger Loggers to use, defaults to a new bunyan logger if nothing is supplied in options Type: Logger Source: registries/SelfReportingMetricsRegistry.js, line 45 &lt;protected&gt; _registry :DimensionAwareMetricsRegistry Type: DimensionAwareMetricsRegistry Source: registries/SelfReportingMetricsRegistry.js, line 37 &lt;protected&gt; _reporter :Reporter Type: Reporter Source: registries/SelfReportingMetricsRegistry.js, line 31 Methods getOrCreateCachedGauge(name, dimensions, publishingIntervalInSeconds) Creates a CachedGauge or gets the existing CachedGauge for a given name and dimension combo. Parameters: Name Type Description name string The Metric name. valueProducingPromiseCallback. function cachedGaugeUpdateIntervalInSeconds. number dimensions Dimensions any custom Dimensions for the Metric. publishingIntervalInSeconds number a optional custom publishing interval. Source: registries/SelfReportingMetricsRegistry.js, line 243 Returns: Type CachedGauge getOrCreateCounter(name, dimensions, publishingIntervalInSeconds) Creates a Counter or gets the existing Counter for a given name and dimension combo Parameters: Name Type Description name string The Metric name dimensions Dimensions any custom Dimensions for the Metric publishingIntervalInSeconds number a optional custom publishing interval Source: registries/SelfReportingMetricsRegistry.js, line 172 Returns: Type Counter getOrCreateGauge(name, callback [, dimensions] [, publishingIntervalInSeconds]) Creates a Gauge or gets the existing Gauge for a given name and dimension combo Parameters: Name Type Argument Description name string The Metric name callback function The callback that will return a value to report to signal fx dimensions Dimensions &lt;optional&gt; any custom Dimensions for the Metric publishingIntervalInSeconds number &lt;optional&gt; a optional custom publishing interval Source: registries/SelfReportingMetricsRegistry.js, line 106 Returns: Type Gauge Example // https://nodejs.org/api/process.html#process_process_memoryusage // Report heap total and heap used at the default interval registry.getOrCreateGauge( 'process-memory-heap-total', () =&gt; { return process.memoryUsage().heapTotal } ); registry.getOrCreateGauge( 'process-memory-heap-used', () =&gt; { return process.memoryUsage().heapUsed } ) getOrCreateHistogram(name, dimensions, publishingIntervalInSeconds) Creates a Histogram or gets the existing Histogram for a given name and dimension combo Parameters: Name Type Description name string The Metric name dimensions Dimensions any custom Dimensions for the Metric publishingIntervalInSeconds number a optional custom publishing interval Source: registries/SelfReportingMetricsRegistry.js, line 127 Returns: Type Histogram getOrCreateMeter(name, dimensions, publishingIntervalInSeconds) Creates a Meter or gets the existing Meter for a given name and dimension combo Parameters: Name Type Description name string The Metric name dimensions Dimensions any custom Dimensions for the Metric publishingIntervalInSeconds number a optional custom publishing interval Source: registries/SelfReportingMetricsRegistry.js, line 150 Returns: Type Meter getOrCreateSettableGauge(name, dimensions, publishingIntervalInSeconds) Creates a SettableGauge or gets the existing SettableGauge for a given name and dimension combo. Parameters: Name Type Description name string The Metric name dimensions Dimensions any custom Dimensions for the Metric publishingIntervalInSeconds number a optional custom publishing interval Source: registries/SelfReportingMetricsRegistry.js, line 218 Returns: Type SettableGauge getOrCreateTimer(name, dimensions, publishingIntervalInSeconds) Creates a Timer or gets the existing Timer for a given name and dimension combo. Parameters: Name Type Description name string The Metric name dimensions Dimensions any custom Dimensions for the Metric publishingIntervalInSeconds number a optional custom publishing interval Source: registries/SelfReportingMetricsRegistry.js, line 195 Returns: Type Timer register(name, metric [, dimensions] [, publishingIntervalInSeconds]) Registers a manually created Metric. Parameters: Name Type Argument Description name string The Metric name metric Metric The Metric to register dimensions Dimensions &lt;optional&gt; any custom Dimensions for the Metric publishingIntervalInSeconds number &lt;optional&gt; a optional custom publishing interval Source: registries/SelfReportingMetricsRegistry.js, line 68 Example const settableGauge = new SettableGauge(5); // register the gauge and have it report to every 10 seconds registry.register('my-gauge', settableGauge, {}, 10); interval(() =&gt; { // such as cpu % used determineAValueThatCannotBeSync((value) =&gt; { settableGauge.update(value); }) }, 10000) shutdown() Calls end on all metrics in the registry that support end() and calls end on the reporter Source: registries/SelfReportingMetricsRegistry.js, line 261 × Search results Close "},"tutorial-SignalFx Express Full End to End Example.html":{"id":"tutorial-SignalFx Express Full End to End Example.html","title":"Tutorial: SignalFx Express Full End to End Example","body":" Measured Modules inputValidatorsmeasured-reporting Classes DimensionAwareMetricsRegistryReporterSelfReportingMetricsRegistry Tutorials SignalFx Express Full End to End Example Global Global SignalFx Express Full End to End Example Using Measured to instrument OS, Process and Express Metrics.This tutorial shows how to use the measured libraries to fully instrument OS and Node Process metrics as well as create an express middleware. The middleware will measure request count, latency distributions (req/res time histogram) and add dimensions to make it filterable by request method, response status code, request uri path. const os = require('os'); const signalfx = require('signalfx'); const express = require('express'); const { SignalFxMetricsReporter, SignalFxSelfReportingMetricsRegistry } = require('measured-signalfx-reporter'); const { createProcessMetrics, createOSMetrics, createExpressMiddleware } = require('measured-node-metrics'); const libraryMetadata = require('./package'); // get metadata from package.json const library = libraryMetadata.name; const version = libraryMetadata.version; // Report process and os stats 1x per minute const PROCESS_AND_SYSTEM_METRICS_REPORTING_INTERVAL_IN_SECONDS = 60; // Report the request count and histogram stats every 10 seconds const REQUEST_METRICS_REPORTING_INTERVAL_IN_SECONDS = 10; const defaultDimensions = { app: library, app_version: version, env: 'test' }; /** * Get your api key from a secrets provider of some kind. * * Good examples: * * &lt;li&gt; S3 with KMS * &lt;li&gt; Cerberus * &lt;li&gt; AWS Secrets Manager * &lt;li&gt; Vault * &lt;li&gt; Confidant * * Bad examples: * * &lt;li&gt; Checked into SCM in plaintext as a property * &lt;li&gt; Set as a plaintext environment variable * * @return {string} Returns the resolved Signal Fx Api Key */ const apiKeyResolver = () =&gt; { // https://diogomonica.com/2017/03/27/why-you-shouldnt-use-env-variables-for-secret-data/ return process.env.SIGNALFX_API_KEY; }; // Create the signal fx client const signalFxClient = new signalfx.Ingest(apiKeyResolver(), { userAgents: library }); // Create the signal fx reporter with the client const signalFxReporter = new SignalFxMetricsReporter(signalFxClient, { defaultDimensions: defaultDimensions, defaultReportingIntervalInSeconds: 10, logLevel: 'debug' }); // Create the self reporting metrics registry with the signal fx reporter const metricsRegistry = new SignalFxSelfReportingMetricsRegistry(signalFxReporter, { logLevel: 'debug' }); createOSMetrics(metricsRegistry, {}, PROCESS_AND_SYSTEM_METRICS_REPORTING_INTERVAL_IN_SECONDS); createProcessMetrics(metricsRegistry, {}, PROCESS_AND_SYSTEM_METRICS_REPORTING_INTERVAL_IN_SECONDS); const app = express(); // wire up the metrics middleware app.use(createExpressMiddleware(metricsRegistry, REQUEST_METRICS_REPORTING_INTERVAL_IN_SECONDS)); app.get('/hello', (req, res) =&gt; { res.send('hello world'); }); app.get('/path2', (req, res) =&gt; { res.send('path2'); }); app.listen(8080, () =&gt; log.info('Example app listening on port 8080!')); × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
