<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"measured-core_lib_util_BinaryHeap.js.html":{"id":"measured-core_lib_util_BinaryHeap.js.html","title":"Source: measured-core/lib/util/BinaryHeap.js","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterReporterSelfReportingMetricsRegistrySettableGaugeSignalFxMetricsReporterSignalFxSelfReportingMetricsRegistryStopwatchTimer Interfaces MetricMetricTypes Tutorials SignalFx Express Full End to End Example Global Global Source: measured-core/lib/util/BinaryHeap.js /** * Based on http://en.wikipedia.org/wiki/Binary_Heap * as well as http://eloquentjavascript.net/appendix2.html */ class BinaryHeap { constructor(options) { options = options || {}; this._elements = options.elements || []; this._score = options.score || this._score; } /** * Add elements to the binary heap. * @param {any[]} elements */ add(...elements) { elements.forEach(element =&gt; { this._elements.push(element); this._bubble(this._elements.length - 1); }); } first() { return this._elements[0]; } removeFirst() { const root = this._elements[0]; const last = this._elements.pop(); if (this._elements.length &gt; 0) { this._elements[0] = last; this._sink(0); } return root; } clone() { return new BinaryHeap({ elements: this.toArray(), score: this._score }); } toSortedArray() { const array = []; const clone = this.clone(); let element; while (true) { element = clone.removeFirst(); if (element === undefined) { break; } array.push(element); } return array; } toArray() { return [].concat(this._elements); } size() { return this._elements.length; } _bubble(bubbleIndex) { const bubbleElement = this._elements[bubbleIndex]; const bubbleScore = this._score(bubbleElement); let parentIndex; let parentElement; let parentScore; while (bubbleIndex &gt; 0) { parentIndex = this._parentIndex(bubbleIndex); parentElement = this._elements[parentIndex]; parentScore = this._score(parentElement); if (bubbleScore &lt;= parentScore) { break; } this._elements[parentIndex] = bubbleElement; this._elements[bubbleIndex] = parentElement; bubbleIndex = parentIndex; } } _sink(sinkIndex) { const sinkElement = this._elements[sinkIndex]; const sinkScore = this._score(sinkElement); const { length } = this._elements; let swapIndex; let swapScore; let swapElement; let childIndexes; let i; let childIndex; let childElement; let childScore; while (true) { swapIndex = null; swapScore = null; swapElement = null; childIndexes = this._childIndexes(sinkIndex); for (i = 0; i &lt; childIndexes.length; i++) { childIndex = childIndexes[i]; if (childIndex &gt;= length) { break; } childElement = this._elements[childIndex]; childScore = this._score(childElement); if (childScore &gt; sinkScore) { if (swapScore === null || swapScore &lt; childScore) { swapIndex = childIndex; swapScore = childScore; swapElement = childElement; } } } if (swapIndex === null) { break; } this._elements[swapIndex] = sinkElement; this._elements[sinkIndex] = swapElement; sinkIndex = swapIndex; } } _parentIndex(index) { return Math.floor((index - 1) / 2); } _childIndexes(index) { return [2 * index + 1, 2 * index + 2]; } _score(element) { return element.valueOf(); } } module.exports = BinaryHeap; Ã— Search results Close "},"measured-core_lib_Collection.js.html":{"id":"measured-core_lib_Collection.js.html","title":"Source: measured-core/lib/Collection.js","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterReporterSelfReportingMetricsRegistrySettableGaugeSignalFxMetricsReporterSignalFxSelfReportingMetricsRegistryStopwatchTimer Interfaces MetricMetricTypes Tutorials SignalFx Express Full End to End Example Global Global Source: measured-core/lib/Collection.js const Optional = require('optional-js'); const Counter = require('./metrics/Counter'); const Gauge = require('./metrics/Gauge'); const SettableGauge = require('./metrics/SettableGauge'); const Histogram = require('./metrics/Histogram'); const Meter = require('./metrics/Meter'); const Timer = require('./metrics/Timer'); const { MetricTypes } = require('./metrics/Metric'); /** * A Simple collection that stores names and a {@link Metric} instances with a few convenience methods for * creating / registering and then gathering all data the registered metrics. * @example * var { Collection } = require('measured'); * const collection = new Collection('node-process-metrics'); * const gauge = collection.gauge('node.process.heap_used', () =&gt; { * return process.memoryUsage().heapUsed; * }); */ class Collection { /** * Creates a named collection of metrics * @param {string} [name] The name to use for this collection. */ constructor(name) { this.name = name; /** * internal map of metric name to {@link Metric} * @type {Object.&lt;string, Metric&gt;} * @private */ this._metrics = {}; } /** * register a metric that was created outside the provided convenience methods of this collection * @param name The metric name * @param metric The {@link Metric} implementation * @example * var { Collection, Gauge } = require('measured'); * const collection = new Collection('node-process-metrics'); * const gauge = new Gauge(() =&gt; { * return process.memoryUsage().heapUsed; * }); * collection.register('node.process.heap_used', gauge); */ register(name, metric) { this._metrics[name] = metric; } /** * Fetches the data/values from all registered metrics * @return {Object} The combined JSON object */ toJSON() { const json = {}; Object.keys(this._metrics).forEach(metric =&gt; { if (Object.prototype.hasOwnProperty.call(this._metrics, metric)) { json[metric] = this._metrics[metric].toJSON(); } }); if (!this.name) { return json; } const wrapper = {}; wrapper[this.name] = json; return wrapper; } /** * Gets or creates and registers a {@link Gauge} * @param {string} name The metric name * @param {function} readFn See {@link Gauge} * @return {Gauge} */ gauge(name, readFn) { this._validateName(name); let gauge; this._getMetricForNameAndType(name, MetricTypes.GAUGE).ifPresentOrElse( registeredMetric =&gt; { gauge = registeredMetric; }, () =&gt; { gauge = new Gauge(readFn); this.register(name, gauge); } ); return gauge; } /** * Gets or creates and registers a {@link Counter} * @param {string} name The metric name * @param {CounterProperties} [properties] See {@link CounterProperties} * @return {Counter} */ counter(name, properties) { this._validateName(name); let counter; this._getMetricForNameAndType(name, MetricTypes.COUNTER).ifPresentOrElse( registeredMetric =&gt; { counter = registeredMetric; }, () =&gt; { counter = new Counter(properties); this.register(name, counter); } ); return counter; } /** * Gets or creates and registers a {@link Histogram} * @param {string} name The metric name * @param {HistogramProperties} [properties] See {@link HistogramProperties} * @return {Histogram} */ histogram(name, properties) { this._validateName(name); let histogram; this._getMetricForNameAndType(name, MetricTypes.HISTOGRAM).ifPresentOrElse( registeredMetric =&gt; { histogram = registeredMetric; }, () =&gt; { histogram = new Histogram(properties); this.register(name, histogram); } ); return histogram; } /** * Gets or creates and registers a {@link Timer} * @param {string} name The metric name * @param {TimerProperties} [properties] See {@link TimerProperties} * @return {Timer} */ timer(name, properties) { this._validateName(name); let timer; this._getMetricForNameAndType(name, MetricTypes.TIMER).ifPresentOrElse( registeredMetric =&gt; { timer = registeredMetric; }, () =&gt; { timer = new Timer(properties); this.register(name, timer); } ); return timer; } /** * Gets or creates and registers a {@link Meter} * @param {string} name The metric name * @param {MeterProperties} [properties] See {@link MeterProperties} * @return {Meter} */ meter(name, properties) { this._validateName(name); let meter; this._getMetricForNameAndType(name, MetricTypes.METER).ifPresentOrElse( registeredMetric =&gt; { meter = registeredMetric; }, () =&gt; { meter = new Meter(properties); this.register(name, meter); } ); return meter; } /** * Gets or creates and registers a {@link SettableGauge} * @param {string} name The metric name * @param {SettableGaugeProperties} [properties] See {@link SettableGaugeProperties} * @return {SettableGauge} */ settableGauge(name, properties) { this._validateName(name); let settableGauge; this._getMetricForNameAndType(name, MetricTypes.METER).ifPresentOrElse( registeredMetric =&gt; { settableGauge = registeredMetric; }, () =&gt; { settableGauge = new SettableGauge(properties); this.register(name, settableGauge); } ); return settableGauge; } /** * Checks the registry for a metric with a given name and type, if it exists in the registry as a * different type an error is thrown. * @param {string} name The metric name * @param {string} requestedType The metric type * @return {Optional&lt;Metric&gt;} * @private */ _getMetricForNameAndType(name, requestedType) { if (this._metrics[name]) { const metric = this._metrics[name]; const actualType = metric.getType(); if (requestedType !== actualType) { throw new Error( `You requested a metric of type: ${requestedType} with name: ${name}, but it exists in the registry as type: ${actualType}` ); } return Optional.of(metric); } return Optional.empty(); } /** * Validates that the provided name is valid. * * @param name The provided metric name param. * @private */ _validateName(name) { if (!name || typeof name !== 'string') { throw new Error('You must supply a metric name'); } } /** * Calls end on all metrics in the registry that support end() */ end() { const metrics = this._metrics; Object.keys(metrics).forEach(name =&gt; { const metric = metrics[name]; if (metric.end) { metric.end(); } }); } } module.exports = Collection; Ã— Search results Close "},"measured-core_lib_metrics_Counter.js.html":{"id":"measured-core_lib_metrics_Counter.js.html","title":"Source: measured-core/lib/metrics/Counter.js","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterReporterSelfReportingMetricsRegistrySettableGaugeSignalFxMetricsReporterSignalFxSelfReportingMetricsRegistryStopwatchTimer Interfaces MetricMetricTypes Tutorials SignalFx Express Full End to End Example Global Global Source: measured-core/lib/metrics/Counter.js const { MetricTypes } = require('./Metric'); /** * Counters are things that increment or decrement * @implements {Metric} * @example * var Measured = require('measured') * var activeUploads = new Measured.Counter(); * http.createServer(function(req, res) { * activeUploads.inc(); * req.on('end', function() { * activeUploads.dec(); * }); * }); */ class Counter { /** * @param {CounterProperties} [properties] see {@link CounterProperties} */ constructor(properties) { properties = properties || {}; this._count = properties.count || 0; } /** * Counters directly return their currently value. * @return {number} */ toJSON() { return this._count; } /** * Increments the counter. * @param {number} n Increment the counter by n. Defaults to 1. */ inc(n) { this._count += arguments.length ? n : 1; } /** * Decrements the counter * @param {number} n Decrement the counter by n. Defaults to 1. */ dec(n) { this._count -= arguments.length ? n : 1; } /** * Resets the counter back to count Defaults to 0. * @param {number} count Resets the counter back to count Defaults to 0. */ reset(count) { this._count = count || 0; } /** * The type of the Metric Impl. {@link MetricTypes}. * @return {string} The type of the Metric Impl. */ getType() { return MetricTypes.COUNTER; } } module.exports = Counter; /** * Properties that can be supplied to the constructor of a {@link Counter} * * @interface CounterProperties * @typedef CounterProperties * @type {Object} * @property {number} count An initial count for the counter. Defaults to 0. * @example * // Creates a counter that starts at 5. * const counter = new Counter({ count: 5 }) */ Ã— Search results Close "},"measured-reporting_lib_registries_DimensionAwareMetricsRegistry.js.html":{"id":"measured-reporting_lib_registries_DimensionAwareMetricsRegistry.js.html","title":"Source: measured-reporting/lib/registries/DimensionAwareMetricsRegistry.js","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterReporterSelfReportingMetricsRegistrySettableGaugeSignalFxMetricsReporterSignalFxSelfReportingMetricsRegistryStopwatchTimer Interfaces MetricMetricTypes Tutorials SignalFx Express Full End to End Example Global Global Source: measured-reporting/lib/registries/DimensionAwareMetricsRegistry.js /** * Simple registry that stores Metrics by name and dimension * @private */ class DimensionAwareMetricsRegistry { constructor() { this._metrics = {}; } /** * Checks to see if a metric with the given name and dimensions is present. * * @param {string} name The metric name * @param {Dimensions} dimensions The dimensions for the metric * @returns {boolean} true if the metric with given dimensions is present */ hasMetric(name, dimensions) { const key = this._generateStorageKey(name, dimensions); return Object.prototype.hasOwnProperty.call(this._metrics, key); } /** * Retrieves a metric with a given name and dimensions is present. * * @param {string} name The metric name * @param {Dimensions} dimensions The dimensions for the metric * @returns {Metric} a wrapper object around name, dimension and {@link Metric} */ getMetric(name, dimensions) { const key = this._generateStorageKey(name, dimensions); return this._metrics[key].metricImpl; } /** * Retrieves a metric by the calculated key (name / dimension combo). * * @param {string} key The registered key for the given registered {@link MetricWrapper} * @returns {MetricWrapper} a wrapper object around name, dimension and {@link Metric} */ getMetricWrapperByKey(key) { return this._metrics[key]; } /** * Upserts a {@link Metric} in the internal storage map for a given name, dimension combo * * @param {string} name The metric name * @param {Metric} metric The {@link Metric} impl * @param {Dimensions} dimensions The dimensions for the metric * @return {string} The registry key for the metric, dimension combo */ putMetric(name, metric, dimensions) { const key = this._generateStorageKey(name, dimensions); this._metrics[key] = { name: name, metricImpl: metric, dimensions: dimensions || {} }; return key; } allKeys() { return Object.keys(this._metrics); } /** * Generates a unique key off of the metric name and custom dimensions for internal use in the registry maps. * * @param {string} name The metric name * @param {Dimensions} dimensions The dimensions for the metric * @return {string} a unique key based off of the metric nae and dimensions * @private */ _generateStorageKey(name, dimensions) { let key = name; if (dimensions) { Object.keys(dimensions).forEach(dimensionKey =&gt; { key = `${key}-${dimensions[dimensionKey]}`; }); } return key; } } module.exports = DimensionAwareMetricsRegistry; Ã— Search results Close "},"measured-reporting_lib_@types_types.js.html":{"id":"measured-reporting_lib_@types_types.js.html","title":"Source: measured-reporting/lib/@types/types.js","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterReporterSelfReportingMetricsRegistrySettableGaugeSignalFxMetricsReporterSignalFxSelfReportingMetricsRegistryStopwatchTimer Interfaces MetricMetricTypes Tutorials SignalFx Express Full End to End Example Global Global Source: measured-reporting/lib/@types/types.js /** * A wrapper object around a {@link Metric}, {@link Dimensions} and the metric name * * @interface MetricWrapper * @typedef MetricWrapper * @type {Object} * @property {string} name The supplied name of the Metric * @property {Metric} metric The {@link Metric} object * @property {Dimensions} dimensions The {@link Dimensions} for the given {@link Metric} */ /** * A Dictionary of string, string key value pairs * * @interface Dimensions * @typedef Dimensions * @type {Object.&lt;string, string&gt;} * * @example * { * path: &quot;/api/foo&quot; * method: &quot;GET&quot; * statusCode: &quot;200&quot; * } */ Ã— Search results Close "},"measured-core_lib_util_ExponentiallyDecayingSample.js.html":{"id":"measured-core_lib_util_ExponentiallyDecayingSample.js.html","title":"Source: measured-core/lib/util/ExponentiallyDecayingSample.js","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterReporterSelfReportingMetricsRegistrySettableGaugeSignalFxMetricsReporterSignalFxSelfReportingMetricsRegistryStopwatchTimer Interfaces MetricMetricTypes Tutorials SignalFx Express Full End to End Example Global Global Source: measured-core/lib/util/ExponentiallyDecayingSample.js const BinaryHeap = require('./BinaryHeap'); const units = require('./units'); const RESCALE_INTERVAL = units.HOURS; const ALPHA = 0.015; const SIZE = 1028; /** * ExponentiallyDecayingSample */ class ExponentiallyDecayingSample { constructor(options) { options = options || {}; this._elements = new BinaryHeap({ score: element =&gt; -element.priority }); this._rescaleInterval = options.rescaleInterval || RESCALE_INTERVAL; this._alpha = options.alpha || ALPHA; this._size = options.size || SIZE; this._random = options.random || this._random; this._landmark = null; this._nextRescale = null; } update(value, timestamp) { const now = Date.now(); if (!this._landmark) { this._landmark = now; this._nextRescale = this._landmark + this._rescaleInterval; } timestamp = timestamp || now; const newSize = this._elements.size() + 1; const element = { priority: this._priority(timestamp - this._landmark), value: value }; if (newSize &lt;= this._size) { this._elements.add(element); } else if (element.priority &gt; this._elements.first().priority) { this._elements.removeFirst(); this._elements.add(element); } if (now &gt;= this._nextRescale) { this._rescale(now); } } toSortedArray() { return this._elements.toSortedArray().map(element =&gt; element.value); } toArray() { return this._elements.toArray().map(element =&gt; element.value); } toArrayWithWeights() { return this._elements.toArray(); } _weight(age) { // We divide by 1000 to not run into huge numbers before reaching a // rescale event. return Math.exp(this._alpha * (age / 1000)); } _priority(age) { return this._weight(age) / this._random(); } _random() { return Math.random(); } _rescale(now) { now = now || Date.now(); const self = this; const oldLandmark = this._landmark; this._landmark = now || Date.now(); this._nextRescale = now + this._rescaleInterval; const factor = self._priority(-(self._landmark - oldLandmark)); this._elements.toArray().forEach(element =&gt; { element.priority *= factor; }); } } module.exports = ExponentiallyDecayingSample; Ã— Search results Close "},"measured-core_lib_util_ExponentiallyMovingWeightedAverage.js.html":{"id":"measured-core_lib_util_ExponentiallyMovingWeightedAverage.js.html","title":"Source: measured-core/lib/util/ExponentiallyMovingWeightedAverage.js","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterReporterSelfReportingMetricsRegistrySettableGaugeSignalFxMetricsReporterSignalFxSelfReportingMetricsRegistryStopwatchTimer Interfaces MetricMetricTypes Tutorials SignalFx Express Full End to End Example Global Global Source: measured-core/lib/util/ExponentiallyMovingWeightedAverage.js const units = require('./units'); const TICK_INTERVAL = 5 * units.SECONDS; /** * ExponentiallyMovingWeightedAverage */ class ExponentiallyMovingWeightedAverage { constructor(timePeriod, tickInterval) { this._timePeriod = timePeriod || units.MINUTE; this._tickInterval = tickInterval || TICK_INTERVAL; this._alpha = 1 - Math.exp(-this._tickInterval / this._timePeriod); this._count = 0; this._rate = 0; } update(n) { this._count += n; } tick() { const instantRate = this._count / this._tickInterval; this._count = 0; this._rate += this._alpha * (instantRate - this._rate); } rate(timeUnit) { return (this._rate || 0) * timeUnit; } } module.exports = ExponentiallyMovingWeightedAverage; Ã— Search results Close "},"measured-core_lib_metrics_Gauge.js.html":{"id":"measured-core_lib_metrics_Gauge.js.html","title":"Source: measured-core/lib/metrics/Gauge.js","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterReporterSelfReportingMetricsRegistrySettableGaugeSignalFxMetricsReporterSignalFxSelfReportingMetricsRegistryStopwatchTimer Interfaces MetricMetricTypes Tutorials SignalFx Express Full End to End Example Global Global Source: measured-core/lib/metrics/Gauge.js const { MetricTypes } = require('./Metric'); /** * Values that can be read instantly * @implements {Metric} * @example * var Measured = require('measured') * var gauge = new Measured.Gauge(function() { * return process.memoryUsage().rss; * }); */ class Gauge { /** * @param {function} readFn A function that returns the numeric value for this gauge. */ constructor(readFn) { this._readFn = readFn; } /** * This is sync for now, but maybe async gauges would be useful as well? * @return {number} Gauges directly return the value from the callback which should be a number. */ toJSON() { return this._readFn(); } /** * The type of the Metric Impl. {@link MetricTypes}. * @return {string} The type of the Metric Impl. */ getType() { return MetricTypes.GAUGE; } } module.exports = Gauge; Ã— Search results Close "},"measured-core_lib_metrics_Histogram.js.html":{"id":"measured-core_lib_metrics_Histogram.js.html","title":"Source: measured-core/lib/metrics/Histogram.js","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterReporterSelfReportingMetricsRegistrySettableGaugeSignalFxMetricsReporterSignalFxSelfReportingMetricsRegistryStopwatchTimer Interfaces MetricMetricTypes Tutorials SignalFx Express Full End to End Example Global Global Source: measured-core/lib/metrics/Histogram.js const { MetricTypes } = require('./Metric'); const binarySearch = require('binary-search'); const EDS = require('../util/ExponentiallyDecayingSample'); /** * Keeps a reservoir of statistically relevant values biased towards the last 5 minutes to explore their distribution. * @implements {Metric} * @example * var Measured = require('measured') * var histogram = new Measured.Histogram(); * http.createServer(function(req, res) { * if (req.headers['content-length']) { * histogram.update(parseInt(req.headers['content-length'], 10)); * } * }); */ class Histogram { /** @param {HistogramProperties} [properties] see {@link HistogramProperties}. */ constructor(properties) { this._properties = properties || {}; this._initializeState(); } _initializeState() { this._sample = this._properties.sample || new EDS(); this._percentilesMethod = this._properties.percentilesMethod || this._percentiles; this._min = null; this._max = null; this._count = 0; this._sum = 0; // These are for the Welford algorithm for calculating running constiance // without floating-point doom. this._constianceM = 0; this._constianceS = 0; } /** * Pushes value into the sample. timestamp defaults to Date.now(). * @param {number} value */ update(value) { this._count++; this._sum += value; this._sample.update(value); this._updateMin(value); this._updateMax(value); this._updateVariance(value); } _percentiles(percentiles) { const values = this._sample.toArray().sort((a, b) =&gt; { return a === b ? 0 : a - b; }); const results = {}; let i, percentile, pos, lower, upper; for (i = 0; i &lt; percentiles.length; i++) { percentile = percentiles[i]; if (values.length) { pos = percentile * (values.length + 1); if (pos &lt; 1) { results[percentile] = values[0]; } else if (pos &gt;= values.length) { results[percentile] = values[values.length - 1]; } else { lower = values[Math.floor(pos) - 1]; upper = values[Math.ceil(pos) - 1]; results[percentile] = lower + (pos - Math.floor(pos)) * (upper - lower); } } else { results[percentile] = null; } } return results; } weightedPercentiles(percentiles) { const values = this._sample.toArrayWithWeights().sort((a, b) =&gt; { return a.value === b.value ? 0 : a.value - b.value; }); const sumWeight = values.reduce((sum, sample) =&gt; { return sum + sample.priority; }, 0); const normWeights = values.map(value =&gt; { return value.priority / sumWeight; }); const quantiles = [0]; let i; for (i = 1; i &lt; values.length; i++) { quantiles[i] = quantiles[i - 1] + normWeights[i - 1]; } function gt(a, b) { return a - b; } const results = {}; let percentile, pos; for (i = 0; i &lt; percentiles.length; i++) { percentile = percentiles[i]; if (values.length) { pos = binarySearch(quantiles, percentile, gt); if (pos &lt; 0) { results[percentile] = values[-pos - 1 - 1].value; } else if (pos &lt; 1) { results[percentile] = values[0].value; } else if (pos &gt;= values.length) { results[percentile] = values[values.length - 1].value; } } else { results[percentile] = null; } } return results; } /** * Resets all values. Histograms initialized with custom options will be reset to the default settings (patch welcome). */ reset() { // while this is technically a bug?, copying existing logic to maintain current api, // TODO reset should reset the sample, not override it with a new EDS() this._properties.sample = new EDS(); this._initializeState(); } /** * Checks whether the histogram contains values. * @return {boolean} Whether the histogram contains values. */ hasValues() { return this._count &gt; 0; } /** * @return {HistogramData} */ toJSON() { const percentiles = this._percentilesMethod([0.5, 0.75, 0.95, 0.99, 0.999]); return { min: this._min, max: this._max, sum: this._sum, variance: this._calculateVariance(), mean: this._calculateMean(), stddev: this._calculateStddev(), count: this._count, median: percentiles[0.5], p75: percentiles[0.75], p95: percentiles[0.95], p99: percentiles[0.99], p999: percentiles[0.999] }; } _updateMin(value) { if (this._min === null || value &lt; this._min) { this._min = value; } } _updateMax(value) { if (this._max === null || value &gt; this._max) { this._max = value; } } _updateVariance(value) { if (this._count === 1) { this._constianceM = value; return value; } const oldM = this._constianceM; this._constianceM += (value - oldM) / this._count; this._constianceS += (value - oldM) * (value - this._constianceM); // TODO is this right, above it returns in the if statement but does nothing but update internal state for the else case? return undefined; } /** * * @return {number|null} * @private */ _calculateMean() { return this._count === 0 ? 0 : this._sum / this._count; } /** * @return {number|null} * @private */ _calculateVariance() { return this._count &lt;= 1 ? null : this._constianceS / (this._count - 1); } /** * @return {number|null} * @private */ _calculateStddev() { return this._count &lt; 1 ? null : Math.sqrt(this._calculateVariance()); } /** * The type of the Metric Impl. {@link MetricTypes}. * @return {string} The type of the Metric Impl. */ getType() { return MetricTypes.HISTOGRAM; } } module.exports = Histogram; /** * Properties to create a {@link Histogram} with. * * @interface HistogramProperties * @typedef HistogramProperties * @type {Object} * @property {object} sample The sample reservoir to use. Defaults to an ExponentiallyDecayingSample. */ /** * The data returned from Histogram::toJSON() * @interface HistogramData * @typedef HistogramData * @typedef {object} * @property {number|null} min The lowest observed value. * @property {number|null} max The highest observed value. * @property {number|null} sum The sum of all observed values. * @property {number|null} variance The variance of all observed values. * @property {number|null} mean The average of all observed values. * @property {number|null} stddev The stddev of all observed values. * @property {number} count The number of observed values. * @property {number} median 50% of all values in the resevoir are at or below this value. * @property {number} p75 See median, 75% percentile. * @property {number} p95 See median, 95% percentile. * @property {number} p99 See median, 99% percentile. * @property {number} p999 See median, 99.9% percentile. */ Ã— Search results Close "},"measured-core_lib_metrics_Meter.js.html":{"id":"measured-core_lib_metrics_Meter.js.html","title":"Source: measured-core/lib/metrics/Meter.js","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterReporterSelfReportingMetricsRegistrySettableGaugeSignalFxMetricsReporterSignalFxSelfReportingMetricsRegistryStopwatchTimer Interfaces MetricMetricTypes Tutorials SignalFx Express Full End to End Example Global Global Source: measured-core/lib/metrics/Meter.js const { MetricTypes } = require('./Metric'); const units = require('../util/units'); const EWMA = require('../util/ExponentiallyMovingWeightedAverage'); const RATE_UNIT = units.SECONDS; const TICK_INTERVAL = 5 * units.SECONDS; /** * Things that are measured as events / interval. * @implements {Metric} * @example * var Measured = require('measured') * var meter = new Measured.Meter(); * http.createServer(function(req, res) { * meter.mark(); * }); */ class Meter { /** * @param {MeterProperties} [properties] see {@link MeterProperties}. */ constructor(properties) { this._properties = properties || {}; this._initializeState(); } /** * Initializes the state of this Metric * @private */ _initializeState() { this._rateUnit = this._properties.rateUnit || RATE_UNIT; this._tickInterval = this._properties.tickInterval || TICK_INTERVAL; if (this._properties.getTime) { this._getTime = this._properties.getTime; } this._m1Rate = this._properties.m1Rate || new EWMA(units.MINUTES, this._tickInterval); this._m5Rate = this._properties.m5Rate || new EWMA(5 * units.MINUTES, this._tickInterval); this._m15Rate = this._properties.m15Rate || new EWMA(15 * units.MINUTES, this._tickInterval); this._count = 0; this._currentSum = 0; this._startTime = this._getTime(); this._lastToJSON = this._getTime(); this._interval = setInterval(this._tick.bind(this), TICK_INTERVAL); } /** * Register n events as having just occured. Defaults to 1. * @param {number} n */ mark(n) { if (!this._interval) { this.start(); } n = n || 1; this._count += n; this._currentSum += n; this._m1Rate.update(n); this._m5Rate.update(n); this._m15Rate.update(n); } start() {} end() { clearInterval(this._interval); this._interval = null; } /** * Refs the backing timer again. Idempotent. */ ref() { if (this._interval &amp;&amp; this._interval.ref) { this._interval.ref(); } } /** * Unrefs the backing timer. The meter will not keep the event loop alive. Idempotent. */ unref() { if (this._interval &amp;&amp; this._interval.unref) { this._interval.unref(); } } _tick() { this._m1Rate.tick(); this._m5Rate.tick(); this._m15Rate.tick(); } /** * Resets all values. Meters initialized with custom options will be reset to the default settings (patch welcome). */ reset() { this.end(); this._initializeState(); } meanRate() { if (this._count === 0) { return 0; } const elapsed = this._getTime() - this._startTime; return this._count / elapsed * this._rateUnit; } currentRate() { const currentSum = this._currentSum; const duration = this._getTime() - this._lastToJSON; const currentRate = currentSum / duration * this._rateUnit; this._currentSum = 0; this._lastToJSON = this._getTime(); // currentRate could be NaN if duration was 0, so fix that return currentRate || 0; } /** * @return {MeterData} */ toJSON() { return { mean: this.meanRate(), count: this._count, currentRate: this.currentRate(), '1MinuteRate': this._m1Rate.rate(this._rateUnit), '5MinuteRate': this._m5Rate.rate(this._rateUnit), '15MinuteRate': this._m15Rate.rate(this._rateUnit) }; } _getTime() { if (!process.hrtime) { return new Date().getTime(); } const hrtime = process.hrtime(); return hrtime[0] * 1000 + hrtime[1] / (1000 * 1000); } /** * The type of the Metric Impl. {@link MetricTypes}. * @return {string} The type of the Metric Impl. */ getType() { return MetricTypes.METER; } } module.exports = Meter; /** * * @interface MeterProperties * @typedef MeterProperties * @type {Object} * @property {number} rateUnit The rate unit. Defaults to 1000 (1 sec). * @property {number} tickInterval The interval in which the averages are updated. Defaults to 5000 (5 sec). * @example * const meter = new Meter({ rateUnit: 1000, tickInterval: 5000}) */ /** * The data returned from Meter::toJSON() * @interface MeterData * @typedef MeterData * @typedef {object} * @property {number} mean The average rate since the meter was started. * @property {number} count The total of all values added to the meter. * @property {number} currentRate The rate of the meter since the last toJSON() call. * @property {number} 1MinuteRate The rate of the meter biased towards the last 1 minute. * @property {number} 5MinuteRate The rate of the meter biased towards the last 5 minutes. * @property {number} 15MinuteRate The rate of the meter biased towards the last 15 minutes. */ Ã— Search results Close "},"measured-core_lib_metrics_Metric.js.html":{"id":"measured-core_lib_metrics_Metric.js.html","title":"Source: measured-core/lib/metrics/Metric.js","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterReporterSelfReportingMetricsRegistrySettableGaugeSignalFxMetricsReporterSignalFxSelfReportingMetricsRegistryStopwatchTimer Interfaces MetricMetricTypes Tutorials SignalFx Express Full End to End Example Global Global Source: measured-core/lib/metrics/Metric.js /** * Interface for Metric types. * * Implementations * &lt;p&gt; * &lt;li&gt;&lt;a href=&quot;#counter&quot;&gt;Counter&lt;/a&gt;, things that increment or decrement.&lt;/li&gt; * &lt;li&gt;&lt;a href=&quot;#gauge&quot;&gt;Gauge&lt;/a&gt;, values that can be read instantly via a supplied call back.&lt;/li&gt; * &lt;li&gt;&lt;a href=&quot;#histogram&quot;&gt;Histogram&lt;/a&gt;, keeps a reservoir of statistically relevant values to explore their distribution.&lt;/li&gt; * &lt;li&gt;&lt;a href=&quot;#meter&quot;&gt;Meter&lt;/a&gt;, things that are measured as events / interval.&lt;/li&gt; * &lt;li&gt;&lt;a href=&quot;#noopmeter&quot;&gt;NoOpMeter&lt;/a&gt;, an empty impl of meter, useful for supplying to a Timer, when you only care about the Histogram.&lt;/li&gt; * &lt;li&gt;&lt;a href=&quot;#settablegauge&quot;&gt;SettableGauge&lt;/a&gt;, just like a Gauge but its value is set directly rather than supplied by a callback.&lt;/li&gt; * &lt;li&gt;&lt;a href=&quot;#timer&quot;&gt;Timer&lt;/a&gt;, timers are a combination of Meters and Histograms. They measure the rate as well as distribution of scalar events.&lt;/li&gt; * &lt;/p&gt; * * @interface Metric */ // eslint-disable-next-line no-unused-vars class Metric { /** * Please note that dispite its name, this method can return raw numbers on * certain implementations such as counters and gauges. * * @return {any} Returns the data from the Metric */ toJSON() {} /** * The type of the Metric Impl. {@link MetricTypes}. * @return {string} The type of the Metric Impl. */ getType() {} } /** * An enum like object that is the set of core metric types that all implementors of {@link Metric} are. * * @typedef MetricTypes * @interface MetricTypes * @type {Object.&lt;string, string&gt;} * @property {COUNTER} The type for Counters. * @property {GAUGE} The type for Gauges. * @property {HISTOGRAM} The type for Histograms. * @property {METER} The type for Meters. * @property {TIMER} The type for Timers. */ const MetricTypes = { COUNTER: 'Counter', GAUGE: 'Gauge', HISTOGRAM: 'Histogram', METER: 'Meter', TIMER: 'Timer' }; module.exports = { MetricTypes }; Ã— Search results Close "},"measured-signalfx-reporter_lib_reporter_SignalFxMetricsReporter.js.html":{"id":"measured-signalfx-reporter_lib_reporter_SignalFxMetricsReporter.js.html","title":"Source: measured-signalfx-reporter/lib/reporter/SignalFxMetricsReporter.js","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterReporterSelfReportingMetricsRegistrySettableGaugeSignalFxMetricsReporterSignalFxSelfReportingMetricsRegistryStopwatchTimer Interfaces MetricMetricTypes Tutorials SignalFx Express Full End to End Example Global Global Source: measured-signalfx-reporter/lib/reporter/SignalFxMetricsReporter.js const { Reporter } = require('measured-reporting'); const { MetricTypes } = require('measured-core'); const { validateSignalFxClient } = require('../validators/inputValidators'); /** * A Reporter that reports metrics to Signal Fx * @extends {Reporter} */ class SignalFxMetricsReporter extends Reporter { /** * @param {SignalFxClient} signalFxClient The configured signal fx client. * @param {ReporterOptions} options See {@link ReporterOptions}. */ constructor(signalFxClient, options) { super(options); validateSignalFxClient(signalFxClient); this._signalFxClient = signalFxClient; } /** * Sends metrics to signal fx, converting name and dimensions and {@link Metric} to data signal fx can ingest * @param {MetricWrapper[]} metrics The array of metrics to send to signal fx. * @protected */ _reportMetrics(metrics) { this._log.debug('_reportMetrics() called'); let signalFxDataPointRequest = {}; metrics.forEach(metric =&gt; { if (!metric) { this._log.warn('Metric was null when it should not have been'); return; } signalFxDataPointRequest = this._processMetric(metric, signalFxDataPointRequest); }); this._log.debug('Sending data to Signal Fx'); this._signalFxClient.send(signalFxDataPointRequest).catch(error =&gt; { this._log.error('Failed to send metrics to signal fx error:', error); }); } /** * Method for getting raw signal fx api request values from the Timer Object. * * @param {MetricWrapper} metric metric The Wrapped Metric Object. * @param {any} currentBuiltRequest The signal fx request that is being built. * @return {any} the currentBuiltRequest The signal fx request that is being built with the given metric in it. * @protected */ _processMetric(metric, currentBuiltRequest) { const newRequest = Object.assign({}, currentBuiltRequest); const { name, metricImpl } = metric; const mergedDimensions = this._getDimensions(metric); const valuesToProcess = this._getValuesToProcessForType(name, metricImpl); valuesToProcess.forEach(metricValueTypeWrapper =&gt; { const signalFxDataPointMetric = { metric: metricValueTypeWrapper.metric, value: metricValueTypeWrapper.value, dimensions: mergedDimensions }; if (Object.prototype.hasOwnProperty.call(newRequest, metricValueTypeWrapper.type)) { newRequest[metricValueTypeWrapper.type].push(signalFxDataPointMetric); } else { newRequest[metricValueTypeWrapper.type] = [signalFxDataPointMetric]; } }); return newRequest; } /** * Maps Measured Metrics Object JSON outputs to there respective signal fx metrics using logic from * com.signalfx.codahale.reporter.AggregateMetricSenderSessionWrapper in the java lib to derive naming * * @param {string} name The registered metric base name * @param {Metric} metric The metric. * @return {MetricValueTypeWrapper[]} an array of MetricValueTypeWrapper that can be used to * build the sig fx data point request * @protected */ _getValuesToProcessForType(name, metric) { const type = metric.getType(); switch (type) { case MetricTypes.TIMER: return this._getValuesToProcessForTimer(name, metric); case MetricTypes.GAUGE: return this._getValuesToProcessForGauge(name, metric); case MetricTypes.COUNTER: return this._getValuesToProcessForCounter(name, metric); case MetricTypes.HISTOGRAM: return this._getValuesToProcessForHistogram(name, metric); case MetricTypes.METER: this._log.warn( 'Meters are not implemented in the signal fx reporter as you can use a counter and reduce your DPM' ); return []; default: this._log.error(`Metric Type: ${type} has not been implemented to report to signal fx`); return []; } } /** * Maps and Filters values from a Timer to a set of metrics to report to SigFx. * * @param {string} name The registry name * @param {Timer} timer The Timer * @return {MetricValueTypeWrapper[]} Returns an array of MetricValueTypeWrapper to use to build the request * @protected */ _getValuesToProcessForTimer(name, timer) { let valuesToProcess = []; // only grab histogram data as Meters can be accomplished with signal fx using the count from the histogram valuesToProcess = valuesToProcess.concat(this._getValuesToProcessForHistogram(name, timer._histogram)); return valuesToProcess; } /** * Maps and Filters values from a Gauge to a set of metrics to report to SigFx. * * @param {string} name The registry name * @param {Gauge} gauge The Gauge * @return {MetricValueTypeWrapper[]} Returns an array of MetricValueTypeWrapper to use to build the request * @protected */ _getValuesToProcessForGauge(name, gauge) { const valuesToProcess = []; valuesToProcess.push({ metric: `${name}`, value: gauge.toJSON(), type: SIGNAL_FX_GAUGE }); return valuesToProcess; } /** * Maps and Filters values from a Counter to a set of metrics to report to SigFx. * * @param {string} name The registry name * @param {Counter} counter The data from the measure metric object * @return {MetricValueTypeWrapper[]} Returns an array of MetricValueTypeWrapper to use to build the request * @protected */ _getValuesToProcessForCounter(name, counter) { const valuesToProcess = []; valuesToProcess.push({ metric: `${name}.count`, value: counter.toJSON(), type: SIGNAL_FX_CUMULATIVE_COUNTER }); return valuesToProcess; } /** * Maps and Filters values from a Histogram to a set of metrics to report to SigFx. * * @param {string} name The registry name * @param {Histogram} histogram The Histogram * @return {MetricValueTypeWrapper[]} Returns an array of MetricValueTypeWrapper to use to build the request * @protected */ _getValuesToProcessForHistogram(name, histogram) { const data = histogram.toJSON(); const valuesToProcess = []; valuesToProcess.push({ metric: `${name}.count`, value: data.count || 0, type: SIGNAL_FX_CUMULATIVE_COUNTER }); valuesToProcess.push({ metric: `${name}.max`, value: data.max || 0, type: SIGNAL_FX_GAUGE }); valuesToProcess.push({ metric: `${name}.min`, value: data.min || 0, type: SIGNAL_FX_GAUGE }); valuesToProcess.push({ metric: `${name}.mean`, value: data.mean || 0, type: SIGNAL_FX_GAUGE }); valuesToProcess.push({ metric: `${name}.p95`, value: data.p95 || 0, type: SIGNAL_FX_GAUGE }); valuesToProcess.push({ metric: `${name}.p99`, value: data.p99 || 0, type: SIGNAL_FX_GAUGE }); return valuesToProcess; } } // const SIGNAL_FX_COUNTER = 'counters'; const SIGNAL_FX_GAUGE = 'gauges'; const SIGNAL_FX_CUMULATIVE_COUNTER = 'cumulative_counters'; module.exports = SignalFxMetricsReporter; /** * Wrapper object to wrap metric value and SFX metadata needed to send metric value to SFX data ingestion. * * @interface MetricValueTypeWrapper * @typedef MetricValueTypeWrapper * @type {Object} * @property {string} metric The metric name to report to SignalFx * @property {number} value the value to report to SignalFx * @property {string} type The mapped SignalFx metric type */ Ã— Search results Close "},"measured-reporting_lib_validators_inputValidators.js.html":{"id":"measured-reporting_lib_validators_inputValidators.js.html","title":"Source: measured-reporting/lib/validators/inputValidators.js","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterReporterSelfReportingMetricsRegistrySettableGaugeSignalFxMetricsReporterSignalFxSelfReportingMetricsRegistryStopwatchTimer Interfaces MetricMetricTypes Tutorials SignalFx Express Full End to End Example Global Global Source: measured-reporting/lib/validators/inputValidators.js const Optional = require('optional-js'); /** * This module contains various validators to validate publicly exposed input * @module inputValidators * @private */ module.exports = { /** * Validates @{link Gauge} options. * * @param {string} name The metric name * @param {function} callback The callback for the Gauge * @param {Dimensions} dimensions The optional custom dimensions * @param {number} publishingIntervalInSeconds the optional publishing interval */ validateGaugeOptions: (name, callback, dimensions, publishingIntervalInSeconds) =&gt; { module.exports.validateMetricName(name); module.exports.validateNumberReturningCallback(callback); module.exports.validateOptionalDimensions(dimensions); module.exports.validateOptionalPublishingInterval(publishingIntervalInSeconds); }, /** * Validates the create histogram Options. * * @param {string} name The metric name * @param {Dimensions} dimensions The optional custom dimensions * @param {number} publishingIntervalInSeconds the optional publishing interval */ validateHistogramOptions: (name, dimensions, publishingIntervalInSeconds) =&gt; { module.exports.validateMetricName(name); module.exports.validateOptionalDimensions(dimensions); module.exports.validateOptionalPublishingInterval(publishingIntervalInSeconds); }, /** * Validates the create counter Options. * * @param {string} name The metric name * @param {Dimensions} dimensions The optional custom dimensions * @param {number} publishingIntervalInSeconds the optional publishing interval */ validateCounterOptions: (name, dimensions, publishingIntervalInSeconds) =&gt; { module.exports.validateMetricName(name); module.exports.validateOptionalDimensions(dimensions); module.exports.validateOptionalPublishingInterval(publishingIntervalInSeconds); }, /** * Validates the create timer Options. * * @param {string} name The metric name * @param {Dimensions} dimensions The optional custom dimensions * @param {number} publishingIntervalInSeconds the optional publishing interval */ validateTimerOptions: (name, dimensions, publishingIntervalInSeconds) =&gt; { module.exports.validateMetricName(name); module.exports.validateOptionalDimensions(dimensions); module.exports.validateOptionalPublishingInterval(publishingIntervalInSeconds); }, /** * Validates the create timer Options. * * @param {string} name The metric name * @param {Metric} metric The metric instance * @param {Dimensions} dimensions The optional custom dimensions * @param {number} publishingIntervalInSeconds the optional publishing interval */ validateRegisterOptions: (name, metric, dimensions, publishingIntervalInSeconds) =&gt; { module.exports.validateMetricName(name); // todo validate metric module.exports.validateOptionalDimensions(dimensions); module.exports.validateOptionalPublishingInterval(publishingIntervalInSeconds); }, /** * Validates the create settable gauge Options. * * @param {string} name The metric name * @param {Dimensions} dimensions The optional custom dimensions * @param {number} publishingIntervalInSeconds the optional publishing interval */ validateSettableGaugeOptions: (name, dimensions, publishingIntervalInSeconds) =&gt; { module.exports.validateMetricName(name); module.exports.validateOptionalDimensions(dimensions); module.exports.validateOptionalPublishingInterval(publishingIntervalInSeconds); }, /** * Validates the metric name. * * @param name The metric name. */ validateMetricName: name =&gt; { const type = typeof name; if (type !== 'string') { throw new Error(`options.name is a required option and must be of type string, actual type: ${type}`); } }, /** * Validates the provided callback. * * @param callback The provided callback for a gauge. */ validateNumberReturningCallback: callback =&gt; { const type = typeof callback; if (type !== 'function') { throw new Error(`options.callback is a required option and must be function, actual type: ${type}`); } const callbackType = typeof callback(); if (callbackType !== 'number') { throw new Error(`options.callback must return a number, actual return type: ${callbackType}`); } }, /** * Validates a set of optional dimensions * @param dimensionsOptional */ validateOptionalDimensions: dimensionsOptional =&gt; { Optional.ofNullable(dimensionsOptional).ifPresent(dimensions =&gt; { const type = typeof dimensions; if (type !== 'object') { throw new Error(`options.dimensions should be an object, actual type: ${type}`); } Object.keys(dimensions).forEach(key =&gt; { const valueType = typeof dimensions[key]; if (valueType !== 'string') { throw new Error(`options.dimensions.${key} should be of type string, actual type: ${type}`); } }); }); }, /** * Validates an optional logger instance * @param loggerOptional */ validateOptionalLogger: loggerOptional =&gt; { Optional.ofNullable(loggerOptional).ifPresent(logger =&gt; { if ( typeof logger.trace !== 'function' || typeof logger.debug !== 'function' || typeof logger.info !== 'function' || typeof logger.warn !== 'function' || typeof logger.error !== 'function' ) { throw new Error( 'The logger that was passed in does not support all required ' + 'logging methods, expected object to have functions trace, debug, info, warn, and error with ' + 'method signatures (...msgs) =&gt; {}' ); } }); }, /** * Validates the optional publishing interval. * * @param publishingIntervalInSecondsOptional The optional publishing interval. */ validateOptionalPublishingInterval: publishingIntervalInSecondsOptional =&gt; { Optional.ofNullable(publishingIntervalInSecondsOptional).ifPresent(publishingIntervalInSeconds =&gt; { const type = typeof publishingIntervalInSeconds; if (type !== 'number') { throw new Error(`options.publishingIntervalInSeconds must be of type number, actual type: ${type}`); } }); }, validateReporterParameters: options =&gt; { module.exports.validateOptionalDimensions(options.defaultDimensions); module.exports.validateOptionalLogger(options.logger); }, /** * Validates that a valid Reporter object has been supplied */ validateReporterInstance: reporter =&gt; { // TODO implement }, /** * Validates the input parameters for a {@link SelfReportingMetricsRegistry} * @param reporter * @param logger */ validateSelfReportingMetricsRegistryParameters: (reporter, logger) =&gt; { // TODO implement } }; Ã— Search results Close "},"measured-core_lib_index.js.html":{"id":"measured-core_lib_index.js.html","title":"Source: measured-core/lib/index.js","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterReporterSelfReportingMetricsRegistrySettableGaugeSignalFxMetricsReporterSignalFxSelfReportingMetricsRegistryStopwatchTimer Interfaces MetricMetricTypes Tutorials SignalFx Express Full End to End Example Global Global Source: measured-core/lib/index.js const Collection = require('./Collection'); const Counter = require('./metrics/Counter'); const Gauge = require('./metrics/Gauge'); const SettableGauge = require('./metrics/SettableGauge'); const Histogram = require('./metrics/Histogram'); const Meter = require('./metrics/Meter'); const NoOpMeter = require('./metrics/NoOpMeter'); const Timer = require('./metrics/Timer'); const BinaryHeap = require('./util/BinaryHeap'); const ExponentiallyDecayingSample = require('./util/ExponentiallyDecayingSample'); const ExponentiallyMovingWeightedAverage = require('./util/ExponentiallyMovingWeightedAverage'); const Stopwatch = require('./util/Stopwatch'); const units = require('./util/units'); const { MetricTypes } = require('./metrics/Metric'); /** * The main measured module that is referenced when require('measured') is used. * @module measured-core */ module.exports = { /** * See {@link Collection} * @type {Collection} * @augments Collection */ Collection, /** * See {@link Counter} * @type {Counter} */ Counter, /** * See {@link Gauge} * @type {Gauge} */ Gauge, /** * See {@link SettableGauge} * @type {SettableGauge} */ SettableGauge, /** * See {@link Histogram} * @type {Histogram} */ Histogram, /** * See {@link Meter} * @type {Meter} */ Meter, /** * See {@link NoOpMeter} * @type {NoOpMeter} */ NoOpMeter, /** * See {@link Timer} * @type {Timer} */ Timer, /** * See {@link BinaryHeap} * @type {BinaryHeap} */ BinaryHeap, /** * See {@link ExponentiallyDecayingSample} * @type {ExponentiallyDecayingSample} */ ExponentiallyDecayingSample, /** * See {@link ExponentiallyMovingWeightedAverage} * @type {ExponentiallyMovingWeightedAverage} */ ExponentiallyMovingWeightedAverage, /** * See {@link Stopwatch} * @type {Stopwatch} */ Stopwatch, /** * See {@link MetricTypes} * @type {MetricTypes} */ MetricTypes, /** * See {@link units} * @type {units} */ units, /** * Creates a named collection. See {@Collection} for more details * * @param name The name for the collection * @return {Collection} */ createCollection: name =&gt; { return new Collection(name); } }; Ã— Search results Close "},"measured-signalfx-reporter_lib_validators_inputValidators.js.html":{"id":"measured-signalfx-reporter_lib_validators_inputValidators.js.html","title":"Source: measured-signalfx-reporter/lib/validators/inputValidators.js","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterReporterSelfReportingMetricsRegistrySettableGaugeSignalFxMetricsReporterSignalFxSelfReportingMetricsRegistryStopwatchTimer Interfaces MetricMetricTypes Tutorials SignalFx Express Full End to End Example Global Global Source: measured-signalfx-reporter/lib/validators/inputValidators.js /** * Validation functions for validating public input * @module SignalFxReporterInputValidators * @private */ module.exports = { /** * Validates that the object supplied for the sfx client at least has a send function * @param signalFxClient */ validateSignalFxClient: signalFxClient =&gt; { if (signalFxClient === undefined) { throw new Error('signalFxClient was undefined when it is required'); } if (typeof signalFxClient.send !== 'function' || signalFxClient.length &lt; 1) { throw new Error('signalFxClient must implement send(data: any)'); } } }; Ã— Search results Close "},"measured-core_lib_util_units.js.html":{"id":"measured-core_lib_util_units.js.html","title":"Source: measured-core/lib/util/units.js","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterReporterSelfReportingMetricsRegistrySettableGaugeSignalFxMetricsReporterSignalFxSelfReportingMetricsRegistryStopwatchTimer Interfaces MetricMetricTypes Tutorials SignalFx Express Full End to End Example Global Global Source: measured-core/lib/util/units.js const NANOSECONDS = 1 / (1000 * 1000); const MICROSECONDS = 1 / 1000; const MILLISECONDS = 1; const SECONDS = 1000 * MILLISECONDS; const MINUTES = 60 * SECONDS; const HOURS = 60 * MINUTES; const DAYS = 24 * HOURS; /** * Time units, as found in Java: {@link http://download.oracle.com/javase/6/docs/api/java/util/concurrent/TimeUnit.html} * @module units * @example * const TimeUnit = require('measured-core').unit * setTimeout(() =&gt; {}, 5 * TimeUnit.MINUTES) */ module.exports = { /** * nanoseconds in milliseconds * @type {number} */ NANOSECONDS, /** * microseconds in milliseconds * @type {number} */ MICROSECONDS, /** * milliseconds in milliseconds * @type {number} */ MILLISECONDS, /** * seconds in milliseconds * @type {number} */ SECONDS, /** * minutes in milliseconds * @type {number} */ MINUTES, /** * hours in milliseconds * @type {number} */ HOURS, /** * days in milliseconds * @type {number} */ DAYS }; Ã— Search results Close "},"measured-core_lib_metrics_NoOpMeter.js.html":{"id":"measured-core_lib_metrics_NoOpMeter.js.html","title":"Source: measured-core/lib/metrics/NoOpMeter.js","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterReporterSelfReportingMetricsRegistrySettableGaugeSignalFxMetricsReporterSignalFxSelfReportingMetricsRegistryStopwatchTimer Interfaces MetricMetricTypes Tutorials SignalFx Express Full End to End Example Global Global Source: measured-core/lib/metrics/NoOpMeter.js const { MetricTypes } = require('./Metric'); /** * A No-Op Impl of Meter that can be used with a timer, to only create histogram data. * This is useful for some time series aggregators that can calculate rates for you just off of sent count. * * @implements {Metric} * @example * const { NoOpMeter, Timer } = require('measured') * const meter = new NoOpMeter(); * const timer = new Timer({meter: meter}); * ... * // do some stuff with the timer and stopwatch api * ... */ // eslint-disable-next-line padded-blocks class NoOpMeter { /** * No-Op impl * @param {number} n Number of events to mark. */ // eslint-disable-next-line no-unused-vars mark(n) {} /** * No-Op impl */ start() {} /** * No-Op impl */ end() {} /** * No-Op impl */ ref() {} /** * No-Op impl */ unref() {} /** * No-Op impl */ reset() {} /** * No-Op impl */ meanRate() {} /** * No-Op impl */ currentRate() {} /** * Returns an empty object * @return {{}} */ toJSON() { return {}; } /** * The type of the Metric Impl. {@link MetricTypes}. * @return {string} The type of the Metric Impl. */ getType() { return MetricTypes.METER; } } module.exports = NoOpMeter; Ã— Search results Close "},"measured-reporting_lib_reporters_Reporter.js.html":{"id":"measured-reporting_lib_reporters_Reporter.js.html","title":"Source: measured-reporting/lib/reporters/Reporter.js","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterReporterSelfReportingMetricsRegistrySettableGaugeSignalFxMetricsReporterSignalFxSelfReportingMetricsRegistryStopwatchTimer Interfaces MetricMetricTypes Tutorials SignalFx Express Full End to End Example Global Global Source: measured-reporting/lib/reporters/Reporter.js const bunyan = require('bunyan'); const Optional = require('optional-js'); const { validateReporterParameters } = require('../validators/inputValidators'); const DEFAULT_REPORTING_INTERVAL_IN_SECONDS = 10; /** * The abstract reporter that specific implementations can extend to create a Self Reporting Metrics Registry Reporter. * * {@link SelfReportingMetricsRegistry} * @abstract */ class Reporter { /** * @param {ReporterOptions} [options] The optional params to supply when creating a reporter. */ constructor(options) { if (this.constructor === Reporter) { throw new TypeError(&quot;Can't instantiate abstract class!&quot;); } options = options || {}; validateReporterParameters(options); /** * Map of intervals to metric keys, this will be used to look up what metrics should be reported at a given interval. * @type {Object.&lt;number, Set&lt;string&gt;&gt;} * @private */ this._intervalToMetric = {}; this._intervals = []; /** * Map of default dimensions, that should be sent with every metric * @type {Dimensions} * @protected */ this._defaultDimensions = options.defaultDimensions || {}; /** * Loggers to use, defaults to a new bunyan logger if nothing is supplied in options * @type {Logger} * @protected */ this._log = options.logger || bunyan.createLogger({ name: 'Reporter', level: options.logLevel || 'info' }); /** * the default interval a number in seconds. * @type {number} * @protected */ this._defaultReportingIntervalInSeconds = options.defaultReportingIntervalInSeconds || DEFAULT_REPORTING_INTERVAL_IN_SECONDS; } /** * Sets the registry, this must be called before reportMetricOnInterval. * * @param {DimensionAwareMetricsRegistry} registry */ setRegistry(registry) { this._registry = registry; } /** * Informs the reporter to report a metric on a given interval in seconds. * * @param {string} metricKey The metric key for the metric in the metric registry. * @param {number} intervalInSeconds The interval in seconds to report the metric on. */ reportMetricOnInterval(metricKey, intervalInSeconds) { intervalInSeconds = intervalInSeconds || this._defaultReportingIntervalInSeconds; if (!this._registry) { throw new Error( 'You must call setRegistry(registry) before telling a Reporter to report a metric on an interval.' ); } if (Object.prototype.hasOwnProperty.call(this._intervalToMetric, intervalInSeconds)) { this._intervalToMetric[intervalInSeconds].add(metricKey); } else { this._intervalToMetric[intervalInSeconds] = new Set([metricKey]); this._reportMetricsWithInterval(intervalInSeconds); this._createIntervalCallback(intervalInSeconds); } } /** * Creates the timed callback loop for the given interval. * * @param {number} intervalInSeconds the interval in seconds for the timeout callback * @private */ _createIntervalCallback(intervalInSeconds) { this._log.debug(`_createIntervalCallback() called with intervalInSeconds: ${intervalInSeconds}`); this._intervals.push( setInterval(() =&gt; { this._reportMetricsWithInterval(intervalInSeconds); }, intervalInSeconds * 1000) ); } /** * Gathers all the metrics that have been registered to report on the given interval. * * @param {number} interval The interval to look up what metrics to report * @private */ _reportMetricsWithInterval(interval) { this._log.debug(`_reportMetricsWithInterval() called with intervalInSeconds: ${interval}`); try { Optional.of(this._intervalToMetric[interval]).ifPresent(metrics =&gt; { const metricsToSend = []; metrics.forEach(metricKey =&gt; { metricsToSend.push(this._registry.getMetricWrapperByKey(metricKey)); }); this._reportMetrics(metricsToSend); }); } catch (error) { this._log.error('Failed to send metrics to signal fx', error); } } /** * This method gets called with an array of {@link MetricWrapper} on an interval, when metrics should be reported. * * This is the main method that needs to get implemented when created an aggregator specific reporter. * * @param {MetricWrapper[]} metrics The array of metrics to report. * @protected * @abstract */ _reportMetrics(metrics) { throw new TypeError('Abstract method _reportMetrics(metrics) must be implemented in implementation class'); } /** * * @param {MetricWrapper} metric The Wrapped Metric Object. * @return {Dimensions} The left merged default dimensions with the metric specific dimensions * @private */ _getDimensions(metric) { return Object.assign({}, this._defaultDimensions, metric.dimensions); } /** * Clears the intervals that are running to report metrics at an interval, and resets the state. */ shutdown() { this._intervals.forEach(interval =&gt; clearInterval(interval)); this._intervals = []; this._intervalToMetric = {}; } } /** * Options for creating a {@link Reporter} * @interface ReporterOptions * @typedef ReporterOptions * @type {Object} * @property {Dimensions} defaultDimensions A dictionary of dimensions to include with every metric reported * @property {Logger} logger The logger to use, if not supplied a new Buynan logger will be created * @property {string} logLevel The log level to use with the created Bunyan logger if you didn't supply your own logger. * @property {number} defaultReportingIntervalInSeconds The default reporting interval to use if non is supplied when registering a metric, defaults to 10 seconds. */ module.exports = Reporter; Ã— Search results Close "},"measured-reporting_lib_registries_SelfReportingMetricsRegistry.js.html":{"id":"measured-reporting_lib_registries_SelfReportingMetricsRegistry.js.html","title":"Source: measured-reporting/lib/registries/SelfReportingMetricsRegistry.js","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterReporterSelfReportingMetricsRegistrySettableGaugeSignalFxMetricsReporterSignalFxSelfReportingMetricsRegistryStopwatchTimer Interfaces MetricMetricTypes Tutorials SignalFx Express Full End to End Example Global Global Source: measured-reporting/lib/registries/SelfReportingMetricsRegistry.js const bunyan = require('bunyan'); const { SettableGauge, Gauge, Timer, Counter, Meter, Histogram } = require('measured-core'); const DimensionAwareMetricsRegistry = require('./DimensionAwareMetricsRegistry'); const { validateSelfReportingMetricsRegistryParameters, validateRegisterOptions, validateGaugeOptions, validateCounterOptions, validateHistogramOptions, validateTimerOptions, validateSettableGaugeOptions } = require('../validators/inputValidators'); /** * A dimensional aware self-reporting metrics registry */ class SelfReportingMetricsRegistry { /** * @param {Reporter} reporter The Metrics Reporter * @param {SelfReportingMetricsRegistryOptions} [options] Configurable options for the Self Reporting Metrics Registry */ constructor(reporter, options) { options = options || {}; validateSelfReportingMetricsRegistryParameters(reporter, options.logger); /** * @type {Reporter} * @protected */ this._reporter = reporter; /** * @type {DimensionAwareMetricsRegistry} * @protected */ this._registry = options.registry || new DimensionAwareMetricsRegistry(); this._reporter.setRegistry(this._registry); /** * Loggers to use, defaults to a new bunyan logger if nothing is supplied in options * @type {Logger} * @protected */ this._log = options.logger || bunyan.createLogger({ name: 'SelfReportingMetricsRegistry', level: options.logLevel || 'info' }); } /** * Registers a manually created Metric. * * @param {string} name The Metric name * @param {Metric} metric The {@link Metric} to register * @param {Dimensions} [dimensions] any custom {@link Dimensions} for the Metric * @param {number} [publishingIntervalInSeconds] a optional custom publishing interval * @example * const settableGauge = new SettableGauge(5); * // register the gauge and have it report to every 10 seconds * registry.register('my-gauge', settableGauge, {}, 10); * interval(() =&gt; { * // such as cpu % used * determineAValueThatCannotBeSync((value) =&gt; { * settableGauge.update(value); * }) * }, 10000) */ register(name, metric, dimensions, publishingIntervalInSeconds) { validateRegisterOptions(name, metric, dimensions, publishingIntervalInSeconds); if (this._registry.hasMetric(name, dimensions)) { throw new Error( `Metric with name: ${name} and dimensions: ${JSON.stringify(dimensions)} has already been registered` ); } else { const key = this._registry.putMetric(name, metric, dimensions); this._reporter.reportMetricOnInterval(key, publishingIntervalInSeconds); } return metric; } /** * Creates a {@link Gauge} or gets the existing Gauge for a given name and dimension combo * * @param {string} name The Metric name * @param {function} callback The callback that will return a value to report to signal fx * @param {Dimensions} [dimensions] any custom {@link Dimensions} for the Metric * @param {number} [publishingIntervalInSeconds] a optional custom publishing interval * @return {Gauge} * @example * // https://nodejs.org/api/process.html#process_process_memoryusage * // Report heap total and heap used at the default interval * registry.getOrCreateGauge( * 'process-memory-heap-total', * () =&gt; { * return process.memoryUsage().heapTotal * } * ); * registry.getOrCreateGauge( * 'process-memory-heap-used', * () =&gt; { * return process.memoryUsage().heapUsed * } * ) */ getOrCreateGauge(name, callback, dimensions, publishingIntervalInSeconds) { validateGaugeOptions(name, callback, dimensions, publishingIntervalInSeconds); let gauge; if (this._registry.hasMetric(name, dimensions)) { gauge = this._registry.getMetric(name, dimensions); } else { gauge = new Gauge(callback); const key = this._registry.putMetric(name, gauge, dimensions); this._reporter.reportMetricOnInterval(key, publishingIntervalInSeconds); } return gauge; } /** * Creates a {@link Histogram} or gets the existing Histogram for a given name and dimension combo * * @param {string} name The Metric name * @param {Dimensions} dimensions any custom {@link Dimensions} for the Metric * @param {number} publishingIntervalInSeconds a optional custom publishing interval * @return {Histogram} */ getOrCreateHistogram(name, dimensions, publishingIntervalInSeconds) { validateHistogramOptions(name, dimensions, publishingIntervalInSeconds); let histogram; if (this._registry.hasMetric(name, dimensions)) { histogram = this._registry.getMetric(name, dimensions); } else { histogram = new Histogram(); const key = this._registry.putMetric(name, histogram, dimensions); this._reporter.reportMetricOnInterval(key, publishingIntervalInSeconds); } return histogram; } /** * Creates a {@link Meter} or gets the existing Meter for a given name and dimension combo * * @param {string} name The Metric name * @param {Dimensions} dimensions any custom {@link Dimensions} for the Metric * @param {number} publishingIntervalInSeconds a optional custom publishing interval * @return {Meter} */ getOrCreateMeter(name, dimensions, publishingIntervalInSeconds) { // todo validate options let meter; if (this._registry.hasMetric(name, dimensions)) { meter = this._registry.getMetric(name, dimensions); } else { meter = new Meter(); const key = this._registry.putMetric(name, meter, dimensions); this._reporter.reportMetricOnInterval(key, publishingIntervalInSeconds); } return meter; } /** * Creates a {@link Counter} or gets the existing Counter for a given name and dimension combo * * @param {string} name The Metric name * @param {Dimensions} dimensions any custom {@link Dimensions} for the Metric * @param {number} publishingIntervalInSeconds a optional custom publishing interval * @return {Counter} */ getOrCreateCounter(name, dimensions, publishingIntervalInSeconds) { validateCounterOptions(name, dimensions, publishingIntervalInSeconds); let counter; if (this._registry.hasMetric(name, dimensions)) { counter = this._registry.getMetric(name, dimensions); } else { counter = new Counter(); const key = this._registry.putMetric(name, counter, dimensions); this._reporter.reportMetricOnInterval(key, publishingIntervalInSeconds); } return counter; } /** * Creates a {@link Timer} or gets the existing Timer for a given name and dimension combo. * * @param {string} name The Metric name * @param {Dimensions} dimensions any custom {@link Dimensions} for the Metric * @param {number} publishingIntervalInSeconds a optional custom publishing interval * @return {Timer} */ getOrCreateTimer(name, dimensions, publishingIntervalInSeconds) { validateTimerOptions(name, dimensions, publishingIntervalInSeconds); let timer; if (this._registry.hasMetric(name, dimensions)) { timer = this._registry.getMetric(name, dimensions); } else { timer = new Timer(); const key = this._registry.putMetric(name, timer, dimensions); this._reporter.reportMetricOnInterval(key, publishingIntervalInSeconds); } return timer; } /** * Creates a {@link SettableGauge} or gets the existing SettableGauge for a given name and dimension combo. * * @param name * @param dimensions * @param publishingIntervalInSeconds */ getOrCreateSettableGauge(name, dimensions, publishingIntervalInSeconds) { validateSettableGaugeOptions(name, dimensions, publishingIntervalInSeconds); let settableGauge; if (this._registry.hasMetric(name, dimensions)) { settableGauge = this._registry.getMetric(name, dimensions); } else { settableGauge = new SettableGauge(); const key = this._registry.putMetric(name, settableGauge, dimensions); this._reporter.reportMetricOnInterval(key, publishingIntervalInSeconds); } return settableGauge; } /** * Calls end on all metrics in the registry that support end() and calls end on the reporter */ shutdown() { // shutdown the reporter this._reporter.shutdown(); // shutdown any metrics that have an end method this._registry.allKeys().forEach(key =&gt; { const metricWrapper = this._registry.getMetricWrapperByKey(key); if (metricWrapper.metric.end) { metricWrapper.metric.end(); } }); } } module.exports = SelfReportingMetricsRegistry; /** * Configurable options for the Self Reporting Metrics Registry * * @interface SelfReportingMetricsRegistryOptions * @typedef SelfReportingMetricsRegistryOptions * @property {Logger} logger the Logger to use * @property {string} logLevel The Log level to use if defaulting to included logger * @property {DimensionAwareMetricsRegistry} registry The registry to use, defaults to new DimensionAwareMetricsRegistry */ Ã— Search results Close "},"measured-core_lib_metrics_SettableGauge.js.html":{"id":"measured-core_lib_metrics_SettableGauge.js.html","title":"Source: measured-core/lib/metrics/SettableGauge.js","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterReporterSelfReportingMetricsRegistrySettableGaugeSignalFxMetricsReporterSignalFxSelfReportingMetricsRegistryStopwatchTimer Interfaces MetricMetricTypes Tutorials SignalFx Express Full End to End Example Global Global Source: measured-core/lib/metrics/SettableGauge.js const { MetricTypes } = require('./Metric'); /** * Works like a {@link Gauge}, but rather than getting its value from a callback, the value * is set when needed. This can be useful for setting a gauges value for asynchronous operations. * @implements {Metric} * @example * const settableGauge = new SettableGauge(); * // Update the settable gauge ever 10'ish seconds * setInterval(() =&gt; { * calculateSomethingAsync().then((value) =&gt; { * settableGauge.setValue(value); * }); * }, 10000); */ class SettableGauge { /** * @param {SettableGaugeProperties} [options] See {@link SettableGaugeProperties}. */ constructor(options) { options = options || {}; this._value = options.initialValue || 0; } setValue(value) { this._value = value; } /** * @return {number} Settable Gauges directly return there current value. */ toJSON() { return this._value; } /** * The type of the Metric Impl. {@link MetricTypes}. * @return {string} The type of the Metric Impl. */ getType() { return MetricTypes.GAUGE; } } module.exports = SettableGauge; /** * Properties that can be supplied to the constructor of a {@link Counter} * * @interface SettableGaugeProperties * @typedef SettableGaugeProperties * @type {Object} * @property {number} initialValue An initial value to use for this settable gauge. Defaults to 0. * @example * // Creates a Gauge that with an initial value of 500. * const settableGauge = new SettableGauge({ initialValue: 500 }) * */ Ã— Search results Close "},"measured-signalfx-reporter_lib_registries_SignalFxSelfReportingMetricsRegistry.js.html":{"id":"measured-signalfx-reporter_lib_registries_SignalFxSelfReportingMetricsRegistry.js.html","title":"Source: measured-signalfx-reporter/lib/registries/SignalFxSelfReportingMetricsRegistry.js","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterReporterSelfReportingMetricsRegistrySettableGaugeSignalFxMetricsReporterSignalFxSelfReportingMetricsRegistryStopwatchTimer Interfaces MetricMetricTypes Tutorials SignalFx Express Full End to End Example Global Global Source: measured-signalfx-reporter/lib/registries/SignalFxSelfReportingMetricsRegistry.js const { NoOpMeter, Timer } = require('measured-core'); const { SelfReportingMetricsRegistry } = require('measured-reporting'); const { validateTimerOptions } = require('measured-reporting').inputValidators; /** * A SignalFx Self Reporting Metrics Registry that disallows the use of meters as they waste DPM and accomplished using a counter. * @extends {SelfReportingMetricsRegistry} */ class SignalFxSelfReportingMetricsRegistry extends SelfReportingMetricsRegistry { /** * @param {Reporter} reporter The Metrics Reporter * @param {SelfReportingMetricsRegistryOptions} [options] Configurable options for the Self Reporting Metrics Registry */ constructor(reporter, options) { super(reporter, options) } /** * Creates a {@link Timer} or get the existing Timer for a given name and dimension combo with a NoOpMeter * * @param {string} name The Metric name * @param {Dimensions} dimensions any custom {@link Dimensions} for the Metric * @param {number} publishingIntervalInSeconds a optional custom publishing interval * @return {Timer} */ getOrCreateTimer(name, dimensions, publishingIntervalInSeconds) { validateTimerOptions(name, dimensions, publishingIntervalInSeconds); let timer; if (this._registry.hasMetric(name, dimensions)) { timer = this._registry.getMetric(name, dimensions); } else { timer = new Timer({ meter: new NoOpMeter() }); const key = this._registry.putMetric(name, timer, dimensions); this._reporter.reportMetricOnInterval(key, publishingIntervalInSeconds); } return timer; } /** * You should use counters and implements meter functionality in your Dashboard. * @param {string} name The Metric name * @param {Dimensions} dimensions any custom {@link Dimensions} for the Metric * @param {number} publishingIntervalInSeconds a optional custom publishing interval * @return {NoOpMeter|*} */ getOrCreateMeter(name, dimensions, publishingIntervalInSeconds) { this._log.error( 'Meters will not get reported using the SignalFx reporter as they waste DPM, please use a counter instead' ); return new NoOpMeter(); } } module.exports = SignalFxSelfReportingMetricsRegistry; Ã— Search results Close "},"measured-core_lib_util_Stopwatch.js.html":{"id":"measured-core_lib_util_Stopwatch.js.html","title":"Source: measured-core/lib/util/Stopwatch.js","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterReporterSelfReportingMetricsRegistrySettableGaugeSignalFxMetricsReporterSignalFxSelfReportingMetricsRegistryStopwatchTimer Interfaces MetricMetricTypes Tutorials SignalFx Express Full End to End Example Global Global Source: measured-core/lib/util/Stopwatch.js const { EventEmitter } = require('events'); /** * A simple object for tracking elapsed time * * @extends {EventEmitter} */ class Stopwatch extends EventEmitter { /** * Creates a started Stopwatch * @param {StopwatchProperties} options See {@link StopwatchProperties} */ constructor(options) { super(); options = options || {}; EventEmitter.call(this); if (options.getTime) { this._getTime = options.getTime; } this._start = this._getTime(); this._ended = false; } /** * Called to mark the end of the timer task * @return {number} the total execution time */ end() { if (this._ended) { return null; } this._ended = true; const elapsed = this._getTime() - this._start; this.emit('end', elapsed); return elapsed; } _getTime() { if (!process.hrtime) { return Date.now(); } const hrtime = process.hrtime(); return hrtime[0] * 1000 + hrtime[1] / (1000 * 1000); } } module.exports = Stopwatch; /** * @interface StopwatchProperties * @typedef StopwatchProperties * @type {Object} * @property {function} getTime optional function override for supplying time., defaults to new Date() / process.hrt() */ Ã— Search results Close "},"measured-core_lib_metrics_Timer.js.html":{"id":"measured-core_lib_metrics_Timer.js.html","title":"Source: measured-core/lib/metrics/Timer.js","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterReporterSelfReportingMetricsRegistrySettableGaugeSignalFxMetricsReporterSignalFxSelfReportingMetricsRegistryStopwatchTimer Interfaces MetricMetricTypes Tutorials SignalFx Express Full End to End Example Global Global Source: measured-core/lib/metrics/Timer.js const { MetricTypes } = require('./Metric'); const Histogram = require('./Histogram'); const Meter = require('./Meter'); const Stopwatch = require('../util/Stopwatch'); /** * * Timers are a combination of Meters and Histograms. They measure the rate as well as distribution of scalar events. * &lt;p&gt; * Since they are frequently used for tracking how long certain things take, they expose an API for that: See example 1. * &lt;p&gt; * But you can also use them as generic histograms that also track the rate of events: See example 2. * * @example * var Measured = require('measured') * var timer = new Measured.Timer(); * http.createServer(function(req, res) { * var stopwatch = timer.start(); * req.on('end', function() { * stopwatch.end(); * }); * }); * * * @example * var Measured = require('measured') * var timer = new Measured.Timer(); * http.createServer(function(req, res) { * if (req.headers['content-length']) { * timer.update(parseInt(req.headers['content-length'], 10)); * } * }); * * @implements {Metric} */ class Timer { /** * @param {TimerProperties} [properties] See {@link TimerProperties}. */ constructor(properties) { properties = properties || {}; this._meter = properties.meter || new Meter({}); this._histogram = properties.histogram || new Histogram({}); this._getTime = properties.getTime; } /** * @return {Stopwatch} Returns a Stopwatch that has been started. */ start() { const self = this; const watch = new Stopwatch({ getTime: this._getTime }); watch.once('end', elapsed =&gt; { self.update(elapsed); }); return watch; } /** * Updates the internal histogram with value and marks one event on the internal meter. * @param {number} value */ update(value) { this._meter.mark(); this._histogram.update(value); } /** * Resets all values. Timers initialized with custom options will be reset to the default settings. */ reset() { this._meter.reset(); this._histogram.reset(); } end() { this._meter.end(); } /** * Refs the backing timer again. Idempotent. */ ref() { this._meter.ref(); } /** * Unrefs the backing timer. The meter will not keep the event loop alive. Idempotent. */ unref() { this._meter.unref(); } /** * toJSON output: * * &lt;li&gt; meter: See &lt;a href=&quot;#meter&quot;&gt;Meter&lt;/a&gt;#toJSON output docs above.&lt;/li&gt; * &lt;li&gt; histogram: See &lt;a href=&quot;#histogram&quot;&gt;Histogram&lt;/a&gt;#toJSON output docs above.&lt;/a&gt;&lt;/li&gt; * * @return {any} */ toJSON() { return { meter: this._meter.toJSON(), histogram: this._histogram.toJSON() }; } /** * The type of the Metric Impl. {@link MetricTypes}. * @return {string} The type of the Metric Impl. */ getType() { return MetricTypes.TIMER; } } module.exports = Timer; /** * @interface TimerProperties * @typedef TimerProperties * @type {Object} * @property {Meter} meter The internal meter to use. Defaults to a new {@link Meter}. * @property {Histogram} histogram The internal histogram to use. Defaults to a new {@link Histogram}. * @property {function} getTime optional function override for supplying time to the {@link Stopwatch} */ Ã— Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterReporterSelfReportingMetricsRegistrySettableGaugeSignalFxMetricsReporterSignalFxSelfReportingMetricsRegistryStopwatchTimer Interfaces MetricMetricTypes Tutorials SignalFx Express Full End to End Example Global Global Global Type Definitions CounterProperties Properties that can be supplied to the constructor of a Counter Type: Object Properties: Name Type Description count number An initial count for the counter. Defaults to 0. Source: measured-core/lib/metrics/Counter.js, line 69 Example // Creates a counter that starts at 5. const counter = new Counter({ count: 5 }) Dimensions A Dictionary of string, string key value pairs Type: Object.&lt;string, string&gt; Source: measured-reporting/lib/@types/types.js, line 12 Example { path: &quot;/api/foo&quot; method: &quot;GET&quot; statusCode: &quot;200&quot; } HistogramData The data returned from Histogram::toJSON() Type: object Properties: Name Type Description min number | null The lowest observed value. max number | null The highest observed value. sum number | null The sum of all observed values. variance number | null The variance of all observed values. mean number | null The average of all observed values. stddev number | null The stddev of all observed values. count number The number of observed values. median number 50% of all values in the resevoir are at or below this value. p75 number See median, 75% percentile. p95 number See median, 95% percentile. p99 number See median, 99% percentile. p999 number See median, 99.9% percentile. Source: measured-core/lib/metrics/Histogram.js, line 239 HistogramProperties Properties to create a Histogram with. Type: Object Properties: Name Type Description sample object The sample reservoir to use. Defaults to an ExponentiallyDecayingSample. Source: measured-core/lib/metrics/Histogram.js, line 230 MeterData The data returned from Meter::toJSON() Type: object Properties: Name Type Description mean number The average rate since the meter was started. count number The total of all values added to the meter. currentRate number The rate of the meter since the last toJSON() call. 1MinuteRate number The rate of the meter biased towards the last 1 minute. 5MinuteRate number The rate of the meter biased towards the last 5 minutes. 15MinuteRate number The rate of the meter biased towards the last 15 minutes. Source: measured-core/lib/metrics/Meter.js, line 171 MeterProperties Type: Object Properties: Name Type Description rateUnit number The rate unit. Defaults to 1000 (1 sec). tickInterval number The interval in which the averages are updated. Defaults to 5000 (5 sec). Source: measured-core/lib/metrics/Meter.js, line 160 Example const meter = new Meter({ rateUnit: 1000, tickInterval: 5000}) MetricValueTypeWrapper Wrapper object to wrap metric value and SFX metadata needed to send metric value to SFX data ingestion. Type: Object Properties: Name Type Description metric string The metric name to report to SignalFx value number the value to report to SignalFx type string The mapped SignalFx metric type Source: measured-signalfx-reporter/lib/reporter/SignalFxMetricsReporter.js, line 212 MetricWrapper A wrapper object around a Metric, Dimensions and the metric name Type: Object Properties: Name Type Description name string The supplied name of the Metric metric Metric The Metric object dimensions Dimensions The Dimensions for the given Metric Source: measured-reporting/lib/@types/types.js, line 1 ReporterOptions Options for creating a Reporter Type: Object Properties: Name Type Description defaultDimensions Dimensions A dictionary of dimensions to include with every metric reported logger Logger The logger to use, if not supplied a new Buynan logger will be created logLevel string The log level to use with the created Bunyan logger if you didn't supply your own logger. defaultReportingIntervalInSeconds number The default reporting interval to use if non is supplied when registering a metric, defaults to 10 seconds. Source: measured-reporting/lib/reporters/Reporter.js, line 160 SelfReportingMetricsRegistryOptions Configurable options for the Self Reporting Metrics Registry Properties: Name Type Description logger Logger the Logger to use logLevel string The Log level to use if defaulting to included logger registry DimensionAwareMetricsRegistry The registry to use, defaults to new DimensionAwareMetricsRegistry Source: measured-reporting/lib/registries/SelfReportingMetricsRegistry.js, line 257 SettableGaugeProperties Properties that can be supplied to the constructor of a Counter Type: Object Properties: Name Type Description initialValue number An initial value to use for this settable gauge. Defaults to 0. Source: measured-core/lib/metrics/SettableGauge.js, line 47 Example // Creates a Gauge that with an initial value of 500. const settableGauge = new SettableGauge({ initialValue: 500 }) StopwatchProperties Type: Object Properties: Name Type Description getTime function optional function override for supplying time., defaults to new Date() / process.hrt() Source: measured-core/lib/util/Stopwatch.js, line 53 TimerProperties Type: Object Properties: Name Type Description meter Meter The internal meter to use. Defaults to a new Meter. histogram Histogram The internal histogram to use. Defaults to a new Histogram. getTime function optional function override for supplying time to the Stopwatch Source: measured-core/lib/metrics/Timer.js, line 123 Ã— Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterReporterSelfReportingMetricsRegistrySettableGaugeSignalFxMetricsReporterSignalFxSelfReportingMetricsRegistryStopwatchTimer Interfaces MetricMetricTypes Tutorials SignalFx Express Full End to End Example Global Global Modules Classes BinaryHeap Collection Counter ExponentiallyDecayingSample ExponentiallyMovingWeightedAverage Gauge Histogram Meter NoOpMeter Reporter SelfReportingMetricsRegistry SettableGauge SignalFxMetricsReporter SignalFxSelfReportingMetricsRegistry Stopwatch Timer Ã— Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterReporterSelfReportingMetricsRegistrySettableGaugeSignalFxMetricsReporterSignalFxSelfReportingMetricsRegistryStopwatchTimer Interfaces MetricMetricTypes Tutorials SignalFx Express Full End to End Example Global Global Classes Classes BinaryHeap Collection Counter ExponentiallyDecayingSample ExponentiallyMovingWeightedAverage Gauge Histogram Meter NoOpMeter Reporter SelfReportingMetricsRegistry SettableGauge SignalFxMetricsReporter SignalFxSelfReportingMetricsRegistry Stopwatch Timer Ã— Search results Close "},"interfaces.list.html":{"id":"interfaces.list.html","title":"Interfaces","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterReporterSelfReportingMetricsRegistrySettableGaugeSignalFxMetricsReporterSignalFxSelfReportingMetricsRegistryStopwatchTimer Interfaces MetricMetricTypes Tutorials SignalFx Express Full End to End Example Global Global Interfaces Classes BinaryHeap Collection Counter ExponentiallyDecayingSample ExponentiallyMovingWeightedAverage Gauge Histogram Meter NoOpMeter Reporter SelfReportingMetricsRegistry SettableGauge SignalFxMetricsReporter SignalFxSelfReportingMetricsRegistry Stopwatch Timer Ã— Search results Close "},"tutorials.list.html":{"id":"tutorials.list.html","title":"Tutorials","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterReporterSelfReportingMetricsRegistrySettableGaugeSignalFxMetricsReporterSignalFxSelfReportingMetricsRegistryStopwatchTimer Interfaces MetricMetricTypes Tutorials SignalFx Express Full End to End Example Global Global Tutorials Classes BinaryHeap Collection Counter ExponentiallyDecayingSample ExponentiallyMovingWeightedAverage Gauge Histogram Meter NoOpMeter Reporter SelfReportingMetricsRegistry SettableGauge SignalFxMetricsReporter SignalFxSelfReportingMetricsRegistry Stopwatch Timer Ã— Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterReporterSelfReportingMetricsRegistrySettableGaugeSignalFxMetricsReporterSignalFxSelfReportingMetricsRegistryStopwatchTimer Interfaces MetricMetricTypes Tutorials SignalFx Express Full End to End Example Global Global MeasuredNode libraries for measuring and reporting application-level metrics. Measured is heavily inspired by Coda Hale, Yammer Inc's Dropwizard Metrics Libraries Available packagesMeasured CoreThe core measured library that has the Metric interfaces and implementations. Measured ReportingThe registry and reporting library that has the classes needed to create a dimension aware, self reporting metrics registry. Measured SignalFx ReporterA reporter that can be used with measured-reporting to send metrics to SignalFx. Measured Datadog reporterNot implemented, community contribution wanted. Measured Graphite reporterNot implemented, community contribution wanted. Development and ContributingSee Development and Contributing LicenseThis project Measured and all of its modules are licensed under the MIT license. Ã— Search results Close "},"BinaryHeap.html":{"id":"BinaryHeap.html","title":"Class: BinaryHeap","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterReporterSelfReportingMetricsRegistrySettableGaugeSignalFxMetricsReporterSignalFxSelfReportingMetricsRegistryStopwatchTimer Interfaces MetricMetricTypes Tutorials SignalFx Express Full End to End Example Global Global Class: BinaryHeap BinaryHeap Based on http://en.wikipedia.org/wiki/Binary_Heapas well as http://eloquentjavascript.net/appendix2.html new BinaryHeap() Source: measured-core/lib/util/BinaryHeap.js, line 5 Methods add(elements) Add elements to the binary heap. Parameters: Name Type Argument Description elements Array.&lt;any&gt; &lt;repeatable&gt; Source: measured-core/lib/util/BinaryHeap.js, line 17 Ã— Search results Close "},"Collection.html":{"id":"Collection.html","title":"Class: Collection","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterReporterSelfReportingMetricsRegistrySettableGaugeSignalFxMetricsReporterSignalFxSelfReportingMetricsRegistryStopwatchTimer Interfaces MetricMetricTypes Tutorials SignalFx Express Full End to End Example Global Global Class: Collection Collection A Simple collection that stores names and a Metric instances with a few convenience methods forcreating / registering and then gathering all data the registered metrics. new Collection( [name]) Creates a named collection of metrics Parameters: Name Type Argument Description name string &lt;optional&gt; The name to use for this collection. Source: measured-core/lib/Collection.js, line 20 Example var { Collection } = require('measured'); const collection = new Collection('node-process-metrics'); const gauge = collection.gauge('node.process.heap_used', () =&gt; { return process.memoryUsage().heapUsed; }); Methods counter(name [, properties]) Gets or creates and registers a Counter Parameters: Name Type Argument Description name string The metric name properties CounterProperties &lt;optional&gt; See CounterProperties Source: measured-core/lib/Collection.js, line 103 Returns: Type Counter end() Calls end on all metrics in the registry that support end() Source: measured-core/lib/Collection.js, line 244 gauge(name, readFn) Gets or creates and registers a Gauge Parameters: Name Type Description name string The metric name readFn function See Gauge Source: measured-core/lib/Collection.js, line 81 Returns: Type Gauge histogram(name [, properties]) Gets or creates and registers a Histogram Parameters: Name Type Argument Description name string The metric name properties HistogramProperties &lt;optional&gt; See HistogramProperties Source: measured-core/lib/Collection.js, line 125 Returns: Type Histogram meter(name [, properties]) Gets or creates and registers a Meter Parameters: Name Type Argument Description name string The metric name properties MeterProperties &lt;optional&gt; See MeterProperties Source: measured-core/lib/Collection.js, line 169 Returns: Type Meter register(name, metric) register a metric that was created outside the provided convenience methods of this collection Parameters: Name Type Description name The metric name metric The Metric implementation Source: measured-core/lib/Collection.js, line 48 Example var { Collection, Gauge } = require('measured'); const collection = new Collection('node-process-metrics'); const gauge = new Gauge(() =&gt; { return process.memoryUsage().heapUsed; }); collection.register('node.process.heap_used', gauge); settableGauge(name [, properties]) Gets or creates and registers a SettableGauge Parameters: Name Type Argument Description name string The metric name properties SettableGaugeProperties &lt;optional&gt; See SettableGaugeProperties Source: measured-core/lib/Collection.js, line 191 Returns: Type SettableGauge timer(name [, properties]) Gets or creates and registers a Timer Parameters: Name Type Argument Description name string The metric name properties TimerProperties &lt;optional&gt; See TimerProperties Source: measured-core/lib/Collection.js, line 147 Returns: Type Timer toJSON() Fetches the data/values from all registered metrics Source: measured-core/lib/Collection.js, line 56 Returns: The combined JSON object Type Object Ã— Search results Close "},"Counter.html":{"id":"Counter.html","title":"Class: Counter","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterReporterSelfReportingMetricsRegistrySettableGaugeSignalFxMetricsReporterSignalFxSelfReportingMetricsRegistryStopwatchTimer Interfaces MetricMetricTypes Tutorials SignalFx Express Full End to End Example Global Global Class: Counter Counter Counters are things that increment or decrement new Counter( [properties]) Parameters: Name Type Argument Description properties CounterProperties &lt;optional&gt; see CounterProperties Implements: Metric Source: measured-core/lib/metrics/Counter.js, line 16 Example var Measured = require('measured') var activeUploads = new Measured.Counter(); http.createServer(function(req, res) { activeUploads.inc(); req.on('end', function() { activeUploads.dec(); }); }); Methods dec(n) Decrements the counter Parameters: Name Type Description n number Decrement the counter by n. Defaults to 1. Source: measured-core/lib/metrics/Counter.js, line 46 getType() The type of the Metric Impl. MetricTypes. Implements: Metric#getType Source: measured-core/lib/metrics/Counter.js, line 62 Returns: The type of the Metric Impl. Type string inc(n) Increments the counter. Parameters: Name Type Description n number Increment the counter by n. Defaults to 1. Source: measured-core/lib/metrics/Counter.js, line 38 reset(count) Resets the counter back to count Defaults to 0. Parameters: Name Type Description count number Resets the counter back to count Defaults to 0. Source: measured-core/lib/metrics/Counter.js, line 54 toJSON() Counters directly return their currently value. Implements: Metric#toJSON Source: measured-core/lib/metrics/Counter.js, line 30 Returns: Type number Ã— Search results Close "},"ExponentiallyDecayingSample.html":{"id":"ExponentiallyDecayingSample.html","title":"Class: ExponentiallyDecayingSample","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterReporterSelfReportingMetricsRegistrySettableGaugeSignalFxMetricsReporterSignalFxSelfReportingMetricsRegistryStopwatchTimer Interfaces MetricMetricTypes Tutorials SignalFx Express Full End to End Example Global Global Class: ExponentiallyDecayingSample ExponentiallyDecayingSample ExponentiallyDecayingSample new ExponentiallyDecayingSample() Source: measured-core/lib/util/ExponentiallyDecayingSample.js, line 11 Ã— Search results Close "},"ExponentiallyMovingWeightedAverage.html":{"id":"ExponentiallyMovingWeightedAverage.html","title":"Class: ExponentiallyMovingWeightedAverage","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterReporterSelfReportingMetricsRegistrySettableGaugeSignalFxMetricsReporterSignalFxSelfReportingMetricsRegistryStopwatchTimer Interfaces MetricMetricTypes Tutorials SignalFx Express Full End to End Example Global Global Class: ExponentiallyMovingWeightedAverage ExponentiallyMovingWeightedAverage ExponentiallyMovingWeightedAverage new ExponentiallyMovingWeightedAverage() Source: measured-core/lib/util/ExponentiallyMovingWeightedAverage.js, line 8 Ã— Search results Close "},"Gauge.html":{"id":"Gauge.html","title":"Class: Gauge","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterReporterSelfReportingMetricsRegistrySettableGaugeSignalFxMetricsReporterSignalFxSelfReportingMetricsRegistryStopwatchTimer Interfaces MetricMetricTypes Tutorials SignalFx Express Full End to End Example Global Global Class: Gauge Gauge Values that can be read instantly new Gauge(readFn) Parameters: Name Type Description readFn function A function that returns the numeric value for this gauge. Implements: Metric Source: measured-core/lib/metrics/Gauge.js, line 12 Example var Measured = require('measured') var gauge = new Measured.Gauge(function() { return process.memoryUsage().rss; }); Methods getType() The type of the Metric Impl. MetricTypes. Implements: Metric#getType Source: measured-core/lib/metrics/Gauge.js, line 32 Returns: The type of the Metric Impl. Type string toJSON() This is sync for now, but maybe async gauges would be useful as well? Implements: Metric#toJSON Source: measured-core/lib/metrics/Gauge.js, line 24 Returns: Gauges directly return the value from the callback which should be a number. Type number Ã— Search results Close "},"Histogram.html":{"id":"Histogram.html","title":"Class: Histogram","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterReporterSelfReportingMetricsRegistrySettableGaugeSignalFxMetricsReporterSignalFxSelfReportingMetricsRegistryStopwatchTimer Interfaces MetricMetricTypes Tutorials SignalFx Express Full End to End Example Global Global Class: Histogram Histogram Keeps a reservoir of statistically relevant values biased towards the last 5 minutes to explore their distribution. new Histogram( [properties]) Parameters: Name Type Argument Description properties HistogramProperties &lt;optional&gt; see HistogramProperties. Implements: Metric Source: measured-core/lib/metrics/Histogram.js, line 17 Example var Measured = require('measured') var histogram = new Measured.Histogram(); http.createServer(function(req, res) { if (req.headers['content-length']) { histogram.update(parseInt(req.headers['content-length'], 10)); } }); Methods getType() The type of the Metric Impl. MetricTypes. Implements: Metric#getType Source: measured-core/lib/metrics/Histogram.js, line 223 Returns: The type of the Metric Impl. Type string hasValues() Checks whether the histogram contains values. Source: measured-core/lib/metrics/Histogram.js, line 141 Returns: Whether the histogram contains values. Type boolean reset() Resets all values. Histograms initialized with custom options will be reset to the default settings (patch welcome). Source: measured-core/lib/metrics/Histogram.js, line 129 toJSON() Implements: Metric#toJSON Source: measured-core/lib/metrics/Histogram.js, line 148 Returns: Type HistogramData update(value) Pushes value into the sample. timestamp defaults to Date.now(). Parameters: Name Type Description value number Source: measured-core/lib/metrics/Histogram.js, line 44 Ã— Search results Close "},"Meter.html":{"id":"Meter.html","title":"Class: Meter","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterReporterSelfReportingMetricsRegistrySettableGaugeSignalFxMetricsReporterSignalFxSelfReportingMetricsRegistryStopwatchTimer Interfaces MetricMetricTypes Tutorials SignalFx Express Full End to End Example Global Global Class: Meter Meter Things that are measured as events / interval. new Meter( [properties]) Parameters: Name Type Argument Description properties MeterProperties &lt;optional&gt; see MeterProperties. Implements: Metric Source: measured-core/lib/metrics/Meter.js, line 18 Example var Measured = require('measured') var meter = new Measured.Meter(); http.createServer(function(req, res) { meter.mark(); }); Methods getType() The type of the Metric Impl. MetricTypes. Implements: Metric#getType Source: measured-core/lib/metrics/Meter.js, line 153 Returns: The type of the Metric Impl. Type string mark(n) Register n events as having just occured. Defaults to 1. Parameters: Name Type Description n number Source: measured-core/lib/metrics/Meter.js, line 52 ref() Refs the backing timer again. Idempotent. Source: measured-core/lib/metrics/Meter.js, line 76 reset() Resets all values. Meters initialized with custom options will be reset to the default settings (patch welcome). Source: measured-core/lib/metrics/Meter.js, line 100 toJSON() Implements: Metric#toJSON Source: measured-core/lib/metrics/Meter.js, line 129 Returns: Type MeterData unref() Unrefs the backing timer. The meter will not keep the event loop alive. Idempotent. Source: measured-core/lib/metrics/Meter.js, line 85 Ã— Search results Close "},"Metric.html":{"id":"Metric.html","title":"Interface: Metric","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterReporterSelfReportingMetricsRegistrySettableGaugeSignalFxMetricsReporterSignalFxSelfReportingMetricsRegistryStopwatchTimer Interfaces MetricMetricTypes Tutorials SignalFx Express Full End to End Example Global Global Interface: Metric Metric Interface for Metric types. Implementations Counter, things that increment or decrement.Gauge, values that can be read instantly via a supplied call back.Histogram, keeps a reservoir of statistically relevant values to explore their distribution.Meter, things that are measured as events / interval.NoOpMeter, an empty impl of meter, useful for supplying to a Timer, when you only care about the Histogram.SettableGauge, just like a Gauge but its value is set directly rather than supplied by a callback.Timer, timers are a combination of Meters and Histograms. They measure the rate as well as distribution of scalar events. Source: measured-core/lib/metrics/Metric.js, line 1 Methods getType() The type of the Metric Impl. MetricTypes. Source: measured-core/lib/metrics/Metric.js, line 31 Returns: The type of the Metric Impl. Type string toJSON() Please note that dispite its name, this method can return raw numbers oncertain implementations such as counters and gauges. Source: measured-core/lib/metrics/Metric.js, line 25 Returns: Returns the data from the Metric Type any Ã— Search results Close "},"MetricTypes.html":{"id":"MetricTypes.html","title":"Interface: MetricTypes","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterReporterSelfReportingMetricsRegistrySettableGaugeSignalFxMetricsReporterSignalFxSelfReportingMetricsRegistryStopwatchTimer Interfaces MetricMetricTypes Tutorials SignalFx Express Full End to End Example Global Global Interface: MetricTypes MetricTypes An enum like object that is the set of core metric types that all implementors of Metric are. Properties: Name Type Description The COUNTER type for Counters. The GAUGE type for Gauges. The HISTOGRAM type for Histograms. The METER type for Meters. The TIMER type for Timers. Source: measured-core/lib/metrics/Metric.js, line 34 Ã— Search results Close "},"module-measured-core.html":{"id":"module-measured-core.html","title":"Module: measured-core","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterReporterSelfReportingMetricsRegistrySettableGaugeSignalFxMetricsReporterSignalFxSelfReportingMetricsRegistryStopwatchTimer Interfaces MetricMetricTypes Tutorials SignalFx Express Full End to End Example Global Global Module: measured-core The main measured module that is referenced when require('measured') is used. Source: measured-core/lib/index.js, line 16 Members &lt;static&gt; BinaryHeap :BinaryHeap See BinaryHeap Type: BinaryHeap Source: measured-core/lib/index.js, line 74 &lt;static&gt; Collection :Collection See Collection Type: Collection Source: measured-core/lib/index.js, line 26 &lt;static&gt; Counter :Counter See Counter Type: Counter Source: measured-core/lib/index.js, line 32 &lt;static&gt; ExponentiallyDecayingSample :ExponentiallyDecayingSample See ExponentiallyDecayingSample Type: ExponentiallyDecayingSample Source: measured-core/lib/index.js, line 80 &lt;static&gt; ExponentiallyMovingWeightedAverage :ExponentiallyMovingWeightedAverage See ExponentiallyMovingWeightedAverage Type: ExponentiallyMovingWeightedAverage Source: measured-core/lib/index.js, line 86 &lt;static&gt; Gauge :Gauge See Gauge Type: Gauge Source: measured-core/lib/index.js, line 38 &lt;static&gt; Histogram :Histogram See Histogram Type: Histogram Source: measured-core/lib/index.js, line 50 &lt;static&gt; Meter :Meter See Meter Type: Meter Source: measured-core/lib/index.js, line 56 &lt;static&gt; MetricTypes :MetricTypes See MetricTypes Type: MetricTypes Source: measured-core/lib/index.js, line 98 &lt;static&gt; NoOpMeter :NoOpMeter See NoOpMeter Type: NoOpMeter Source: measured-core/lib/index.js, line 62 &lt;static&gt; SettableGauge :SettableGauge See SettableGauge Type: SettableGauge Source: measured-core/lib/index.js, line 44 &lt;static&gt; Stopwatch :Stopwatch See Stopwatch Type: Stopwatch Source: measured-core/lib/index.js, line 92 &lt;static&gt; Timer :Timer See Timer Type: Timer Source: measured-core/lib/index.js, line 68 &lt;static&gt; units :units See units Type: units Source: measured-core/lib/index.js, line 104 Methods &lt;static&gt; createCollection(name) Creates a named collection. See {@Collection} for more details Parameters: Name Type Description name The name for the collection Source: measured-core/lib/index.js, line 112 Returns: Type Collection Ã— Search results Close "},"module-units.html":{"id":"module-units.html","title":"Module: units","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterReporterSelfReportingMetricsRegistrySettableGaugeSignalFxMetricsReporterSignalFxSelfReportingMetricsRegistryStopwatchTimer Interfaces MetricMetricTypes Tutorials SignalFx Express Full End to End Example Global Global Module: units Time units, as found in Java: http://download.oracle.com/javase/6/docs/api/java/util/concurrent/TimeUnit.html Source: measured-core/lib/util/units.js, line 9 Example const TimeUnit = require('measured-core').unit setTimeout(() =&gt; {}, 5 * TimeUnit.MINUTES) Members &lt;static&gt; DAYS :number days in milliseconds Type: number Source: measured-core/lib/util/units.js, line 51 &lt;static&gt; HOURS :number hours in milliseconds Type: number Source: measured-core/lib/util/units.js, line 46 &lt;static&gt; MICROSECONDS :number microseconds in milliseconds Type: number Source: measured-core/lib/util/units.js, line 26 &lt;static&gt; MILLISECONDS :number milliseconds in milliseconds Type: number Source: measured-core/lib/util/units.js, line 31 &lt;static&gt; MINUTES :number minutes in milliseconds Type: number Source: measured-core/lib/util/units.js, line 41 &lt;static&gt; NANOSECONDS :number nanoseconds in milliseconds Type: number Source: measured-core/lib/util/units.js, line 21 &lt;static&gt; SECONDS :number seconds in milliseconds Type: number Source: measured-core/lib/util/units.js, line 36 Ã— Search results Close "},"NoOpMeter.html":{"id":"NoOpMeter.html","title":"Class: NoOpMeter","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterReporterSelfReportingMetricsRegistrySettableGaugeSignalFxMetricsReporterSignalFxSelfReportingMetricsRegistryStopwatchTimer Interfaces MetricMetricTypes Tutorials SignalFx Express Full End to End Example Global Global Class: NoOpMeter NoOpMeter A No-Op Impl of Meter that can be used with a timer, to only create histogram data.This is useful for some time series aggregators that can calculate rates for you just off of sent count. new NoOpMeter() Implements: Metric Source: measured-core/lib/metrics/NoOpMeter.js, line 17 Example const { NoOpMeter, Timer } = require('measured') const meter = new NoOpMeter(); const timer = new Timer({meter: meter}); ... // do some stuff with the timer and stopwatch api ... Methods currentRate() No-Op impl Source: measured-core/lib/metrics/NoOpMeter.js, line 58 end() No-Op impl Source: measured-core/lib/metrics/NoOpMeter.js, line 33 getType() The type of the Metric Impl. MetricTypes. Implements: Metric#getType Source: measured-core/lib/metrics/NoOpMeter.js, line 72 Returns: The type of the Metric Impl. Type string mark(n) No-Op impl Parameters: Name Type Description n number Number of events to mark. Source: measured-core/lib/metrics/NoOpMeter.js, line 23 meanRate() No-Op impl Source: measured-core/lib/metrics/NoOpMeter.js, line 53 ref() No-Op impl Source: measured-core/lib/metrics/NoOpMeter.js, line 38 reset() No-Op impl Source: measured-core/lib/metrics/NoOpMeter.js, line 48 start() No-Op impl Source: measured-core/lib/metrics/NoOpMeter.js, line 28 toJSON() Returns an empty object Implements: Metric#toJSON Source: measured-core/lib/metrics/NoOpMeter.js, line 64 Returns: Type Object unref() No-Op impl Source: measured-core/lib/metrics/NoOpMeter.js, line 43 Ã— Search results Close "},"Reporter.html":{"id":"Reporter.html","title":"Class: Reporter","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterReporterSelfReportingMetricsRegistrySettableGaugeSignalFxMetricsReporterSignalFxSelfReportingMetricsRegistryStopwatchTimer Interfaces MetricMetricTypes Tutorials SignalFx Express Full End to End Example Global Global Class: Reporter Reporter The abstract reporter that specific implementations can extend to create a Self Reporting Metrics Registry Reporter. SelfReportingMetricsRegistry &lt;abstract&gt; new Reporter( [options]) Parameters: Name Type Argument Description options ReporterOptions &lt;optional&gt; The optional params to supply when creating a reporter. Source: measured-reporting/lib/reporters/Reporter.js, line 13 Members &lt;protected&gt; _defaultDimensions :Dimensions Map of default dimensions, that should be sent with every metric Type: Dimensions Source: measured-reporting/lib/reporters/Reporter.js, line 38 &lt;protected&gt; _defaultReportingIntervalInSeconds :number the default interval a number in seconds. Type: number Source: measured-reporting/lib/reporters/Reporter.js, line 54 &lt;protected&gt; _log :Logger Loggers to use, defaults to a new bunyan logger if nothing is supplied in options Type: Logger Source: measured-reporting/lib/reporters/Reporter.js, line 45 Methods &lt;abstract, protected&gt; _reportMetrics(metrics) This method gets called with an array of MetricWrapper on an interval, when metrics should be reported. This is the main method that needs to get implemented when created an aggregator specific reporter. Parameters: Name Type Description metrics Array.&lt;MetricWrapper&gt; The array of metrics to report. Source: measured-reporting/lib/reporters/Reporter.js, line 136 reportMetricOnInterval(metricKey, intervalInSeconds) Informs the reporter to report a metric on a given interval in seconds. Parameters: Name Type Description metricKey string The metric key for the metric in the metric registry. intervalInSeconds number The interval in seconds to report the metric on. Source: measured-reporting/lib/reporters/Reporter.js, line 73 setRegistry(registry) Sets the registry, this must be called before reportMetricOnInterval. Parameters: Name Type Description registry DimensionAwareMetricsRegistry Source: measured-reporting/lib/reporters/Reporter.js, line 63 shutdown() Clears the intervals that are running to report metrics at an interval, and resets the state. Source: measured-reporting/lib/reporters/Reporter.js, line 153 Ã— Search results Close "},"SelfReportingMetricsRegistry.html":{"id":"SelfReportingMetricsRegistry.html","title":"Class: SelfReportingMetricsRegistry","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterReporterSelfReportingMetricsRegistrySettableGaugeSignalFxMetricsReporterSignalFxSelfReportingMetricsRegistryStopwatchTimer Interfaces MetricMetricTypes Tutorials SignalFx Express Full End to End Example Global Global Class: SelfReportingMetricsRegistry SelfReportingMetricsRegistry A dimensional aware self-reporting metrics registry new SelfReportingMetricsRegistry(reporter [, options]) Parameters: Name Type Argument Description reporter Reporter The Metrics Reporter options SelfReportingMetricsRegistryOptions &lt;optional&gt; Configurable options for the Self Reporting Metrics Registry Source: measured-reporting/lib/registries/SelfReportingMetricsRegistry.js, line 24 Members &lt;protected&gt; _log :Logger Loggers to use, defaults to a new bunyan logger if nothing is supplied in options Type: Logger Source: measured-reporting/lib/registries/SelfReportingMetricsRegistry.js, line 51 &lt;protected&gt; _registry :DimensionAwareMetricsRegistry Type: DimensionAwareMetricsRegistry Source: measured-reporting/lib/registries/SelfReportingMetricsRegistry.js, line 43 &lt;protected&gt; _reporter :Reporter Type: Reporter Source: measured-reporting/lib/registries/SelfReportingMetricsRegistry.js, line 37 Methods getOrCreateCounter(name, dimensions, publishingIntervalInSeconds) Creates a Counter or gets the existing Counter for a given name and dimension combo Parameters: Name Type Description name string The Metric name dimensions Dimensions any custom Dimensions for the Metric publishingIntervalInSeconds number a optional custom publishing interval Source: measured-reporting/lib/registries/SelfReportingMetricsRegistry.js, line 179 Returns: Type Counter getOrCreateGauge(name, callback [, dimensions] [, publishingIntervalInSeconds]) Creates a Gauge or gets the existing Gauge for a given name and dimension combo Parameters: Name Type Argument Description name string The Metric name callback function The callback that will return a value to report to signal fx dimensions Dimensions &lt;optional&gt; any custom Dimensions for the Metric publishingIntervalInSeconds number &lt;optional&gt; a optional custom publishing interval Source: measured-reporting/lib/registries/SelfReportingMetricsRegistry.js, line 112 Returns: Type Gauge Example // https://nodejs.org/api/process.html#process_process_memoryusage // Report heap total and heap used at the default interval registry.getOrCreateGauge( 'process-memory-heap-total', () =&gt; { return process.memoryUsage().heapTotal } ); registry.getOrCreateGauge( 'process-memory-heap-used', () =&gt; { return process.memoryUsage().heapUsed } ) getOrCreateHistogram(name, dimensions, publishingIntervalInSeconds) Creates a Histogram or gets the existing Histogram for a given name and dimension combo Parameters: Name Type Description name string The Metric name dimensions Dimensions any custom Dimensions for the Metric publishingIntervalInSeconds number a optional custom publishing interval Source: measured-reporting/lib/registries/SelfReportingMetricsRegistry.js, line 133 Returns: Type Histogram getOrCreateMeter(name, dimensions, publishingIntervalInSeconds) Creates a Meter or gets the existing Meter for a given name and dimension combo Parameters: Name Type Description name string The Metric name dimensions Dimensions any custom Dimensions for the Metric publishingIntervalInSeconds number a optional custom publishing interval Source: measured-reporting/lib/registries/SelfReportingMetricsRegistry.js, line 156 Returns: Type Meter getOrCreateSettableGauge(name, dimensions, publishingIntervalInSeconds) Creates a SettableGauge or gets the existing SettableGauge for a given name and dimension combo. Parameters: Name Type Description name dimensions publishingIntervalInSeconds Source: measured-reporting/lib/registries/SelfReportingMetricsRegistry.js, line 224 getOrCreateTimer(name, dimensions, publishingIntervalInSeconds) Creates a Timer or gets the existing Timer for a given name and dimension combo. Parameters: Name Type Description name string The Metric name dimensions Dimensions any custom Dimensions for the Metric publishingIntervalInSeconds number a optional custom publishing interval Source: measured-reporting/lib/registries/SelfReportingMetricsRegistry.js, line 202 Returns: Type Timer register(name, metric [, dimensions] [, publishingIntervalInSeconds]) Registers a manually created Metric. Parameters: Name Type Argument Description name string The Metric name metric Metric The Metric to register dimensions Dimensions &lt;optional&gt; any custom Dimensions for the Metric publishingIntervalInSeconds number &lt;optional&gt; a optional custom publishing interval Source: measured-reporting/lib/registries/SelfReportingMetricsRegistry.js, line 74 Example const settableGauge = new SettableGauge(5); // register the gauge and have it report to every 10 seconds registry.register('my-gauge', settableGauge, {}, 10); interval(() =&gt; { // such as cpu % used determineAValueThatCannotBeSync((value) =&gt; { settableGauge.update(value); }) }, 10000) shutdown() Calls end on all metrics in the registry that support end() and calls end on the reporter Source: measured-reporting/lib/registries/SelfReportingMetricsRegistry.js, line 242 Ã— Search results Close "},"SettableGauge.html":{"id":"SettableGauge.html","title":"Class: SettableGauge","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterReporterSelfReportingMetricsRegistrySettableGaugeSignalFxMetricsReporterSignalFxSelfReportingMetricsRegistryStopwatchTimer Interfaces MetricMetricTypes Tutorials SignalFx Express Full End to End Example Global Global Class: SettableGauge SettableGauge Works like a Gauge, but rather than getting its value from a callback, the valueis set when needed. This can be useful for setting a gauges value for asynchronous operations. new SettableGauge( [options]) Parameters: Name Type Argument Description options SettableGaugeProperties &lt;optional&gt; See SettableGaugeProperties. Implements: Metric Source: measured-core/lib/metrics/SettableGauge.js, line 16 Example const settableGauge = new SettableGauge(); // Update the settable gauge ever 10'ish seconds setInterval(() =&gt; { calculateSomethingAsync().then((value) =&gt; { settableGauge.setValue(value); }); }, 10000); Methods getType() The type of the Metric Impl. MetricTypes. Implements: Metric#getType Source: measured-core/lib/metrics/SettableGauge.js, line 40 Returns: The type of the Metric Impl. Type string toJSON() Implements: Metric#toJSON Source: measured-core/lib/metrics/SettableGauge.js, line 32 Returns: Settable Gauges directly return there current value. Type number Ã— Search results Close "},"SignalFxMetricsReporter.html":{"id":"SignalFxMetricsReporter.html","title":"Class: SignalFxMetricsReporter","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterReporterSelfReportingMetricsRegistrySettableGaugeSignalFxMetricsReporterSignalFxSelfReportingMetricsRegistryStopwatchTimer Interfaces MetricMetricTypes Tutorials SignalFx Express Full End to End Example Global Global Class: SignalFxMetricsReporter SignalFxMetricsReporter A Reporter that reports metrics to Signal Fx new SignalFxMetricsReporter(signalFxClient, options) Parameters: Name Type Description signalFxClient SignalFxClient The configured signal fx client. options ReporterOptions See ReporterOptions. Source: measured-signalfx-reporter/lib/reporter/SignalFxMetricsReporter.js, line 9 Extends Reporter Members &lt;protected&gt; _defaultDimensions :Dimensions Map of default dimensions, that should be sent with every metric Type: Dimensions Inherited From: Reporter#_defaultDimensions Source: measured-reporting/lib/reporters/Reporter.js, line 38 &lt;protected&gt; _defaultReportingIntervalInSeconds :number the default interval a number in seconds. Type: number Inherited From: Reporter#_defaultReportingIntervalInSeconds Source: measured-reporting/lib/reporters/Reporter.js, line 54 &lt;protected&gt; _log :Logger Loggers to use, defaults to a new bunyan logger if nothing is supplied in options Type: Logger Inherited From: Reporter#_log Source: measured-reporting/lib/reporters/Reporter.js, line 45 Methods &lt;protected&gt; _getValuesToProcessForCounter(name, counter) Maps and Filters values from a Counter to a set of metrics to report to SigFx. Parameters: Name Type Description name string The registry name counter Counter The data from the measure metric object Source: measured-signalfx-reporter/lib/reporter/SignalFxMetricsReporter.js, line 151 Returns: Returns an array of MetricValueTypeWrapper to use to build the request Type Array.&lt;MetricValueTypeWrapper&gt; &lt;protected&gt; _getValuesToProcessForGauge(name, gauge) Maps and Filters values from a Gauge to a set of metrics to report to SigFx. Parameters: Name Type Description name string The registry name gauge Gauge The Gauge Source: measured-signalfx-reporter/lib/reporter/SignalFxMetricsReporter.js, line 133 Returns: Returns an array of MetricValueTypeWrapper to use to build the request Type Array.&lt;MetricValueTypeWrapper&gt; &lt;protected&gt; _getValuesToProcessForHistogram(name, histogram) Maps and Filters values from a Histogram to a set of metrics to report to SigFx. Parameters: Name Type Description name string The registry name histogram Histogram The Histogram Source: measured-signalfx-reporter/lib/reporter/SignalFxMetricsReporter.js, line 169 Returns: Returns an array of MetricValueTypeWrapper to use to build the request Type Array.&lt;MetricValueTypeWrapper&gt; &lt;protected&gt; _getValuesToProcessForTimer(name, timer) Maps and Filters values from a Timer to a set of metrics to report to SigFx. Parameters: Name Type Description name string The registry name timer Timer The Timer Source: measured-signalfx-reporter/lib/reporter/SignalFxMetricsReporter.js, line 118 Returns: Returns an array of MetricValueTypeWrapper to use to build the request Type Array.&lt;MetricValueTypeWrapper&gt; &lt;protected&gt; _getValuesToProcessForType(name, metric) Maps Measured Metrics Object JSON outputs to there respective signal fx metrics using logic fromcom.signalfx.codahale.reporter.AggregateMetricSenderSessionWrapper in the java lib to derive naming Parameters: Name Type Description name string The registered metric base name metric Metric The metric. Source: measured-signalfx-reporter/lib/reporter/SignalFxMetricsReporter.js, line 88 Returns: an array of MetricValueTypeWrapper that can be used tobuild the sig fx data point request Type Array.&lt;MetricValueTypeWrapper&gt; &lt;protected&gt; _processMetric(metric, currentBuiltRequest) Method for getting raw signal fx api request values from the Timer Object. Parameters: Name Type Description metric MetricWrapper metric The Wrapped Metric Object. currentBuiltRequest any The signal fx request that is being built. Source: measured-signalfx-reporter/lib/reporter/SignalFxMetricsReporter.js, line 53 Returns: the currentBuiltRequest The signal fx request that is being built with the given metric in it. Type any &lt;protected&gt; _reportMetrics(metrics) Sends metrics to signal fx, converting name and dimensions and Metric to data signal fx can ingest Parameters: Name Type Description metrics Array.&lt;MetricWrapper&gt; The array of metrics to send to signal fx. Overrides: Reporter#_reportMetrics Source: measured-signalfx-reporter/lib/reporter/SignalFxMetricsReporter.js, line 25 reportMetricOnInterval(metricKey, intervalInSeconds) Informs the reporter to report a metric on a given interval in seconds. Parameters: Name Type Description metricKey string The metric key for the metric in the metric registry. intervalInSeconds number The interval in seconds to report the metric on. Inherited From: Reporter#reportMetricOnInterval Source: measured-reporting/lib/reporters/Reporter.js, line 73 setRegistry(registry) Sets the registry, this must be called before reportMetricOnInterval. Parameters: Name Type Description registry DimensionAwareMetricsRegistry Inherited From: Reporter#setRegistry Source: measured-reporting/lib/reporters/Reporter.js, line 63 shutdown() Clears the intervals that are running to report metrics at an interval, and resets the state. Inherited From: Reporter#shutdown Source: measured-reporting/lib/reporters/Reporter.js, line 153 Ã— Search results Close "},"SignalFxSelfReportingMetricsRegistry.html":{"id":"SignalFxSelfReportingMetricsRegistry.html","title":"Class: SignalFxSelfReportingMetricsRegistry","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterReporterSelfReportingMetricsRegistrySettableGaugeSignalFxMetricsReporterSignalFxSelfReportingMetricsRegistryStopwatchTimer Interfaces MetricMetricTypes Tutorials SignalFx Express Full End to End Example Global Global Class: SignalFxSelfReportingMetricsRegistry SignalFxSelfReportingMetricsRegistry A SignalFx Self Reporting Metrics Registry that disallows the use of meters as they waste DPM and accomplished using a counter. new SignalFxSelfReportingMetricsRegistry(reporter [, options]) Parameters: Name Type Argument Description reporter Reporter The Metrics Reporter options SelfReportingMetricsRegistryOptions &lt;optional&gt; Configurable options for the Self Reporting Metrics Registry Source: measured-signalfx-reporter/lib/registries/SignalFxSelfReportingMetricsRegistry.js, line 9 Extends SelfReportingMetricsRegistry Members &lt;protected&gt; _log :Logger Loggers to use, defaults to a new bunyan logger if nothing is supplied in options Type: Logger Inherited From: SelfReportingMetricsRegistry#_log Source: measured-reporting/lib/registries/SelfReportingMetricsRegistry.js, line 51 &lt;protected&gt; _registry :DimensionAwareMetricsRegistry Type: DimensionAwareMetricsRegistry Inherited From: SelfReportingMetricsRegistry#_registry Source: measured-reporting/lib/registries/SelfReportingMetricsRegistry.js, line 43 &lt;protected&gt; _reporter :Reporter Type: Reporter Inherited From: SelfReportingMetricsRegistry#_reporter Source: measured-reporting/lib/registries/SelfReportingMetricsRegistry.js, line 37 Methods getOrCreateCounter(name, dimensions, publishingIntervalInSeconds) Creates a Counter or gets the existing Counter for a given name and dimension combo Parameters: Name Type Description name string The Metric name dimensions Dimensions any custom Dimensions for the Metric publishingIntervalInSeconds number a optional custom publishing interval Inherited From: SelfReportingMetricsRegistry#getOrCreateCounter Source: measured-reporting/lib/registries/SelfReportingMetricsRegistry.js, line 179 Returns: Type Counter getOrCreateGauge(name, callback [, dimensions] [, publishingIntervalInSeconds]) Creates a Gauge or gets the existing Gauge for a given name and dimension combo Parameters: Name Type Argument Description name string The Metric name callback function The callback that will return a value to report to signal fx dimensions Dimensions &lt;optional&gt; any custom Dimensions for the Metric publishingIntervalInSeconds number &lt;optional&gt; a optional custom publishing interval Inherited From: SelfReportingMetricsRegistry#getOrCreateGauge Source: measured-reporting/lib/registries/SelfReportingMetricsRegistry.js, line 112 Returns: Type Gauge Example // https://nodejs.org/api/process.html#process_process_memoryusage // Report heap total and heap used at the default interval registry.getOrCreateGauge( 'process-memory-heap-total', () =&gt; { return process.memoryUsage().heapTotal } ); registry.getOrCreateGauge( 'process-memory-heap-used', () =&gt; { return process.memoryUsage().heapUsed } ) getOrCreateHistogram(name, dimensions, publishingIntervalInSeconds) Creates a Histogram or gets the existing Histogram for a given name and dimension combo Parameters: Name Type Description name string The Metric name dimensions Dimensions any custom Dimensions for the Metric publishingIntervalInSeconds number a optional custom publishing interval Inherited From: SelfReportingMetricsRegistry#getOrCreateHistogram Source: measured-reporting/lib/registries/SelfReportingMetricsRegistry.js, line 133 Returns: Type Histogram getOrCreateMeter(name, dimensions, publishingIntervalInSeconds) You should use counters and implements meter functionality in your Dashboard. Parameters: Name Type Description name string The Metric name dimensions Dimensions any custom Dimensions for the Metric publishingIntervalInSeconds number a optional custom publishing interval Overrides: SelfReportingMetricsRegistry#getOrCreateMeter Source: measured-signalfx-reporter/lib/registries/SignalFxSelfReportingMetricsRegistry.js, line 49 Returns: Type NoOpMeter | * getOrCreateSettableGauge(name, dimensions, publishingIntervalInSeconds) Creates a SettableGauge or gets the existing SettableGauge for a given name and dimension combo. Parameters: Name Type Description name dimensions publishingIntervalInSeconds Inherited From: SelfReportingMetricsRegistry#getOrCreateSettableGauge Source: measured-reporting/lib/registries/SelfReportingMetricsRegistry.js, line 224 getOrCreateTimer(name, dimensions, publishingIntervalInSeconds) Creates a Timer or get the existing Timer for a given name and dimension combo with a NoOpMeter Parameters: Name Type Description name string The Metric name dimensions Dimensions any custom Dimensions for the Metric publishingIntervalInSeconds number a optional custom publishing interval Overrides: SelfReportingMetricsRegistry#getOrCreateTimer Source: measured-signalfx-reporter/lib/registries/SignalFxSelfReportingMetricsRegistry.js, line 27 Returns: Type Timer register(name, metric [, dimensions] [, publishingIntervalInSeconds]) Registers a manually created Metric. Parameters: Name Type Argument Description name string The Metric name metric Metric The Metric to register dimensions Dimensions &lt;optional&gt; any custom Dimensions for the Metric publishingIntervalInSeconds number &lt;optional&gt; a optional custom publishing interval Inherited From: SelfReportingMetricsRegistry#register Source: measured-reporting/lib/registries/SelfReportingMetricsRegistry.js, line 74 Example const settableGauge = new SettableGauge(5); // register the gauge and have it report to every 10 seconds registry.register('my-gauge', settableGauge, {}, 10); interval(() =&gt; { // such as cpu % used determineAValueThatCannotBeSync((value) =&gt; { settableGauge.update(value); }) }, 10000) shutdown() Calls end on all metrics in the registry that support end() and calls end on the reporter Inherited From: SelfReportingMetricsRegistry#shutdown Source: measured-reporting/lib/registries/SelfReportingMetricsRegistry.js, line 242 Ã— Search results Close "},"Stopwatch.html":{"id":"Stopwatch.html","title":"Class: Stopwatch","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterReporterSelfReportingMetricsRegistrySettableGaugeSignalFxMetricsReporterSignalFxSelfReportingMetricsRegistryStopwatchTimer Interfaces MetricMetricTypes Tutorials SignalFx Express Full End to End Example Global Global Class: Stopwatch Stopwatch A simple object for tracking elapsed time new Stopwatch(options) Creates a started Stopwatch Parameters: Name Type Description options StopwatchProperties See StopwatchProperties Source: measured-core/lib/util/Stopwatch.js, line 8 Extends EventEmitter Methods end() Called to mark the end of the timer task Source: measured-core/lib/util/Stopwatch.js, line 29 Returns: the total execution time Type number Ã— Search results Close "},"Timer.html":{"id":"Timer.html","title":"Class: Timer","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterReporterSelfReportingMetricsRegistrySettableGaugeSignalFxMetricsReporterSignalFxSelfReportingMetricsRegistryStopwatchTimer Interfaces MetricMetricTypes Tutorials SignalFx Express Full End to End Example Global Global Class: Timer Timer Timers are a combination of Meters and Histograms. They measure the rate as well as distribution of scalar events. Since they are frequently used for tracking how long certain things take, they expose an API for that: See example 1. But you can also use them as generic histograms that also track the rate of events: See example 2. new Timer( [properties]) Parameters: Name Type Argument Description properties TimerProperties &lt;optional&gt; See TimerProperties. Implements: Metric Source: measured-core/lib/metrics/Timer.js, line 36 Examples var Measured = require('measured') var timer = new Measured.Timer(); http.createServer(function(req, res) { var stopwatch = timer.start(); req.on('end', function() { stopwatch.end(); }); }); var Measured = require('measured') var timer = new Measured.Timer(); http.createServer(function(req, res) { if (req.headers['content-length']) { timer.update(parseInt(req.headers['content-length'], 10)); } }); Methods getType() The type of the Metric Impl. MetricTypes. Implements: Metric#getType Source: measured-core/lib/metrics/Timer.js, line 116 Returns: The type of the Metric Impl. Type string ref() Refs the backing timer again. Idempotent. Source: measured-core/lib/metrics/Timer.js, line 86 reset() Resets all values. Timers initialized with custom options will be reset to the default settings. Source: measured-core/lib/metrics/Timer.js, line 74 start() Source: measured-core/lib/metrics/Timer.js, line 51 Returns: Returns a Stopwatch that has been started. Type Stopwatch toJSON() toJSON output: meter: See Meter#toJSON output docs above. histogram: See Histogram#toJSON output docs above. Implements: Metric#toJSON Source: measured-core/lib/metrics/Timer.js, line 105 Returns: Type any unref() Unrefs the backing timer. The meter will not keep the event loop alive. Idempotent. Source: measured-core/lib/metrics/Timer.js, line 93 update(value) Updates the internal histogram with value and marks one event on the internal meter. Parameters: Name Type Description value number Source: measured-core/lib/metrics/Timer.js, line 66 Ã— Search results Close "},"tutorial-SignalFx Express Full End to End Example.html":{"id":"tutorial-SignalFx Express Full End to End Example.html","title":"Tutorial: SignalFx Express Full End to End Example","body":" Measured Modules measured-coreunits Classes BinaryHeapCollectionCounterExponentiallyDecayingSampleExponentiallyMovingWeightedAverageGaugeHistogramMeterNoOpMeterReporterSelfReportingMetricsRegistrySettableGaugeSignalFxMetricsReporterSignalFxSelfReportingMetricsRegistryStopwatchTimer Interfaces MetricMetricTypes Tutorials SignalFx Express Full End to End Example Global Global SignalFx Express Full End to End Example Using Measured to instrument OS, Process and Express Metrics.This tutorial shows how to use the measured libraries to fully instrument OS and Node Process metrics as well as create an express middleware. The middleware will measure request count, latency distributions (req/res time histogram) and add dimensions to make it filterable by request method, response status code, request uri path. const os = require('os'); const signalfx = require('signalfx'); const express = require('express'); const { SignalFxMetricsReporter, SignalFxSelfReportingMetricsRegistry } = require('measured-reporting'); const { Stopwatch } = require('measured-core'); const libraryMetadata = require('./package'); // get metadata from package.json const library = libraryMetadata.name; const version = libraryMetadata.version; // report process and os stats 1x per minute const PROCESS_AND_SYSTEM_METRICS_REPORTING_INTERVAL_IN_SECONDS = 1; // Report the request count and histogram stats every 10 seconds const REQUEST_METRICS_REPORTING_INTERVAL_IN_SECONDS = 10; const defaultDimensions = { app: library, app_version: version, env: 'test' }; /** * Get your api key from a secrets provider of some kind. * * Good examples: * * &lt;li&gt; S3 with KMS * &lt;li&gt; Cerberus * &lt;li&gt; AWS Secrets Manager * &lt;li&gt; Vault * &lt;li&gt; Confidant * * Bad examples: * * &lt;li&gt; Checked into SCM in plaintext as a property * &lt;li&gt; Set as a plaintext environment variable * * @return {string} Returns the resolved Signal Fx Api Key */ const apiKeyResolver = () =&gt; { // https://diogomonica.com/2017/03/27/why-you-shouldnt-use-env-variables-for-secret-data/ return process.env.SIGNALFX_API_KEY }; // create the signal fx client const signalFxClient = new signalfx.Ingest(apiKeyResolver(), { userAgents: library }); // create the signal fx reporter with the client const signalFxReporter = new SignalFxMetricsReporter(signalFxClient, { defaultDimensions: defaultDimensions, defaultReportingIntervalInSeconds: 10 }); // create the self reporting metrics registry with the signal fx reporter const metricsRegistry = new SignalFxSelfReportingMetricsRegistry(signalFxReporter); metricsRegistry.getOrCreateGauge( 'os-1m-load-average', () =&gt; { // os.loadavg returns an array [1, 5, 15] mins intervals return os.loadavg()[0] }, {}, PROCESS_AND_SYSTEM_METRICS_REPORTING_INTERVAL_IN_SECONDS ); metricsRegistry.getOrCreateGauge( 'os-free-mem-bytes', () =&gt; { return os.freemem() }, {}, PROCESS_AND_SYSTEM_METRICS_REPORTING_INTERVAL_IN_SECONDS ); metricsRegistry.getOrCreateGauge( 'os-total-mem-bytes', () =&gt; { return os.totalmem() }, {}, PROCESS_AND_SYSTEM_METRICS_REPORTING_INTERVAL_IN_SECONDS ); // https://nodejs.org/api/process.html#process_process_memoryusage metricsRegistry.getOrCreateGauge( 'process-memory-rss', () =&gt; { return process.memoryUsage().rss }, {}, PROCESS_AND_SYSTEM_METRICS_REPORTING_INTERVAL_IN_SECONDS ); // https://nodejs.org/api/process.html#process_process_memoryusage metricsRegistry.getOrCreateGauge( 'process-memory-heap-total', () =&gt; { return process.memoryUsage().heapTotal }, {}, PROCESS_AND_SYSTEM_METRICS_REPORTING_INTERVAL_IN_SECONDS ); // https://nodejs.org/api/process.html#process_process_memoryusage metricsRegistry.getOrCreateGauge( 'process-memory-heap-used', () =&gt; { return process.memoryUsage().heapUsed }, {}, PROCESS_AND_SYSTEM_METRICS_REPORTING_INTERVAL_IN_SECONDS ); // https://nodejs.org/api/process.html#process_process_memoryusage metricsRegistry.getOrCreateGauge( 'process-memory-external', () =&gt; { const mem = process.memoryUsage() as any return mem.hasOwnProperty('external') ? mem.external : 0 }, {}, PROCESS_AND_SYSTEM_METRICS_REPORTING_INTERVAL_IN_SECONDS ); // https://nodejs.org/api/process.html#process_process_uptime metricsRegistry.getOrCreateGauge( 'process-uptime-seconds', () =&gt; { return Math.floor(process.uptime()) }, {}, PROCESS_AND_SYSTEM_METRICS_REPORTING_INTERVAL_IN_SECONDS ); // Now that we have some base system and process metrics wired up, // lets wire up an express middleware that will track request count, latency statics and give us all this // information filterable by http method, response status code and URI path. /** * This middleware is a little interesting because we need to track the time elapsed before we know the status code dimension. * So we will create the Stopwatch manually rather that using the API available on the Timer object itself, see api docs for more info. * * @param metricsRegistry the self reporting metrics registry * @return {Function} Express Middleware */ const createExpressMiddleware = metricsRegistry =&gt; { return (req, res, next) =&gt; { const stopwatch = new Stopwatch(); req.on('end', () =&gt; { const customDimensions = { statusCode: `${res.statusCode}`, path: req.route ? req.route.path : '_unknown', method: req.method }; // create the timer for the request count/latency histogram const requestTimer = metricsRegistry.getOrCreateTimer( 'request', customDimensions, REQUEST_METRICS_REPORTING_INTERVAL_IN_SECONDS ); // stop the request latency counter const time = stopwatch.end(); requestTimer.update(time) }); next() } }; const app = express(); // wire up the metrics middleware app.use(createExpressMiddleware(metricsRegistry)); app.get('/hello', (req, res) =&gt; { res.send('hello world') }); app.get('/path2', (req, res) =&gt; { res.send('path2') }); app.listen(8080, () =&gt; log.info('Example app listening on port 8080!')); Ã— Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
